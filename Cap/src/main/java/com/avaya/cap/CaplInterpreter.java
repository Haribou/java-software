/* Generated By:JavaCC: Do not edit this line. CaplInterpreter.java */
package com.avaya.cap;

import com.avaya.messaging.commons.io.StackTraceLogger;

import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import java.util.Collection;
import java.util.Map;
import java.util.Set;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map.Entry;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.PatternSyntaxException;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.Iterator;
import java.util.Date;
import java.text.SimpleDateFormat;
import com.google.gson.JsonElement;
import com.fasterxml.jackson.databind.JsonNode;
import static com.avaya.messaging.commons.utilities.StringUtils.isEmpty;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.avaya.cap.comparators.*;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import com.avaya.cap.collections.*;

public class CaplInterpreter implements CaplInterpreterConstants {
        private static final CaplValueComparator ASCENDING_CAPL_VALUE_COMPARATOR = new CaplValueComparator(true),
                                                                                         DESCENDING_CAPL_VALUE_COMPARATOR = new CaplValueComparator(false);

        private static final StringComparator ASCENDING_KEY_COMPARATOR = new StringComparator(true),
                                                                                  DESCENDING_KEY_COMPARATOR = new StringComparator(false);

        private static final CaplMapValueComparator ASCENDING_MAP_VALUE_COMPARATOR = new CaplMapValueComparator(true),
                                                                                                DESCENDING_MAP_VALUE_COMPARATOR = new CaplMapValueComparator(false);

        private static final FrequencyMapComparator ASCENDING_FREQUENCY_MAP_COMPARATOR = new FrequencyMapComparator(true),
                                                                                                DESCENDING_FREQUENCY_MAP_COMPARATOR = new FrequencyMapComparator(false);

        private static final Logger LOGGER = Logger.getLogger(CaplInterpreter.class);

        private final static double EPSILON = 0.000001d;

        private final static String ALL_COLLECTION_VALUES_KEY = "*ALL*";

        private final static CaplValue EMPTY_CAPL_VALUE = new CaplValue();

        private static CapHttpClient capHttpClientField = null;

        private static EventRecorder eventRecorderField = null;

        private String getTokenString(Token token)
        {
                return CaplInterpreterConstants.tokenImage[token.kind];
        }

        private void printMessage(Token errorToken, String message, Level logLevel)
        {
                if (errorToken == null)
                        errorToken = token;
                message = "Line " + errorToken.beginLine + ", column " + errorToken.beginColumn + ", token \u005c"" + errorToken.image + "\u005c" (" + getTokenString(errorToken) + "): " + message;
                LOGGER.log(logLevel, message);
        }

        private void printMessage(Token errorToken, String message)
        {
                if (errorToken == null)
                        errorToken = token;
                message = "Line " + errorToken.beginLine + ", column " + errorToken.beginColumn + ", token \u005c"" + errorToken.image + "\u005c" (" + getTokenString(errorToken) + "): " + message;
                LOGGER.error(message);
        }

        private void printMessage(String message, Level logLevel)
        {
                printMessage(token, message, logLevel);
        }

        private void printMessage(String message)
        {
                printMessage(token, message, Level.ERROR);
        }

        private void printOperandDataTypeError(String[] allowedOperandDataTypes, CaplValue operand, Token operator)
        {
                final String allowedDataTypes = String.join(", ", allowedOperandDataTypes);

                printMessage("Data type of operand for \u005c"" + operator + "\u005c" operation must be an element of set { " + allowedDataTypes + " } but is " + operand.getValueDataType(), Level.ERROR);
        }

        private void printOperandDataTypeError(String[] allowedOperandDataTypes, CaplValue operand1, CaplValue operand2, Token operator)
        {
                final String allowedDataTypes = String.join(", ", allowedOperandDataTypes);

                printMessage("Data types of operands for \u005c"" + operator + "\u005c" operation must be an element of set { " + allowedDataTypes + " } but are " + operand1.getValueDataType() + ", " + operand2.getValueDataType(), Level.ERROR);
        }

        private void printOperandDataTypeIncompatibilityError(String message, CaplValue operand1, CaplValue operand2, Token operator)
        {
                printMessage("Operands with data types " + operand1.getValueDataType() + " and " + operand2.getValueDataType() + ", respectively, are incompatible with respect to operator " + operator + ": " + message, Level.ERROR);
        }

        private void printOperandDataTypeError(String[] allowedOperandDataTypes, CaplValue operand, String operator)
        {
                final String allowedDataTypes = String.join(", ", allowedOperandDataTypes);

                printMessage("Data type of operand for \u005c"" + operator + "\u005c" operation must be an element of set { " + allowedDataTypes + " } but is " + operand.getValueDataType(), Level.ERROR);
        }

        private void printOperandDataTypeError(String[] allowedOperandDataTypes, CaplValue operand1, CaplValue operand2, String operator)
        {
                final String allowedDataTypes = String.join(", ", allowedOperandDataTypes);

                printMessage("Data types of operands for \u005c"" + operator + "\u005c" operation must be elements of set { " + allowedDataTypes + " } but are " + operand1.getValueDataType() + ", " + operand2.getValueDataType(), Level.ERROR);
        }

        private boolean isPositiveInteger(CaplValue numberCaplValue)
        {
                return numberCaplValue.getValueDataType() == ValueDataType.NUMBER && numberCaplValue.getNumberValue() > 0d && Math.floor(numberCaplValue.getNumberValue()) == Math.ceil(numberCaplValue.getNumberValue());
        }

        private void makeImmutable(Map<String, CaplValue> caplValues)
        {
                if (caplValues == null)
                        return;
                for (CaplValue oneCaplValue: caplValues.values())
                        oneCaplValue.setMutability(Mutability.CONSTANT);
        }

        private boolean validateMatchingProperties(CaplValue findExpressionCaplValue, boolean caseInsensitiveMatch, boolean partialMatch)
        {
                if (caseInsensitiveMatch && (findExpressionCaplValue.getValueDataType() == ValueDataType.NUMBER || findExpressionCaplValue.getValueDataType() == ValueDataType.BOOLEAN))
                {
                        printOperandDataTypeError(new String[] { "SET", "MAP", "LIST", "STRING" }, findExpressionCaplValue, "CONTAINS - CASE-INSENSITIVE");
                        return false;
                }
                if (partialMatch && !findExpressionCaplValue.hasCollectionValueDataType())
                {
                        printOperandDataTypeError(new String[] { "SET", "MAP", "LIST" }, findExpressionCaplValue, "CONTAINS - PARTIAL");
                        return false;
                }
                return true;
        }

        private CaplValue sortSet(CaplValue caplValuesSet, Token sortOperation)
        {
                final CaplValue sortedCaplValue = CaplCollection.getList(Math.max(1, caplValuesSet.getSetValue().size()));

                final List<CaplValue> setEntriesAsList = sortedCaplValue.getListValue();

                for (CaplValue oneElement: caplValuesSet.getSetValue())
                        setEntriesAsList.add(oneElement);

                try
                {
                        if (sortOperation.kind == CaplInterpreterConstants.SORT_ASC)
                                setEntriesAsList.sort(ASCENDING_CAPL_VALUE_COMPARATOR);
                        else setEntriesAsList.sort(DESCENDING_CAPL_VALUE_COMPARATOR);
                } catch (ClassCastException e)
                {
                        printMessage("SET entries must be consistently numeric or strings");
                        return null;
                }

                return sortedCaplValue;
        }

        private CaplValue sortMap(CaplValue caplValuesMap, Token sortOperation)
        {
                final CaplValue sortedCaplValue = CaplCollection.getMap(Math.max(1, caplValuesMap.getMapValue().size())); // We use the CaplCollection generator to ensure that the map is backed by a LinkedHashMap that is ordered.

                final Map<String, CaplValue> originalCaplValuesMap = caplValuesMap.getMapValue(),
                                                                         sortedCaplValuesMap = sortedCaplValue.getMapValue();

                final List<String> mapKeysAsList;

                final List<Entry<String, CaplValue>> mapEntriesAsList;

                if (sortOperation.kind == CaplInterpreterConstants.SORT_ASC_KEYS || sortOperation.kind == CaplInterpreterConstants.SORT_DESC_KEYS)
                {
                        mapKeysAsList = new ArrayList<String>(originalCaplValuesMap.size());
                        for (String oneKey: originalCaplValuesMap.keySet())
                                mapKeysAsList.add(oneKey);
                        if (sortOperation.kind == CaplInterpreterConstants.SORT_ASC_KEYS)
                                mapKeysAsList.sort(ASCENDING_KEY_COMPARATOR);
                        else mapKeysAsList.sort(DESCENDING_KEY_COMPARATOR);

                        for (String oneKey: mapKeysAsList)
                                sortedCaplValuesMap.put(oneKey, originalCaplValuesMap.get(oneKey));
                }
                else
                {
                        mapEntriesAsList = new ArrayList<Entry<String, CaplValue>>(originalCaplValuesMap.size());
                        for (Entry<String, CaplValue> oneEntry: originalCaplValuesMap.entrySet())
                                mapEntriesAsList.add(oneEntry);
                        try
                        {
                                if (sortOperation.kind == CaplInterpreterConstants.SORT_ASC_VALUES)
                                        mapEntriesAsList.sort(ASCENDING_MAP_VALUE_COMPARATOR);
                                else mapEntriesAsList.sort(DESCENDING_MAP_VALUE_COMPARATOR);
                        } catch (ClassCastException e)
                        {
                                printMessage("MAP entries must be consistently numeric or strings");
                                return null;
                        }
                        for (Entry<String, CaplValue> oneEntry: mapEntriesAsList)
                                sortedCaplValuesMap.put(oneEntry.getKey(), oneEntry.getValue());
                }

                return sortedCaplValue;
        }

        private CaplValue sortList(CaplValue caplValuesList, Token sortOperation)
        {
                final CaplValue sortedCaplValue = CaplCollection.getList(Math.max(1, caplValuesList.getCapacity()));

                final List<CaplValue> sortedCaplValuesList = sortedCaplValue.getListValue();

                for (CaplValue oneElement: caplValuesList.getListValue())
                        sortedCaplValuesList.add(oneElement);

                try
                {
                        if (sortOperation.kind == CaplInterpreterConstants.SORT_ASC)
                                sortedCaplValuesList.sort(ASCENDING_CAPL_VALUE_COMPARATOR);
                        else sortedCaplValuesList.sort(DESCENDING_CAPL_VALUE_COMPARATOR);
                } catch (ClassCastException e)
                {
                        printMessage("LIST entries must be consistently numeric or strings");
                        return null;
                }

                return sortedCaplValue;
        }

        private CaplValue countOccurrences(CaplValue findExpressionIn, CaplValue findExpression, boolean caseInsensitiveMatch)
        {
                Pattern regexPattern;

                Matcher regexMatcher;

                int numberMatches = 0;

                try
                {
                        if (caseInsensitiveMatch)
                                regexPattern = Pattern.compile(findExpression.getStringValue(), Pattern.CASE_INSENSITIVE);
                        else regexPattern = Pattern.compile(findExpression.getStringValue());
                } catch (PatternSyntaxException e)
                {
                        printMessage("Invalid regular expression \u005c"" + findExpression.getStringValue() + "\u005c"");
                        return null;
                }
                regexMatcher = regexPattern.matcher(findExpressionIn.getStringValue());
                while (regexMatcher.find())
                        numberMatches++;

                return new CaplValue(numberMatches);
        }

        private CaplValue rankCollection(Collection<CaplValue> collection, Token aggregationToken, CaplValue rankingNumber, Token rankingNumberUnit, CaplValue findExpression, boolean caseInsensitiveMatch)
        {
                Map<CaplValue, CaplValue> valueFrequencyMap;

                int rankedNumber;

                Pattern regexPattern = null;

                Matcher regexMatcher;

                String elementAsString;

                CaplValue frequency,
                                  matchedSubstringCaplValue;

                Iterator<Entry<CaplValue, CaplValue>> valueFrequencyIterator;

                List<CaplValue> rankedList;

                HashMap<String, CaplValue> oneRankedListEntry;

                Entry<CaplValue, CaplValue> oneValueFrequencyEntry;

                if (rankingNumber.getValueDataType() == ValueDataType.NUMBER)
                {
                        if (rankingNumberUnit.kind == CaplInterpreterConstants.PCT)
                        {
                            if (rankingNumber.getNumberValue() < 0 || rankingNumber.getNumberValue() > 100)
                            {
                                printMessage("The numeric argument of TOP / BOTTOM must be in the range [0, 100]");
                                        return null;
                            }
                        }
                        else if (Math.ceil(rankingNumber.getNumberValue()) > Math.floor(rankingNumber.getNumberValue()))
                        {
                                printMessage("The numeric argument of TOP / BOTTOM must be an integer");
                                return null;
                        }

                        if (findExpression == null || findExpression.getValueDataType() == ValueDataType.STRING)
                        {
                                valueFrequencyMap = new HashMap<CaplValue, CaplValue>();
                                if (findExpression != null)
                                        try
                                        {
                                                if (caseInsensitiveMatch)
                                                        regexPattern = Pattern.compile(findExpression.getStringValue(), Pattern.CASE_INSENSITIVE);
                                                else regexPattern = Pattern.compile(findExpression.getStringValue());
                                        } catch (PatternSyntaxException e)
                                        {
                                                printMessage("Invalid regular expression \u005c"" + findExpression.getStringValue() + "\u005c"");
                                                return null;
                                        }

                                for (CaplValue oneCollectionElement: collection)
                                {
                                        if (oneCollectionElement.getValueDataType() == ValueDataType.NUMBER ||
                                                oneCollectionElement.getValueDataType() == ValueDataType.STRING && findExpression == null)
                                        {
                                                frequency = valueFrequencyMap.get(oneCollectionElement);
                                                if (frequency == null)
                                                        valueFrequencyMap.put(oneCollectionElement, new CaplValue(1d));
                                                else frequency.addNumberValue(1d);
                                        }
                                        else if (oneCollectionElement.getValueDataType() == ValueDataType.STRING)
                                        {
                                                elementAsString = oneCollectionElement.getStringValue();
                                                regexMatcher = regexPattern.matcher(elementAsString);
                                                while (regexMatcher.find())
                                                {
                                                        matchedSubstringCaplValue = new CaplValue(elementAsString.substring(regexMatcher.start(), regexMatcher.end()));
                                                        frequency = valueFrequencyMap.get(matchedSubstringCaplValue);
                                                        if (frequency == null)
                                                                valueFrequencyMap.put(matchedSubstringCaplValue, new CaplValue(1d));
                                                        else frequency.addNumberValue(1d);
                                                }
                                        }
                                }
                                if (rankingNumberUnit.kind == CaplInterpreterConstants.PCT)
                                        rankedNumber = (int) Math.ceil(valueFrequencyMap.size() * (rankingNumber.getNumberValue() / 100d));
                                else rankedNumber = (int) rankingNumber.getNumberValue();
                                rankedNumber = Math.min(rankedNumber, valueFrequencyMap.size());
                                rankedList = new ArrayList<CaplValue>(rankedNumber);
                                valueFrequencyIterator = valueFrequencyMap.entrySet().iterator();
                                while (valueFrequencyIterator.hasNext())
                                {
                                        oneValueFrequencyEntry = valueFrequencyIterator.next();
                                        oneRankedListEntry = new HashMap<String, CaplValue>();
                                        oneRankedListEntry.put("k", oneValueFrequencyEntry.getKey()); // k = key
                                        oneRankedListEntry.put("f", oneValueFrequencyEntry.getValue()); // f = frequency
                                        rankedList.add(new CaplValue(Mutability.CONSTANT, oneRankedListEntry, Integer.MAX_VALUE));
                                }
                                rankedList.sort(aggregationToken.kind == CaplInterpreterConstants.TOP ? DESCENDING_FREQUENCY_MAP_COMPARATOR : ASCENDING_FREQUENCY_MAP_COMPARATOR);
                                return new CaplValue(Mutability.CONSTANT, rankedList.subList(0, rankedNumber), Integer.MAX_VALUE);
                        }
                        else
                        {
                                printMessage("The third argument of TOP / BOTTOM, if present, must be a STRING (regular expression)");
                                return null;
                        }
                }
                printMessage("TOP / BOTTOM must have a numeric (ranking) argument");
                return null;
        }

        private CaplValue rankCollection(String text, Token aggregationToken, CaplValue rankingNumber, Token rankingNumberUnit, CaplValue findExpression, boolean caseInsensitiveMatch)
        {
                Map<CaplValue, CaplValue> valueFrequencyMap;

                int rankedNumber;

                Pattern regexPattern = null;

                Matcher regexMatcher;

                CaplValue frequency,
                                  matchedSubstringCaplValue;

                Iterator<Entry<CaplValue, CaplValue>> valueFrequencyIterator;

                List<CaplValue> rankedList;

                HashMap<String, CaplValue> oneRankedListEntry;

                Entry<CaplValue, CaplValue> oneValueFrequencyEntry;

                if (rankingNumber.getValueDataType() == ValueDataType.NUMBER)
                {
                        if (rankingNumberUnit.kind == CaplInterpreterConstants.PCT)
                        {
                            if (rankingNumber.getNumberValue() < 0 || rankingNumber.getNumberValue() > 100)
                            {
                                printMessage("The numeric argument of TOP / BOTTOM must be in the range [0, 100]");
                                        return null;
                            }
                        }
                        else if (Math.ceil(rankingNumber.getNumberValue()) > Math.floor(rankingNumber.getNumberValue()))
                        {
                                printMessage("The numeric argument of TOP / BOTTOM must be an integer");
                                return null;
                        }

                        if (findExpression.getValueDataType() == ValueDataType.STRING)
                        {
                                valueFrequencyMap = new HashMap<CaplValue, CaplValue>();
                                try
                                {
                                        if (caseInsensitiveMatch)
                                                regexPattern = Pattern.compile(findExpression.getStringValue(), Pattern.CASE_INSENSITIVE);
                                        else regexPattern = Pattern.compile(findExpression.getStringValue());
                                } catch (PatternSyntaxException e)
                                {
                                        printMessage("Invalid regular expression \u005c"" + findExpression.getStringValue() + "\u005c"");
                                        return null;
                                }

                                regexMatcher = regexPattern.matcher(text);
                                while (regexMatcher.find())
                                {
                                        matchedSubstringCaplValue = new CaplValue(text.substring(regexMatcher.start(), regexMatcher.end()));
                                        frequency = valueFrequencyMap.get(matchedSubstringCaplValue);
                                        if (frequency == null)
                                                valueFrequencyMap.put(matchedSubstringCaplValue, new CaplValue(1d));
                                        else frequency.addNumberValue(1d);
                                }

                                if (rankingNumberUnit.kind == CaplInterpreterConstants.PCT)
                                        rankedNumber = (int) Math.ceil(valueFrequencyMap.size() * (rankingNumber.getNumberValue() / 100d));
                                else rankedNumber = (int) rankingNumber.getNumberValue();
                                rankedNumber = Math.min(rankedNumber, valueFrequencyMap.size());
                                rankedList = new ArrayList<CaplValue>(rankedNumber);
                                valueFrequencyIterator = valueFrequencyMap.entrySet().iterator();
                                while (valueFrequencyIterator.hasNext())
                                {
                                        oneValueFrequencyEntry = valueFrequencyIterator.next();
                                        oneRankedListEntry = new HashMap<String, CaplValue>();
                                        oneRankedListEntry.put("k", oneValueFrequencyEntry.getKey()); // k = key
                                        oneRankedListEntry.put("f", oneValueFrequencyEntry.getValue()); // f = frequency
                                        rankedList.add(new CaplValue(Mutability.CONSTANT, oneRankedListEntry, Integer.MAX_VALUE));
                                }
                                rankedList.sort(aggregationToken.kind == CaplInterpreterConstants.TOP ? DESCENDING_FREQUENCY_MAP_COMPARATOR : ASCENDING_FREQUENCY_MAP_COMPARATOR);
                                return new CaplValue(Mutability.CONSTANT, rankedList.subList(0, rankedNumber), Integer.MAX_VALUE);
                        }
                        else
                        {
                                printMessage("The third argument of TOP / BOTTOM, if present, must be a STRING (regular expression)");
                                return null;
                        }
                }
                printMessage("TOP / BOTTOM must have a numeric (ranking) argument");
                return null;
        }

        private double getNumericValue(CaplValue caplValue) throws IllegalArgumentException
        {
                switch (caplValue.getValueDataType())
                {
                        case NUMBER: return caplValue.getNumberValue();
                    case STRING: return caplValue.getStringValue().length();
                        case SET: return caplValue.getSetValue().size();
                        case MAP: return caplValue.getMapValue().size();
                        case LIST: return caplValue.getListValue().size();
                        default: printOperandDataTypeError(new String[] { "NUMBER", "SET", "MAP", "LIST", "STRING" }, caplValue, "aggregation operation (collection element must have a numeric value or property [size/length])");
                                         throw new IllegalArgumentException("Argument does not have a numeric property");
                }
        }

        private CaplValue getAggregationValue(CaplValue referencedCaplValue, Token aggregationToken, CaplValue[] aggregationParameterCaplValues)
        {
                double aggregatedValue = 0d,
                           stdDev,
                           alpha,
                           oneMinusAlpha,
                           startOfFirstBucket,
                           bucketWidth;

                double[] valuesToAggregate;

                int[] histogramBuckets;

                int index = 0,
                        numberCoreBuckets,
                        totalNumberBuckets = 0,
                        bucketIndex;

                Map<String, CaplValue> histogram;

                CaplValue histogramCaplValue;

                if (referencedCaplValue.hasCollectionValueDataType())
                        switch (aggregationToken.kind)
                        {
                                case SORT_ASC:
                                case SORT_DESC: switch (referencedCaplValue.getValueDataType())
                                                                {
                                                                        case SET: return sortSet(referencedCaplValue, aggregationToken);
                                                                        case LIST: return sortList(referencedCaplValue, aggregationToken);
                                                                        default: printOperandDataTypeError(new String[] { "SET / LIST" }, referencedCaplValue, "SORT_ASC / SORT_DESC");
                                                                                         return null;
                                                                }
                                case SORT_ASC_KEYS:
                                case SORT_ASC_VALUES:
                                case SORT_DESC_KEYS:
                                case SORT_DESC_VALUES: if (referencedCaplValue.getValueDataType() == ValueDataType.MAP)
                                                                                        return sortMap(referencedCaplValue, aggregationToken);
                                                                           printOperandDataTypeError(new String[] { "MAP" }, referencedCaplValue, "SORT_ASC_KEYS / SORT_ASC_VALUES / SORT_DESC_KEYS / SORT_DESC_VALUES");
                                                                           return null;
                                default: switch (referencedCaplValue.getValueDataType())
                                                 {
                                                        case SET: valuesToAggregate = new double[referencedCaplValue.getSetValue().size()];
                                                                          for (CaplValue oneCollectionElement: referencedCaplValue.getSetValue())
                                                                                        try
                                                                                        {
                                                                                                valuesToAggregate[index++] = getNumericValue(oneCollectionElement);
                                                                                        } catch (Exception e)
                                                                                        {
                                                                                                printOperandDataTypeError(new String[] { "NUMBER", "SET", "MAP", "LIST", "STRING" }, oneCollectionElement, "aggregation operation (collection element must have a numeric value or property [size/length])");
                                                                                                return null;
                                                                                        }
                                                                          break;
                                                        case MAP: valuesToAggregate = new double[referencedCaplValue.getMapValue().size()];
                                                                          for (CaplValue oneCollectionElement: referencedCaplValue.getMapValue().values())
                                                                                        try
                                                                                        {
                                                                                                valuesToAggregate[index++] = getNumericValue(oneCollectionElement);
                                                                                        } catch (Exception e)
                                                                                        {
                                                                                                printOperandDataTypeError(new String[] { "NUMBER", "SET", "MAP", "LIST", "STRING" }, oneCollectionElement, "aggregation operation (collection element must have a numeric value or property [size/length])");
                                                                                                return null;
                                                                                        }
                                                                          break;
                                                        default: valuesToAggregate = new double[referencedCaplValue.getListValue().size()];
                                                                         for (CaplValue oneCollectionElement: referencedCaplValue.getListValue())
                                                                                try
                                                                                {
                                                                                        valuesToAggregate[index++] = getNumericValue(oneCollectionElement);
                                                                                } catch (Exception e)
                                                                                {
                                                                                        printOperandDataTypeError(new String[] { "NUMBER", "SET", "MAP", "LIST", "STRING" }, oneCollectionElement, "aggregation operation (collection element must have a numeric value or property [size/length])");
                                                                                        return null;
                                                                                }
                                                 }

                                                 switch (aggregationToken.kind)
                                                 {
                                                        case SUM: aggregatedValue = 0d;
                                                                          if (valuesToAggregate.length > 0)
                                                                                for (double oneNumber: valuesToAggregate)
                                                                                        aggregatedValue += oneNumber;
                                                                          return new CaplValue(aggregatedValue);
                                                        case MIN: aggregatedValue = Double.MAX_VALUE;
                                                                          if (valuesToAggregate.length > 0)
                                                                                for (double oneNumber: valuesToAggregate)
                                                                                        if (oneNumber < aggregatedValue)
                                                                                                aggregatedValue = oneNumber;
                                                                          return new CaplValue(aggregatedValue);
                                                        case MAX: aggregatedValue = Double.MIN_VALUE;
                                                                          if (valuesToAggregate.length > 0)
                                                                                for (double oneNumber: valuesToAggregate)
                                                                                        if (oneNumber > aggregatedValue)
                                                                                                aggregatedValue = oneNumber;
                                                                          return new CaplValue(aggregatedValue);
                                                        case STD_DEV: aggregatedValue = 0d;
                                                                                  stdDev = 0d;
                                                                                  if (valuesToAggregate.length > 0)
                                                                                  {
                                                                                        for (double oneNumber: valuesToAggregate)
                                                                                                aggregatedValue += oneNumber;
                                                                                        aggregatedValue /= valuesToAggregate.length;
                                                                                        for (double oneNumber: valuesToAggregate)
                                                                                                stdDev += Math.pow(oneNumber - aggregatedValue, 2d);
                                                                                        stdDev /= valuesToAggregate.length;
                                                                                        aggregatedValue = Math.sqrt(stdDev);
                                                                                  }
                                                                                  return new CaplValue(aggregatedValue);
                                                        case HISTO: histogramCaplValue = CaplCollection.getMap(Integer.MAX_VALUE);
                                                                                histogram = histogramCaplValue.getMapValue();
                                                                                if (valuesToAggregate.length > 0)
                                                                                {
                                                                                        startOfFirstBucket = aggregationParameterCaplValues[0].getNumberValue();
                                                                                        numberCoreBuckets = (int) aggregationParameterCaplValues[1].getNumberValue();
                                                                                        totalNumberBuckets = 2 + numberCoreBuckets;
                                                                                        bucketWidth = aggregationParameterCaplValues[2].getNumberValue();
                                                                                        histogramBuckets = new int[totalNumberBuckets];
                                                                                        for (double oneNumber: valuesToAggregate)
                                                                                                if (oneNumber < startOfFirstBucket)
                                                                                                        histogramBuckets[0]++;
                                                                                                else
                                                                                                {
                                                                                                        bucketIndex = (int) Math.floor((oneNumber - startOfFirstBucket) / bucketWidth);
                                                                                                        if (bucketIndex >= numberCoreBuckets)
                                                                                                                histogramBuckets[totalNumberBuckets - 1]++;
                                                                                                        else histogramBuckets[bucketIndex + 1]++;
                                                                                                }
                                                                                        histogram.put("< " + startOfFirstBucket, new CaplValue(histogramBuckets[0]));
                                                                                        for (index = 1; index < totalNumberBuckets - 1; index++)
                                                                                                histogram.put("" + (startOfFirstBucket + (index - 1) * bucketWidth), new CaplValue(histogramBuckets[index]));
                                                                                        histogram.put("> "+ (startOfFirstBucket + numberCoreBuckets * bucketWidth), new CaplValue(histogramBuckets[totalNumberBuckets - 1]));
                                                                                }
                                                                                return histogramCaplValue;
                                                        case AVG: if (valuesToAggregate.length > 0)
                                                                                if (aggregationParameterCaplValues[0] == null)
                                                                            {
                                                                                aggregatedValue = 0d;
                                                                                        for (double oneNumber: valuesToAggregate)
                                                                                                aggregatedValue += oneNumber;
                                                                                        aggregatedValue /= valuesToAggregate.length;
                                                                            }
                                                                            else
                                                                            {
                                                                                aggregatedValue = valuesToAggregate[0];
                                                                                alpha = aggregationParameterCaplValues[0].getNumberValue();
                                                                                oneMinusAlpha = 1d - alpha;
                                                                                for (index = 1; index < valuesToAggregate.length; index++)
                                                                                                aggregatedValue = alpha * valuesToAggregate[index] + oneMinusAlpha * aggregatedValue;
                                                                            }
                                                                          else aggregatedValue = 0d;
                                                                          return new CaplValue(aggregatedValue);
                                                        case AVG_DIFF: if (referencedCaplValue.getValueDataType() == ValueDataType.LIST)
                                                                                   {
                                                                                        aggregatedValue = 0d;
                                                                                        if (valuesToAggregate.length > 1)
                                                                                                        if (aggregationParameterCaplValues[0] == null)
                                                                                                    {
                                                                                                                for (index = 1; index < valuesToAggregate.length; index++)
                                                                                                                        aggregatedValue += Math.abs(valuesToAggregate[index] - valuesToAggregate[index - 1]);
                                                                                                                aggregatedValue /= (valuesToAggregate.length - 1);
                                                                                                    }
                                                                                                    else
                                                                                                    {
                                                                                                        alpha = aggregationParameterCaplValues[0].getNumberValue();
                                                                                                        oneMinusAlpha = 1d - alpha;
                                                                                                        for (index = 1; index < valuesToAggregate.length; index++)
                                                                                                                        aggregatedValue = alpha * Math.abs(valuesToAggregate[index] - valuesToAggregate[index - 1]) + oneMinusAlpha * aggregatedValue;
                                                                                                    }
                                                                                        return new CaplValue(aggregatedValue);
                                                                                   }
                                                                               printOperandDataTypeError(new String[] { "LIST" }, referencedCaplValue, "AVG_DIFF");
                                                                                   return null;
                                                        default: if (referencedCaplValue.getValueDataType() == ValueDataType.LIST)
                                                                     {
                                                                                if (valuesToAggregate.length > 0)
                                                                                        if (aggregationParameterCaplValues[0] == null)
                                                                                    {
                                                                                        aggregatedValue = 0d;
                                                                                                for (index = 1; index < valuesToAggregate.length; index++)
                                                                                                        aggregatedValue += Math.pow(valuesToAggregate[index] - valuesToAggregate[index - 1], 2d);
                                                                                                aggregatedValue = Math.sqrt(aggregatedValue / (valuesToAggregate.length - 1));
                                                                                    }
                                                                                    else
                                                                                    {
                                                                                        aggregatedValue = 0;
                                                                                        alpha = aggregationParameterCaplValues[0].getNumberValue();
                                                                                        oneMinusAlpha = 1d - alpha;
                                                                                        for (index = 1; index < valuesToAggregate.length; index++)
                                                                                                        aggregatedValue = alpha * Math.pow(valuesToAggregate[index] - valuesToAggregate[index - 1], 2d) + oneMinusAlpha * aggregatedValue;
                                                                                                aggregatedValue = Math.sqrt(aggregatedValue);
                                                                                    }
                                                                                else aggregatedValue = 0d;
                                                                                return new CaplValue(aggregatedValue);
                                                                     }
                                                                 printOperandDataTypeError(new String[] { "LIST" }, referencedCaplValue, "AVG_SQR_DIFF");
                                                                     return null;
                                                 }
                        }

                printMessage(aggregationToken, "Unable to aggregate primitive data", Level.ERROR);
                return null;
        }

        private CaplValue getListIndex(CaplValue referencedCaplValue, Token indexToken, CaplValue collectionElementParameterCaplValue)
        {
                int index = 0;

                if (referencedCaplValue.getValueDataType() == ValueDataType.LIST)
                {
                        if (collectionElementParameterCaplValue.hasCollectionValueDataType())
                        {
                                printOperandDataTypeError(new String[] { "NUMBER", "STRING", "BOOLEAN" }, collectionElementParameterCaplValue, "FIRST/LAST_INDEX(...)");
                                return null;
                        }
                        if (indexToken.kind == CaplInterpreterConstants.FIRST_INDEX)
                                for (CaplValue oneListElement: referencedCaplValue.getListValue())
                                {
                                        if (oneListElement.equals(collectionElementParameterCaplValue))
                                                return new CaplValue(index);
                                        index++;
                                }
                        else for (CaplValue oneListElement: referencedCaplValue.getListValue())
                        {
                                if (oneListElement.equals(collectionElementParameterCaplValue))
                                        return new CaplValue(index);
                                index++;
                        }
                        return new CaplValue(-1d);
                 }
                 printOperandDataTypeError(new String[] { "LIST" }, referencedCaplValue, "FIRST_INDEX");
                 return null;
        }

        private CaplValue getValue(Token referenceValueToken, Map<String, CaplValue> stateCaplValues)
        {
                final String referencedValue = referenceValueToken.toString();

                switch (referenceValueToken.kind)
                {
                    case NUMBER: return new CaplValue(Double.parseDouble(referencedValue));
                    case NUM_EVENTS: if (stateCaplValues.containsKey("*numberEvents*"))
                                                        return new CaplValue(stateCaplValues.get("*numberEvents*").getNumberValue());
                                                 printMessage(referenceValueToken, "*numberEvents* is not present in the entity state, indicating an invalid persistent entity state");
                                                         return null;
                    case NOW: return stateCaplValues.get("*now*");
                        case STRING: return new CaplValue(referencedValue.substring(1, referencedValue.length() - 1));
                        default: return new CaplValue(Boolean.parseBoolean(referencedValue));
                }
        }

        private CaplValue collectionContainsText(Collection<CaplValue> collection, CaplValue findExpressionCaplValue, boolean caseInsensitiveMatch)
        {
                Pattern regexPattern;

                try
                {
                        if (caseInsensitiveMatch)
                                regexPattern = Pattern.compile(findExpressionCaplValue.getStringValue(), Pattern.CASE_INSENSITIVE);
                        else regexPattern = Pattern.compile(findExpressionCaplValue.getStringValue());
                } catch (PatternSyntaxException e)
                {
                        printMessage("Invalid regular expression \u005c"" + findExpressionCaplValue.getStringValue() + "\u005c"");
                        return null;
                }

                for (CaplValue oneCollectionElement: collection)
                        if (oneCollectionElement.getValueDataType() == ValueDataType.STRING && regexPattern.matcher(oneCollectionElement.getStringValue()).matches())
                                return new CaplValue(true);

                return new CaplValue(false);
        }

        private CaplValue textContainsText(String text, String findExpression, boolean caseInsensitiveMatch)
        {
                Pattern regexPattern;

                try
                {
                        if (caseInsensitiveMatch)
                                regexPattern = Pattern.compile(findExpression, Pattern.CASE_INSENSITIVE);
                        else regexPattern = Pattern.compile(findExpression);
                } catch (PatternSyntaxException e)
                {
                        printMessage("Invalid regular expression \u005c"" + findExpression + "\u005c"");
                        return null;
                }

                return new CaplValue(regexPattern.matcher(text).find());
        }

        private CaplValue collectionContainsCount(Collection<CaplValue> collection, CaplValue findExpressionCaplValue, boolean caseInsensitiveMatch)
        {
                Pattern regexPattern;

                int numberMatches = 0;

                if (findExpressionCaplValue.getValueDataType() == ValueDataType.STRING)
                {
                        try
                        {
                                if (caseInsensitiveMatch)
                                        regexPattern = Pattern.compile(findExpressionCaplValue.getStringValue(), Pattern.CASE_INSENSITIVE);
                                else regexPattern = Pattern.compile(findExpressionCaplValue.getStringValue());
                        } catch (PatternSyntaxException e)
                        {
                                printMessage("Invalid regular expression \u005c"" + findExpressionCaplValue.getStringValue() + "\u005c"");
                                return null;
                        }

                        for (CaplValue oneCollectionElement: collection)
                                if (oneCollectionElement.getValueDataType() == ValueDataType.STRING && regexPattern.matcher(oneCollectionElement.getStringValue()).matches())
                                        numberMatches++;
                }
                else for (CaplValue oneCollectionElement: collection)
                                if (oneCollectionElement.equals(findExpressionCaplValue))
                                        numberMatches++;

                return new CaplValue(numberMatches);
        }

        private CaplValue collectionContainsCount(Set<String> collection, CaplValue findExpressionCaplValue, boolean caseInsensitiveMatch)
        {
                Pattern regexPattern;

                int numberMatches = 0;

                try
                {
                        if (caseInsensitiveMatch)
                                regexPattern = Pattern.compile(findExpressionCaplValue.getStringValue(), Pattern.CASE_INSENSITIVE);
                        else regexPattern = Pattern.compile(findExpressionCaplValue.getStringValue());
                } catch (PatternSyntaxException e)
                {
                        printMessage("Invalid regular expression \u005c"" + findExpressionCaplValue.getStringValue() + "\u005c"");
                        return null;
                }

                for (String oneCollectionElement: collection)
                        if (regexPattern.matcher(oneCollectionElement).matches())
                                numberMatches++;

                return new CaplValue(numberMatches);
        }

        private CaplValue collectionContainsText(Set<String> collection, CaplValue findExpressionCaplValue, boolean caseInsensitiveMatch)
        {
                Pattern regexPattern;

                try
                {
                        if (caseInsensitiveMatch)
                                regexPattern = Pattern.compile(findExpressionCaplValue.getStringValue(), Pattern.CASE_INSENSITIVE);
                        else regexPattern = Pattern.compile(findExpressionCaplValue.getStringValue());
                } catch (PatternSyntaxException e)
                {
                        printMessage("Invalid regular expression \u005c"" + findExpressionCaplValue.getStringValue() + "\u005c"");
                        return null;
                }

                for (String oneCollectionElement: collection)
                {
                        if (regexPattern.matcher(oneCollectionElement).matches())
                                return new CaplValue(true);
                }

                return new CaplValue(false);
        }

        private CaplValue textContainsCollection(String text, Collection<CaplValue> collection, boolean caseInsensitiveMatch, boolean partialMatch)
        {
                int numElements = 0;

                Pattern regexPattern;

                String oneStringElement;

                if (collection.size() == 0)
                        return new CaplValue(true);

                for (CaplValue oneCollectionElement: collection)
                        if (oneCollectionElement.getValueDataType() == ValueDataType.STRING)
                        {
                                numElements++;
                                oneStringElement = oneCollectionElement.getStringValue();

                                try
                                {
                                        if (caseInsensitiveMatch)
                                                regexPattern = Pattern.compile(oneStringElement, Pattern.CASE_INSENSITIVE);
                                        else regexPattern = Pattern.compile(oneStringElement);
                                        if (regexPattern.matcher(text).find())
                                        {
                                                if (partialMatch)
                                                        return new CaplValue(true);
                                        }
                                        else if (!partialMatch)
                                                return new CaplValue(false);
                                } catch (PatternSyntaxException e)
                                {
                                        if (caseInsensitiveMatch)
                                        {
                                                if (text.toLowerCase().indexOf(oneStringElement.toLowerCase()) >= 0)
                                                {
                                                        if (partialMatch)
                                                                return new CaplValue(true);
                                                }
                                                else if (!partialMatch)
                                                        return new CaplValue(false);
                                        }
                                        else if (text.indexOf(oneStringElement) >= 0)
                                        {
                                                if (partialMatch)
                                                        return new CaplValue(true);
                                        }
                                        else if (!partialMatch)
                                                return new CaplValue(false);
                                }
                        }

                if (numElements == 0)
                        return new CaplValue(true);
                if (partialMatch)
                return new CaplValue(false);
        return new CaplValue(true);
        }

        private CaplValue collectionContains(Collection<CaplValue> collection1, Collection<CaplValue> collection2, boolean caseInsensitiveMatch, boolean partialMatch)
        {
                int numElements = 0;

                CaplValue foundMatch;

                if (collection2.size() == 0)
                        return new CaplValue(true);

                for (CaplValue oneCollectionElement: collection2)
                {
                        numElements++;
                        if (oneCollectionElement.getValueDataType() == ValueDataType.STRING)
                        {
                                foundMatch = collectionContainsText(collection1, oneCollectionElement, caseInsensitiveMatch);
                                if (foundMatch == null)
                                        return null;
                                if (foundMatch.getBooleanValue())
                                {
                                        if (partialMatch)
                                                return new CaplValue(true);
                                }
                                else if (!partialMatch)
                                        return new CaplValue(false);

                        }
                        else if (collection1.contains(oneCollectionElement))
                        {
                                if (partialMatch)
                                        return new CaplValue(true);
                        }
                        else if (!partialMatch)
                                return new CaplValue(false);
                }

                if (numElements == 0)
                        return new CaplValue(true);
                if (partialMatch)
                return new CaplValue(false);
        return new CaplValue(true);
        }

        private CaplValue collectionContains(Set<String> collection1, Collection<CaplValue> collection2, boolean caseInsensitiveMatch, boolean partialMatch)
        {
                int numElements = 0;

                CaplValue foundMatch;

                if (collection2.size() == 0)
                        return new CaplValue(true);

                for (CaplValue oneCollectionElement: collection2)
                {
                        numElements++;
                        if (oneCollectionElement.getValueDataType() == ValueDataType.STRING)
                        {
                                foundMatch = collectionContainsText(collection1, oneCollectionElement, caseInsensitiveMatch);
                                if (foundMatch == null)
                                        return null;
                                if (foundMatch.getBooleanValue())
                                {
                                        if (partialMatch)
                                                return new CaplValue(true);
                                }
                                else if (!partialMatch)
                                        return new CaplValue(false);
                        }
                }

                if (numElements == 0)
                        return new CaplValue(true);
                if (partialMatch)
                return new CaplValue(false);
        return new CaplValue(true);
        }

        private CaplValue valueContains(CaplValue referencedCaplValue, CaplValue findExpressionCaplValue, boolean caseInsensitiveMatch, boolean partialMatch)
        {
                if (referencedCaplValue == null)
                {
                        printMessage("Specified referenced value does not exist");
                        return null;
                }
                if (findExpressionCaplValue == null)
                {
                        printMessage("Invalid SET/LIST/STRING CONTAINS element value");
                        return null;
                }
                if (!validateMatchingProperties(findExpressionCaplValue, caseInsensitiveMatch, partialMatch))
                        return null;

                switch (referencedCaplValue.getValueDataType())
                {
                        case SET: switch (findExpressionCaplValue.getValueDataType())
                                          {
                                                        case NUMBER: return new CaplValue(referencedCaplValue.getSetValue().contains(findExpressionCaplValue));
                                                        case STRING: return collectionContainsText(referencedCaplValue.getSetValue(), findExpressionCaplValue, caseInsensitiveMatch);
                                                        case BOOLEAN: return new CaplValue(referencedCaplValue.getSetValue().contains(findExpressionCaplValue));
                                                        case SET: return collectionContains(referencedCaplValue.getSetValue(), findExpressionCaplValue.getSetValue(), caseInsensitiveMatch, partialMatch);
                                                        case LIST: return collectionContains(referencedCaplValue.getSetValue(), findExpressionCaplValue.getListValue(), caseInsensitiveMatch, partialMatch);
                                                        default: printOperandDataTypeError(new String[] { "NUMBER", "STRING", "BOOLEAN", "SET", "LIST" }, findExpressionCaplValue, "CONTAINS");
                                                                         return null;
                                          }
                        case LIST: switch (findExpressionCaplValue.getValueDataType())
                                           {
                                                case NUMBER: return new CaplValue(referencedCaplValue.getListValue().contains(findExpressionCaplValue));
                                                        case STRING: return collectionContainsText(referencedCaplValue.getListValue(), findExpressionCaplValue, caseInsensitiveMatch);
                                                        case BOOLEAN: return new CaplValue(referencedCaplValue.getListValue().contains(findExpressionCaplValue));
                                                        case SET: return collectionContains(referencedCaplValue.getListValue(), findExpressionCaplValue.getSetValue(), caseInsensitiveMatch, partialMatch);
                                                        case LIST: return collectionContains(referencedCaplValue.getListValue(), findExpressionCaplValue.getListValue(), caseInsensitiveMatch, partialMatch);
                                                        default: printOperandDataTypeError(new String[] { "NUMBER", "STRING", "BOOLEAN", "SET", "LIST" }, findExpressionCaplValue, "CONTAINS");
                                                                         return null;
                                           }
                        case STRING: switch (findExpressionCaplValue.getValueDataType())
                                             {
                                                case STRING: return textContainsText(referencedCaplValue.getStringValue(), findExpressionCaplValue.getStringValue(), caseInsensitiveMatch);
                                                        case SET: return textContainsCollection(referencedCaplValue.getStringValue(), findExpressionCaplValue.getSetValue(), caseInsensitiveMatch, partialMatch);
                                                        case LIST: return textContainsCollection(referencedCaplValue.getStringValue(), findExpressionCaplValue.getListValue(), caseInsensitiveMatch, partialMatch);
                                                        default: printOperandDataTypeError(new String[] { "STRING", "SET", "LIST" }, findExpressionCaplValue, "CONTAINS");
                                                                         return null;
                                             }
                        default: printOperandDataTypeError(new String[] { "SET", "LIST", "STRING" }, referencedCaplValue, "CONTAINS");
                                         return null;
                }
        }

        private CaplValue containsKeys(CaplValue referencedCaplValue, CaplValue findExpressionCaplValue, boolean caseInsensitiveMatch, boolean partialMatch)
        {
                if (referencedCaplValue == null)
                {
                        printMessage("Specified referenced value does not exist");
                        return null;
                }
                if (findExpressionCaplValue == null)
                {
                        printMessage("Invalid MAP KEY CONTAINS value");
                        return null;
                }
                if (!validateMatchingProperties(findExpressionCaplValue, caseInsensitiveMatch, partialMatch))
                        return null;

                if (referencedCaplValue.getValueDataType() == ValueDataType.MAP)
                        switch (findExpressionCaplValue.getValueDataType())
                        {
                                case STRING: return collectionContainsText(referencedCaplValue.getMapValue().keySet(), findExpressionCaplValue, caseInsensitiveMatch);
                                case SET: return collectionContains(referencedCaplValue.getMapValue().keySet(), findExpressionCaplValue.getSetValue(), caseInsensitiveMatch, partialMatch);
                                case LIST: return collectionContains(referencedCaplValue.getMapValue().keySet(), findExpressionCaplValue.getListValue(), caseInsensitiveMatch, partialMatch);
                                default: printOperandDataTypeError(new String[] { "STRING", "SET", "LIST" }, findExpressionCaplValue, "CONTAINS KEYS");
                                                 return null;
                        }

                printOperandDataTypeError(new String[] { "MAP" }, referencedCaplValue, "CONTAINS KEYS");
                return null;
        }

        private CaplValue containsValues(CaplValue referencedCaplValue, CaplValue findExpressionCaplValue, boolean caseInsensitiveMatch, boolean partialMatch)
        {
                if (referencedCaplValue == null)
                {
                        printMessage("Specified referenced value does not exist");
                        return null;
                }
                if (findExpressionCaplValue == null)
                {
                        printMessage("Invalid MAP VALUE CONTAINS value");
                        return null;
                }
                if (!validateMatchingProperties(findExpressionCaplValue, caseInsensitiveMatch, partialMatch))
                        return null;

                if (referencedCaplValue.getValueDataType() == ValueDataType.MAP)
                    switch (findExpressionCaplValue.getValueDataType())
                        {
                                case NUMBER: return new CaplValue(referencedCaplValue.getMapValue().values().contains(findExpressionCaplValue));
                                case STRING: return collectionContainsText(referencedCaplValue.getMapValue().values(), findExpressionCaplValue, caseInsensitiveMatch);
                                case BOOLEAN:return new CaplValue(referencedCaplValue.getMapValue().values().contains(findExpressionCaplValue));
                                case SET: return collectionContains(referencedCaplValue.getMapValue().values(), findExpressionCaplValue.getSetValue(), caseInsensitiveMatch, partialMatch);
                                case LIST: return collectionContains(referencedCaplValue.getMapValue().values(), findExpressionCaplValue.getListValue(), caseInsensitiveMatch, partialMatch);
                                default: printOperandDataTypeError(new String[] { "NUMBER", "STRING", "BOOLEAN", "SET", "LIST" }, findExpressionCaplValue, "CONTAINS");
                                                 return null;
                        }

                printOperandDataTypeError(new String[] { "MAP" }, referencedCaplValue, "CONTAINS VALUES");
                return null;
        }

        private CaplValue count(CaplValue referencedCaplValue, Token aggregationToken, CaplValue countExpression, boolean caseInsensitiveMatch)
        {
                        switch (aggregationToken.kind)
                        {
                                case COUNT: switch (referencedCaplValue.getValueDataType())
                                                        {
                                                                case STRING: if (countExpression == null)
                                                                                                return new CaplValue(referencedCaplValue.getStringValue().length());
                                                                                         if (countExpression.getValueDataType() == ValueDataType.STRING)
                                                                                                return countOccurrences(referencedCaplValue, countExpression, caseInsensitiveMatch);
                                                                                         printOperandDataTypeError(new String[] { "STRING" }, countExpression, "COUNT");
                                                                                         return null;
                                                                case SET: if (countExpression == null)
                                                                                        return new CaplValue(referencedCaplValue.getSetValue().size());
                                                                                  return collectionContainsCount(referencedCaplValue.getSetValue(), countExpression, caseInsensitiveMatch);
                                                                case LIST: if (countExpression == null)
                                                                                        return new CaplValue(referencedCaplValue.getListValue().size());
                                                                                  return collectionContainsCount(referencedCaplValue.getListValue(), countExpression, caseInsensitiveMatch);
                                                                default: printOperandDataTypeError(new String[] { "STRING, SET, LIST" }, referencedCaplValue, "COUNT");
                                                                                 return null;
                                                        }
                                case COUNT_KEYS: if (referencedCaplValue.getValueDataType() == ValueDataType.MAP)
                                                                 {
                                                                        if (countExpression == null)
                                                                                return new CaplValue(referencedCaplValue.getMapValue().size());
                                                                        if (countExpression.getValueDataType() == ValueDataType.STRING)
                                                                                return collectionContainsCount(referencedCaplValue.getMapValue().keySet(), countExpression, caseInsensitiveMatch);
                                                                        printOperandDataTypeError(new String[] { "STRING" }, countExpression, "COUNT_KEYS");
                                                                        return null;
                                                                 }
                                                                 printOperandDataTypeError(new String[] { "MAP" }, referencedCaplValue, "COUNT_KEYS");
                                                                 return null;
                                default: if (referencedCaplValue.getValueDataType() == ValueDataType.MAP)
                                                        if (countExpression == null)
                                                                return new CaplValue(referencedCaplValue.getMapValue().values().size());
                                                        else return collectionContainsCount(referencedCaplValue.getMapValue().values(), countExpression, caseInsensitiveMatch);
                                                 printOperandDataTypeError(new String[] { "MAP" }, referencedCaplValue, "COUNT_VALUES");
                                                 return null;
                        }
        }

        private boolean addCollectionValue(CaplValue referencedCaplValue, CaplValue collectionKeyCaplValue, CaplValue collectionCaplValueElement, boolean isInitializer)
        {
                Set<CaplValue> setValues;

                Map<String, CaplValue> mapValues;

                List<CaplValue> listValues;

                int removeListElements;

                if (referencedCaplValue == null)
                {
                        printMessage("Specified referenced value does not exist");
                        return false;
                }
                if (referencedCaplValue.getMutability() == Mutability.CONSTANT)
                {
                        printMessage("Specified collection value is a CONSTANT and cannot be modified (added to)");
                        return false;
                }
                if (collectionKeyCaplValue == null)
                {
                        printMessage("Invalid SET or LIST element or MAP key value");
                        return false;
                }

                switch (referencedCaplValue.getValueDataType())
                {
                        case SET: if (collectionCaplValueElement == null)
                                          {
                                                        setValues = referencedCaplValue.getSetValue();
                                                        switch (collectionKeyCaplValue.getValueDataType())
                                                        {
                                                                case NUMBER:
                                                                case STRING:
                                                                case BOOLEAN: setValues.add(collectionKeyCaplValue); return true;
                                                                case SET: setValues.addAll(collectionKeyCaplValue.getSetValue()); return true;
                                                                default: printOperandDataTypeError(new String[] { "NUMBER", "STRING", "BOOLEAN", "SET" }, collectionKeyCaplValue, "ADD");
                                                                                 return false;
                                                        }
                                          }
                                          printMessage("SET ADD operation must have a single operand, not a pair of operands");
                                          return false;
                        case MAP: mapValues = referencedCaplValue.getMapValue();
                                          if (collectionKeyCaplValue.getValueDataType() == ValueDataType.MAP)
                                                        if (collectionCaplValueElement == null)
                                                        {
                                                                mapValues.putAll(collectionKeyCaplValue.getMapValue());
                                                                return true;
                                                        }
                                                        else printMessage("MAP ADD operation must have a single operand if the key is another MAP (i.e., if you are adding a MAP to a MAP), not a pair of operands");
                                          else if (collectionCaplValueElement == null)
                                          {
                                                printMessage("Value to add to the map is null");
                                                return false;
                                          }
                                          else if (collectionKeyCaplValue.getValueDataType() == ValueDataType.NUMBER)
                                          {
                                                        mapValues.put("" + collectionKeyCaplValue.getNumberValue(), collectionCaplValueElement);
                                                        return true;
                                          }
                                          else if (collectionKeyCaplValue.getValueDataType() == ValueDataType.STRING)
                                          {
                                                        mapValues.put(collectionKeyCaplValue.getStringValue(), collectionCaplValueElement);
                                                        return true;
                                          }
                                          else if (collectionKeyCaplValue.getValueDataType() == ValueDataType.BOOLEAN)
                                          {
                                                        mapValues.put("" + collectionKeyCaplValue.getBooleanValue(), collectionCaplValueElement);
                                                        return true;
                                          }
                                          printOperandDataTypeError(new String[] { "STRING" }, collectionKeyCaplValue, "ADD");
                                          return false;
                        case LIST: if (collectionCaplValueElement == null)
                                           {
                                                        listValues = referencedCaplValue.getListValue();
                                                        switch (collectionKeyCaplValue.getValueDataType())
                                                        {
                                                                case NUMBER:
                                                                case STRING:
                                                                case BOOLEAN:
                                                                case SET:
                                                                case MAP: listValues.add(collectionKeyCaplValue); break;
                                                                default: listValues.addAll(collectionKeyCaplValue.getListValue());
                                                        }
                                                        if (!isInitializer && referencedCaplValue.getTimeWindowStart() == 0L)
                                                        {
                                                                removeListElements = listValues.size() - referencedCaplValue.getCapacity();
                                                                while (removeListElements > 0)
                                                                {
                                                                        listValues.remove(0);
                                                                        removeListElements--;
                                                                }
                                                        }
                                                        return true;
                                           }
                                           else printMessage("LIST ADD operation must have a single operand, not a pair of operands");
                                           return false;
                        default: printOperandDataTypeError(new String[] { "SET", "MAP", "LIST" }, referencedCaplValue, "ADD");
                                         return false;
                }
        }

        private boolean removeCollectionValue(CaplValue referencedCaplValue, CaplValue collectionKeyCaplValue)
        {
                Set<CaplValue> setValues;

                Map<String, CaplValue> mapValues;

                List<CaplValue> listValues;

                int listIndex;

                if (referencedCaplValue == null)
                {
                        printMessage("Specified referenced value does not exist");
                        return false;
                }
                if (referencedCaplValue.getMutability() == Mutability.CONSTANT)
                {
                        printMessage("Specified collection value is a CONSTANT and cannot be modified (removed from)");
                        return false;
                }
                if (collectionKeyCaplValue == null)
                {
                        printMessage("Invalid SET or LIST element or MAP key value");
                        return false;
                }

                switch (referencedCaplValue.getValueDataType())
                {
                        case SET: setValues = referencedCaplValue.getSetValue();
                                          switch (collectionKeyCaplValue.getValueDataType())
                                          {
                                                        case NUMBER: setValues.remove(collectionKeyCaplValue); return true;
                                                        case STRING: if (isEmpty(collectionKeyCaplValue.getStringValue()))
                                                                                 {
                                                                                        printMessage("STRING key for collection operation must not be empty");
                                                                                        return false;
                                                                                 }
                                                                                 if (collectionKeyCaplValue.getStringValue().equals(ALL_COLLECTION_VALUES_KEY))
                                                                                        setValues.clear();
                                                                                 else setValues.remove(collectionKeyCaplValue);
                                                                                 return true;
                                                        case BOOLEAN: setValues.remove(collectionKeyCaplValue); return true;
                                                        case SET: setValues.removeAll(collectionKeyCaplValue.getSetValue()); return true;
                                                        default: printOperandDataTypeError(new String[] { "NUMBER", "STRING", "BOOLEAN", "SET" }, collectionKeyCaplValue, "REMOVE");
                                                                         return false;
                                          }
                        case MAP: mapValues = referencedCaplValue.getMapValue();
                                          if (collectionKeyCaplValue.getValueDataType() == ValueDataType.STRING)
                                          {
                                             if (isEmpty(collectionKeyCaplValue.getStringValue()))
                                                 {
                                                        printMessage("STRING key for collection operation must not be empty");
                                                        return false;
                                                 }
                                                 if (collectionKeyCaplValue.getStringValue().equals(ALL_COLLECTION_VALUES_KEY))
                                                        mapValues.clear();
                                                 else mapValues.remove(collectionKeyCaplValue.getStringValue());
                                                 return true;
                                          }
                                          printOperandDataTypeError(new String[] { "STRING", "MAP" }, collectionKeyCaplValue, "REMOVE");
                                          return false;
                        case LIST: listValues = referencedCaplValue.getListValue();
                                           if (collectionKeyCaplValue.getValueDataType() == ValueDataType.NUMBER && Double.isNaN(collectionKeyCaplValue.getNumberValue()))
                                           {
                                                        listIndex = listValues.size() - 1;
                                                        listValues.remove(listIndex);
                                                return true;
                                           }
                                           switch (collectionKeyCaplValue.getValueDataType())
                                           {
                                                        case NUMBER: listValues.remove(collectionKeyCaplValue); return true;
                                                        case STRING: if (collectionKeyCaplValue.getStringValue().equals(ALL_COLLECTION_VALUES_KEY))
                                                                                        listValues.clear();
                                                                                 else listValues.remove(collectionKeyCaplValue);
                                                                                 return true;
                                                        case BOOLEAN: listValues.remove(collectionKeyCaplValue); return true;
                                                        case LIST: listValues.removeAll(collectionKeyCaplValue.getListValue()); return true;
                                                        default: printOperandDataTypeError(new String[] { "NUMBER", "STRING", "BOOLEAN", "LIST" }, collectionKeyCaplValue, "REMOVE");
                                                                         return false;
                                           }
                        default: printOperandDataTypeError(new String[] { "SET", "MAP", "LIST" }, referencedCaplValue, "REMOVE");
                                         return false;
                }
        }

        private boolean removeCollectionValues(CaplValue referencedCaplValue)
        {
                if (referencedCaplValue == null)
                {
                        printMessage("Specified referenced value does not exist");
                        return false;
                }
                if (referencedCaplValue.getMutability() == Mutability.CONSTANT)
                {
                        printMessage("Specified collection value is a CONSTANT and cannot be modified (removed from)");
                        return false;
                }

                switch (referencedCaplValue.getValueDataType())
                {
                        case SET: referencedCaplValue.getSetValue().clear(); break;
                        case MAP: referencedCaplValue.getMapValue().clear(); break;
                        case LIST: referencedCaplValue.getListValue().clear(); break;
                        default: printOperandDataTypeError(new String[] { "SET", "MAP", "LIST" }, referencedCaplValue, "REMOVE_ALL");
                                         return false;
                }

                return true;
        }

        private CaplValue parseDate(CaplValue dateCaplValue, CaplValue datePatternCaplValue)
        {
                SimpleDateFormat dateParser;

                if (dateCaplValue == null || datePatternCaplValue == null)
                        return null;

                if (dateCaplValue.getValueDataType() == ValueDataType.STRING)
                {
                        if (datePatternCaplValue.getValueDataType() == ValueDataType.STRING)
                                try
                                {
                                        dateParser = new SimpleDateFormat(datePatternCaplValue.getStringValue());
                                        return new CaplValue(dateParser.parse(dateCaplValue.getStringValue()).getTime()); // Return date as a number of milliseconds since epoch beginning.
                                } catch (Exception e)
                                {
                                        printMessage("Unable to parse date string \u005c"" + dateCaplValue.getStringValue() + "\u005c" with date/time pattern \u005c"" + datePatternCaplValue.getStringValue() + "\u005c"");
                                        return null;
                                }
                        printOperandDataTypeError(new String[] { "STRING" }, datePatternCaplValue, "DATE");
                        return null;
                }

                printOperandDataTypeError(new String[] { "STRING" }, dateCaplValue, "DATE");
                return null;
        }

        private CaplValue formatDate(CaplValue dateCaplValue, CaplValue datePatternCaplValue)
        {
                SimpleDateFormat dateParser;

                if (dateCaplValue == null || datePatternCaplValue == null)
                        return null;

                if (dateCaplValue.getValueDataType() == ValueDataType.STRING)
                        try
                        {
                                dateCaplValue = new CaplValue(Double.parseDouble(dateCaplValue.getStringValue()));
                        } catch (NumberFormatException e)
                        {
                                printOperandDataTypeError(new String[] { "NUMBER", "NUMBER_AS_STRING" }, datePatternCaplValue, "NUMBER_TO_DATE");
                                return null;
                        }
                if (dateCaplValue.getValueDataType() == ValueDataType.NUMBER)
                {
                        if (datePatternCaplValue.getValueDataType() == ValueDataType.STRING)
                                try
                                {
                                        dateParser = new SimpleDateFormat(datePatternCaplValue.getStringValue());
                                        return new CaplValue(dateParser.format(new Date((long) dateCaplValue.getNumberValue())));
                                } catch (Exception e)
                                {
                                        printMessage("Unable to parse date string \u005c"" + dateCaplValue.getNumberValue() + "\u005c" with date/time pattern \u005c"" + datePatternCaplValue.getStringValue() + "\u005c"");
                                        return null;
                                }
                        printOperandDataTypeError(new String[] { "STRING" }, datePatternCaplValue, "NUMBER_TO_DATE");
                        return null;
                }

                printOperandDataTypeError(new String[] { "NUMBER", "NUMBER_AS_STRING" }, dateCaplValue, "NUMBER_TO_DATE");
                return null;
        }

        private String urlEncodeMap(CaplValue mapCaplValue)
        {
                String urlEncodedMap = "",
                           parameterValue;

                for (Entry<String, CaplValue> mapValue: mapCaplValue.getMapValue().entrySet())
                {
                        parameterValue = CapHttpClient.getAsString(mapValue.getValue());
                        if (parameterValue == null)
                        {
                                printMessage("Invalid value \u005c"" + mapValue.getValue() + "\u005c" for map entry \u005c"" + mapValue.getKey() + "\u005c" - map entry value must be of primitive NUMBER, STRING, or BOOLEAN type");
                                return null;
                        }
                        if (urlEncodedMap.length() > 0)
                                urlEncodedMap += "&";
                        try
                        {
                                urlEncodedMap += mapValue.getKey() + "=" + URLEncoder.encode(parameterValue, StandardCharsets.UTF_8.toString());
                        } catch (Exception e)
                        {
                                printMessage("Invalid value \u005c"" + parameterValue + "\u005c" for map entry \u005c"" + mapValue.getKey() + "\u005c" - unable to URLEncode the map entry value");
                                return null;
                        }
                }

                return urlEncodedMap;
        }

        private CaplValue operateOnSet(CaplValue setCaplValue, CaplValue numberCaplValue, Token operator)
        {
                final CaplValue clonedSetCaplValue = CaplCollection.getSet(setCaplValue.getCapacity());

                final Set<CaplValue> setValue = clonedSetCaplValue.getSetValue();

                final double number;

                if (operator.kind == CaplInterpreterConstants.LOG)
                        number = 0d;
                else number = numberCaplValue.getNumberValue();

                for (CaplValue oneSetValue: setCaplValue.getSetValue())
                        if (oneSetValue.getValueDataType() == ValueDataType.NUMBER)
                                switch (operator.kind)
                                {
                                        case PLUS: setValue.add(new CaplValue(oneSetValue.getNumberValue() + number)); break;
                                        case MINUS: setValue.add(new CaplValue(oneSetValue.getNumberValue() - number)); break;
                                        case MULT: setValue.add(new CaplValue(oneSetValue.getNumberValue() * number)); break;
                                        case DIV: setValue.add(new CaplValue(oneSetValue.getNumberValue() / number)); break;
                                        case INT_DIV: setValue.add(new CaplValue(Math.floor(oneSetValue.getNumberValue() / number))); break;
                                        case MODULO: setValue.add(new CaplValue(oneSetValue.getNumberValue() % number)); break;
                                        case LOG: setValue.add(new CaplValue(Math.log(oneSetValue.getNumberValue()))); break;
                                        case ABS: setValue.add(new CaplValue(Math.abs(oneSetValue.getNumberValue()))); break;
                                        case FLOOR: setValue.add(new CaplValue(Math.floor(oneSetValue.getNumberValue()))); break;
                                        case CEIL: setValue.add(new CaplValue(Math.ceil(oneSetValue.getNumberValue()))); break;
                                        default: // EXP
                                                         setValue.add(new CaplValue(Math.pow(oneSetValue.getNumberValue(), number)));
                                }
                        else
                        {
                                printOperandDataTypeError(new String[] { "SET contains non-numeric values, thus performing an numeric function on all elements is not allowed" }, setCaplValue, operator);
                                return null;
                        }

                return clonedSetCaplValue;
        }

        private CaplValue operateOnMap(CaplValue mapCaplValue, CaplValue numberCaplValue, Token operator)
        {
                final CaplValue clonedMapCaplValue = CaplCollection.getMap(mapCaplValue.getCapacity());

                final Map<String, CaplValue> mapValue = clonedMapCaplValue.getMapValue();

                final double number;

                if (operator.kind == CaplInterpreterConstants.LOG)
                        number = 0d;
                else number = numberCaplValue.getNumberValue();

                for (Entry<String, CaplValue> oneMapValue: mapCaplValue.getMapValue().entrySet())
                        if (oneMapValue.getValue().getValueDataType() == ValueDataType.NUMBER)
                                switch (operator.kind)
                                {
                                        case PLUS: mapValue.put(oneMapValue.getKey(), new CaplValue(oneMapValue.getValue().getNumberValue() + number)); break;
                                        case MINUS: mapValue.put(oneMapValue.getKey(), new CaplValue(oneMapValue.getValue().getNumberValue() - number)); break;
                                        case MULT: mapValue.put(oneMapValue.getKey(), new CaplValue(oneMapValue.getValue().getNumberValue() * number)); break;
                                        case DIV: mapValue.put(oneMapValue.getKey(), new CaplValue(oneMapValue.getValue().getNumberValue() / number)); break;
                                        case INT_DIV: mapValue.put(oneMapValue.getKey(), new CaplValue(Math.floor(oneMapValue.getValue().getNumberValue() / number))); break;
                                        case MODULO: mapValue.put(oneMapValue.getKey(), new CaplValue(oneMapValue.getValue().getNumberValue() % number)); break;
                                        case LOG: mapValue.put(oneMapValue.getKey(), new CaplValue(Math.log(oneMapValue.getValue().getNumberValue()))); break;
                                        case ABS: mapValue.put(oneMapValue.getKey(), new CaplValue(Math.abs(oneMapValue.getValue().getNumberValue()))); break;
                                        case FLOOR: mapValue.put(oneMapValue.getKey(), new CaplValue(Math.floor(oneMapValue.getValue().getNumberValue()))); break;
                                        case CEIL: mapValue.put(oneMapValue.getKey(), new CaplValue(Math.ceil(oneMapValue.getValue().getNumberValue()))); break;
                                        default: // EXP
                                                         mapValue.put(oneMapValue.getKey(), new CaplValue(Math.pow(oneMapValue.getValue().getNumberValue(), number)));
                                }
                        else
                        {
                                printOperandDataTypeError(new String[] { "MAP contains non-numeric values, thus performing an numeric function on all elements is not allowed" }, mapCaplValue, operator);
                                return null;
                        }

                return clonedMapCaplValue;
        }

        private CaplValue operateOnList(CaplValue listCaplValue, CaplValue numberCaplValue, Token operator)
        {
                final CaplValue clonedListCaplValue = CaplCollection.getList(listCaplValue.getCapacity());

                final List<CaplValue> listValue = clonedListCaplValue.getListValue();

                final double number;

                if (operator.kind == CaplInterpreterConstants.LOG)
                        number = 0d;
                else number = numberCaplValue.getNumberValue();

                for (CaplValue oneListValue: listCaplValue.getListValue())
                        if (oneListValue.getValueDataType() == ValueDataType.NUMBER)
                                switch (operator.kind)
                                {
                                        case PLUS: listValue.add(new CaplValue(oneListValue.getNumberValue() + number)); break;
                                        case MINUS: listValue.add(new CaplValue(oneListValue.getNumberValue() - number)); break;
                                        case MULT: listValue.add(new CaplValue(oneListValue.getNumberValue() * number)); break;
                                        case DIV: listValue.add(new CaplValue(oneListValue.getNumberValue() / number)); break;
                                        case INT_DIV: listValue.add(new CaplValue(Math.floor(oneListValue.getNumberValue() / number))); break;
                                        case MODULO: listValue.add(new CaplValue(oneListValue.getNumberValue() % number)); break;
                                        case LOG: listValue.add(new CaplValue(Math.log(oneListValue.getNumberValue()))); break;
                                        case ABS: listValue.add(new CaplValue(Math.abs(oneListValue.getNumberValue()))); break;
                                        case FLOOR: listValue.add(new CaplValue(Math.floor(oneListValue.getNumberValue()))); break;
                                        case CEIL: listValue.add(new CaplValue(Math.ceil(oneListValue.getNumberValue()))); break;
                                        default: // EXP
                                                         listValue.add(new CaplValue(Math.pow(oneListValue.getNumberValue(), number)));
                                }
                        else
                        {
                                printOperandDataTypeError(new String[] { "LIST contains non-numeric values, thus performing an numeric function on all elements is not allowed" }, listCaplValue, operator);
                                return null;
                        }

                return clonedListCaplValue;
        }

        public static void setCapHttpClient(CapHttpClient capHttpClient)
        {
                capHttpClientField = capHttpClient;
        }

        public static void setEventRecorder(EventRecorder eventRecorder)
        {
                eventRecorderField = eventRecorder;
        }

        public ObjectNode analyzeEvent(String analysisId, Map<String, CaplValue> analysisStateCaplValues, Map<String, CaplValue> entityStateCaplValues, JsonNode eventObject)
        {
                Map<String, CaplValue> outputCaplValues;

                Set<String> referencedIdentifiers = null;

                final boolean firstExecutionForEntity = entityStateCaplValues.get("*numberEvents*").getNumberValue() == 1d;

                boolean debug;

                CaplValue eventCaplValue;

                if (LOGGER.isTraceEnabled())
                        LOGGER.trace("Starting CAP analysis interpretation...");

                if (firstExecutionForEntity)
                        referencedIdentifiers = new HashSet<String>();

                try
            {
                        eventCaplValue = JsonManager.convertJsonToCaplValue(eventObject, Mutability.CONSTANT);
                        if (eventCaplValue == null)
                                return JsonManager.generateResponseObject("The event object is not valid JSON");

                if (firstExecutionForEntity)
                {
                        if (analysisStateCaplValues.size() == 0)
                                {
                                        if (!settings(analysisStateCaplValues, referencedIdentifiers))
                                                return JsonManager.generateResponseObject("Unable to parse and interpret specified CAP analysis - the \u005c"settings\u005c" section is invalid");
                                        debug = analysisStateCaplValues.get("*debug*").getBooleanValue();
                                // Parse the "constants section" to populate the analysis constants state. If the analysis state is empty because there are no defined constants,
                                // we end up here as well but parsing the constants section in this case is just as fast as skipping it (else branch below). Note that the constants
                                // section needs to be parsed only once for each analysis.
                                if (!constants(analysisStateCaplValues, referencedIdentifiers, debug))
                                        return JsonManager.generateResponseObject("Unable to parse and interpret specified CAP analysis - the \u005c"constants\u005c" section is invalid");
                        }
                        else
                        {
                                debug = analysisStateCaplValues.get("*debug*").getBooleanValue();
                                if (!section(CaplInterpreterConstants.SETTINGS, CaplInterpreterConstants.SEMICOLON, debug)) // Skip "settings" section".
                                        return JsonManager.generateResponseObject("Unable to parse and interpret specified CAP analysis - the \u005c"trace\u005c" section is invalid");
                                if (!section(CaplInterpreterConstants.CONSTANTS, CaplInterpreterConstants.SEMICOLON, debug)) // Skip "constants" section".
                                        return JsonManager.generateResponseObject("Unable to parse and interpret specified CAP analysis - the \u005c"constants\u005c" section is invalid");
                        }
                        entityStateCaplValues.putAll(analysisStateCaplValues);

                        // Need to parse the "variables" section to populate the entity variables state. Note that the variables section must be parsed only once for each entity.
                        if (!variables(entityStateCaplValues, eventCaplValue, referencedIdentifiers, debug))
                                return JsonManager.generateResponseObject("Unable to parse and interpret specified CAP analysis - the \u005c"variables\u005c" section is invalid");
                }
                else
                {
                        debug = analysisStateCaplValues.get("*debug*").getBooleanValue();
                        if (!section(CaplInterpreterConstants.SETTINGS, CaplInterpreterConstants.SEMICOLON, debug)) // Skip "settings" section".
                                return JsonManager.generateResponseObject("Unable to parse and interpret specified CAP analysis - the \u005c"trace\u005c" section is invalid");
                        if (!section(CaplInterpreterConstants.CONSTANTS, CaplInterpreterConstants.SEMICOLON, debug)) // Skip "constants section".
                                return JsonManager.generateResponseObject("Unable to parse and interpret specified CAP analysis - the \u005c"constants\u005c" section is invalid");
                        entityStateCaplValues.putAll(analysisStateCaplValues);

                            if (!section(CaplInterpreterConstants.VARIABLES, CaplInterpreterConstants.SEMICOLON, debug)) // Skip "variables" section.
                                return JsonManager.generateResponseObject("Unable to parse and interpret specified CAP analysis - the \u005c"variables\u005c" section is invalid");
                    }

                    outputCaplValues = rules(entityStateCaplValues, eventCaplValue, referencedIdentifiers, debug);
                if (outputCaplValues == null)
                {
                        LOGGER.error("Failed to parse and interpret CAP analysis");
                        return JsonManager.generateResponseObject("Unable to parse and interpret specified CAP analysis");
                }

                if (analysisStateCaplValues.get("*eventRecording*").getBooleanValue())
                        eventRecorderField.recordJsonObject(analysisId, eventObject);

                if (firstExecutionForEntity)
                        return JsonManager.generateResponseObject("Successfully parsed CAP analysis",
                                                                                                          new String[] { "analysisState", "entityState", "output" },
                                                                                                          new ObjectNode[] {
                                                                                                                                                        JsonManager.caplValuesMapToObjectNode(analysisStateCaplValues, true),
                                                                                                                                                        JsonManager.caplValuesMapToObjectNode(entityStateCaplValues, Mutability.VARIABLE, true),
                                                                                                                                                        JsonManager.caplValuesMapToObjectNode(outputCaplValues, false)
                                                                                                                                           });
                return JsonManager.generateResponseObject("Successfully parsed CAP analysis",
                                                                                                  new String[] { "entityState", "output" },
                                                                                                  new ObjectNode[] {
                                                                                                                                                JsonManager.caplValuesMapToObjectNode(entityStateCaplValues, Mutability.VARIABLE, true),
                                                                                                                                                JsonManager.caplValuesMapToObjectNode(outputCaplValues, false)
                                                                                                                                   });
            } catch (Exception e)
            {
                if (LOGGER.isTraceEnabled())
                        StackTraceLogger.log("Unable to parse and interpret specified CAP analysis", Level.ERROR, e, LOGGER);
                else LOGGER.error("Unable to parse and interpret specified CAP analysis: " + e.getMessage());
                return JsonManager.generateResponseObject("Unable to parse and interpret specified CAP analysis");
                }
        }

  final private boolean section(int skipFromToken, int skipToToken, boolean debug) throws ParseException {
        Token currentToken = token_source.getNextToken();

        if (debug)
                printMessage("Skipping section", Level.TRACE);

        if (currentToken.kind == skipFromToken)
        {
                do
                        currentToken = token_source.getNextToken();
                while(currentToken.kind != CaplInterpreterConstants.EOF && currentToken.kind != skipToToken);

                return currentToken.kind == skipToToken;
        }
        return false;

  }

  final private CaplValue averageParameterExpression(Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Mutability mutability,
                                                                                         Set<String> referencedIdentifiers, Token aggregationToken, boolean evaluate) throws ParseException {
        CaplValue avgParameterCaplValue;
    jj_consume_token(LEFT_PARENTHESIS);
    avgParameterCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
    jj_consume_token(RIGHT_PARENTHESIS);
                if (evaluate)
                {
                        if (avgParameterCaplValue == null)
                                {if (true) return null;}
                        if (avgParameterCaplValue.getValueDataType() != ValueDataType.NUMBER)
                        {
                                printOperandDataTypeError(new String[] { "NUMBER" }, avgParameterCaplValue, aggregationToken);
                                {if (true) return null;}
                        }
                }
                {if (true) return avgParameterCaplValue;}
    throw new Error("Missing return statement in function");
  }

  final private CaplValue webServiceContent(Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Mutability mutability,
                                                                        Set<String> referencedIdentifiers, boolean evaluate) throws ParseException {
        Token operator;

        CaplValue urlCaplValue,
                          queryParametersCaplValue = null,
                          headerParametersCaplValue = null,
                          payloadParametersCaplValue = null,
                          returnCaplValue;

        Map<String, CaplValue> headerParametersMap = null;

        String[] queryParametersArray,
                         nameValueArray;

        String queryParameters;

        JsonElement httpResponse;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case GET:
      operator = jj_consume_token(GET);
      jj_consume_token(LEFT_PARENTHESIS);
      urlCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
      jj_consume_token(COMMA);
      queryParametersCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
      break;
    case POST:
      operator = jj_consume_token(POST);
      jj_consume_token(LEFT_PARENTHESIS);
      urlCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
      jj_consume_token(COMMA);
      queryParametersCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
      jj_consume_token(COMMA);
      payloadParametersCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
                        if (evaluate && payloadParametersCaplValue == null)
                        {
                                printMessage("Invalid payload for HTTP request");
                                {if (true) return null;}
                        }
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
      headerParametersCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
                        if (evaluate && headerParametersCaplValue == null)
                        {
                                printMessage("Invalid headers for HTTP request");
                                {if (true) return null;}
                        }
      break;
    default:
      jj_la1[1] = jj_gen;
      ;
    }
    jj_consume_token(RIGHT_PARENTHESIS);
                if (evaluate)
                {
                    if (urlCaplValue == null)
                    {
                        printMessage("Invalid URL for HTTP request");
                        {if (true) return null;}
                        }
                        if (urlCaplValue.getValueDataType() == ValueDataType.STRING)
                        {
                                if (queryParametersCaplValue == null)
                                {
                                        printMessage("Invalid query parameters for HTTP request");
                                        {if (true) return null;}
                                }
                                if (queryParametersCaplValue.getValueDataType() == ValueDataType.MAP)
                                {
                                        queryParameters = urlEncodeMap(queryParametersCaplValue);
                                        if (queryParameters == null)
                                                {if (true) return null;}
                                }
                                else if (queryParametersCaplValue.getValueDataType() == ValueDataType.STRING)
                                {
                                        queryParameters = queryParametersCaplValue.getStringValue();
                                        if (queryParameters.indexOf('&') >= 0)
                                        {
                                                queryParametersArray = queryParameters.split("&");
                                                if (queryParametersArray != null && queryParametersArray.length > 0)
                                                {
                                                        queryParameters = "";
                                                        for (String queryParameter: queryParametersArray)
                                                        {
                                                                nameValueArray = queryParameter.split("=");
                                                                if (nameValueArray == null || nameValueArray.length != 2)
                                                                {
                                                                        printMessage("Invalid HTTP parameters \u005c"" + queryParameters + "\u005c" - parameters are not in the expected <name>=<value>&<name>=<value>... format");
                                                                        {if (true) return null;}
                                                                }
                                                                if (queryParameters.length() > 0)
                                                                        queryParameters += "&";
                                                                try
                                                                {
                                                                        queryParameters += nameValueArray[0] + "=" + URLEncoder.encode(nameValueArray[1], StandardCharsets.UTF_8.toString());
                                                                } catch (Exception e)
                                                                {
                                                                        printMessage("Invalid HTTP parameter \u005c"" + queryParametersCaplValue.getStringValue() + "\u005c" - unable to URLEncode this string value value");
                                                                        {if (true) return null;}
                                                                }
                                                        }
                                                 }
                                        }
                                }
                                else
                                {
                                        printOperandDataTypeError(new String[] { "MAP", "STRING" }, queryParametersCaplValue, "GET/POST");
                                        {if (true) return null;}
                                }

                                if (headerParametersCaplValue != null)
                                if (headerParametersCaplValue.getValueDataType() == ValueDataType.MAP)
                                        headerParametersMap = headerParametersCaplValue.getMapValue();
                                else
                                        {
                                                printOperandDataTypeError(new String[] { "MAP" }, headerParametersCaplValue, "GET/POST");
                                                {if (true) return null;}
                                        }

                                if (payloadParametersCaplValue != null)
                                        if (!payloadParametersCaplValue.hasCollectionValueDataType())
                                        {
                                                printOperandDataTypeError(new String[] { "SET", "MAP", "LIST" }, payloadParametersCaplValue, "GET/POST");
                                                {if (true) return null;}
                                        }

                                httpResponse = capHttpClientField.httpRequest(operator.kind == CaplInterpreterConstants.GET, urlCaplValue.getStringValue(),
                                                                                                                          queryParameters, headerParametersMap, payloadParametersCaplValue);
                                if (httpResponse == null)
                                {
                                        printMessage("Unable to perform HTTP GET/POST request");
                                        {if (true) return null;}
                                }
                                returnCaplValue = JsonManager.convertJsonToCaplValue(httpResponse, Mutability.VARIABLE);
                                if (returnCaplValue == null)
                                        printMessage("Unable to parse HTTP response");
                                {if (true) return returnCaplValue;}
                }
                        printOperandDataTypeError(new String[] { "STRING" }, urlCaplValue, "GET");
                        {if (true) return null;}
                }
                {if (true) return EMPTY_CAPL_VALUE;}
    throw new Error("Missing return statement in function");
  }

  final private CaplValue aggregation(CaplValue referencedCaplValue, Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Mutability mutability,
                                                          Set<String> referencedIdentifiers, boolean evaluate) throws ParseException {
        Token aggregationToken = null,
                  caseInsensitiveMatch = null;

        CaplValue[] aggregationParameterCaplValues = new CaplValue[3];

        int index;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SUM:
    case AVG:
    case MAX:
    case MIN:
    case STD_DEV:
    case AVG_DIFF:
    case AVG_SQR_DIFF:
    case HISTO:
    case SORT_ASC:
    case SORT_ASC_KEYS:
    case SORT_ASC_VALUES:
    case SORT_DESC:
    case SORT_DESC_KEYS:
    case SORT_DESC_VALUES:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SUM:
        aggregationToken = jj_consume_token(SUM);
        break;
      case MIN:
        aggregationToken = jj_consume_token(MIN);
        break;
      case MAX:
        aggregationToken = jj_consume_token(MAX);
        break;
      case STD_DEV:
        aggregationToken = jj_consume_token(STD_DEV);
        break;
      case SORT_ASC:
        aggregationToken = jj_consume_token(SORT_ASC);
        break;
      case SORT_ASC_KEYS:
        aggregationToken = jj_consume_token(SORT_ASC_KEYS);
        break;
      case SORT_ASC_VALUES:
        aggregationToken = jj_consume_token(SORT_ASC_VALUES);
        break;
      case SORT_DESC:
        aggregationToken = jj_consume_token(SORT_DESC);
        break;
      case SORT_DESC_KEYS:
        aggregationToken = jj_consume_token(SORT_DESC_KEYS);
        break;
      case SORT_DESC_VALUES:
        aggregationToken = jj_consume_token(SORT_DESC_VALUES);
        break;
      case AVG:
      case AVG_DIFF:
      case AVG_SQR_DIFF:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AVG:
          aggregationToken = jj_consume_token(AVG);
          break;
        case AVG_DIFF:
          aggregationToken = jj_consume_token(AVG_DIFF);
          break;
        case AVG_SQR_DIFF:
          aggregationToken = jj_consume_token(AVG_SQR_DIFF);
          break;
        default:
          jj_la1[2] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LEFT_PARENTHESIS:
          aggregationParameterCaplValues[0] = averageParameterExpression(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, aggregationToken, evaluate);
                                        if (evaluate)
                                                if (aggregationParameterCaplValues[0] == null)
                                                        {if (true) return null;}
          break;
        default:
          jj_la1[3] = jj_gen;
          ;
        }
        break;
      case HISTO:
        aggregationToken = jj_consume_token(HISTO);
        jj_consume_token(LEFT_PARENTHESIS);
        aggregationParameterCaplValues[0] = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
        jj_consume_token(COMMA);
        aggregationParameterCaplValues[1] = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
        jj_consume_token(COMMA);
        aggregationParameterCaplValues[2] = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
        jj_consume_token(RIGHT_PARENTHESIS);
                        if (evaluate)
                        {
                                for (index = 0; index < 3; index++)
                                        if (aggregationParameterCaplValues[index] == null)
                                                {if (true) return null;}
                                        else if (aggregationParameterCaplValues[index].getValueDataType() != ValueDataType.NUMBER)
                                        {
                                                printOperandDataTypeError(new String[] { "NUMBER" }, aggregationParameterCaplValues[index], "HISTO");
                                                {if (true) return null;}
                                        }
                                if (!isPositiveInteger(aggregationParameterCaplValues[1]))
                                {
                                        printOperandDataTypeError(new String[] { "INTEGER >= 1" }, aggregationParameterCaplValues[1], "HISTO");
                                        {if (true) return null;}
                                }
                                if (aggregationParameterCaplValues[2].getNumberValue() <= 0d)
                                {
                                        printOperandDataTypeError(new String[] { "NUMBER > 0" }, aggregationParameterCaplValues[2], "HISTO");
                                        {if (true) return null;}
                                }
                        }
        break;
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                if (evaluate)
                        {if (true) return getAggregationValue(referencedCaplValue, aggregationToken, aggregationParameterCaplValues);}
                {if (true) return EMPTY_CAPL_VALUE;}
      break;
    case COUNT:
    case COUNT_KEYS:
    case COUNT_VALUES:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COUNT:
        aggregationToken = jj_consume_token(COUNT);
        break;
      case COUNT_KEYS:
        aggregationToken = jj_consume_token(COUNT_KEYS);
        break;
      case COUNT_VALUES:
        aggregationToken = jj_consume_token(COUNT_VALUES);
        break;
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CASE_INSENSITIVE_MATCH:
        caseInsensitiveMatch = jj_consume_token(CASE_INSENSITIVE_MATCH);
        break;
      default:
        jj_la1[6] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFT_PARENTHESIS:
        jj_consume_token(LEFT_PARENTHESIS);
        aggregationParameterCaplValues[0] = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
        jj_consume_token(RIGHT_PARENTHESIS);
        break;
      default:
        jj_la1[7] = jj_gen;
        ;
      }
                if (evaluate)
                {
                        if (aggregationParameterCaplValues[0] == null || aggregationParameterCaplValues[0].getValueDataType() == ValueDataType.NUMBER ||
                                aggregationParameterCaplValues[0].getValueDataType() == ValueDataType.STRING ||
                                aggregationParameterCaplValues[0].getValueDataType() == ValueDataType.BOOLEAN)
                                {if (true) return count(referencedCaplValue, aggregationToken, aggregationParameterCaplValues[0], caseInsensitiveMatch != null);}
                        printOperandDataTypeError(new String[] { "NUMBER", "STRING", "BOOLEAN" }, aggregationParameterCaplValues[0], "COUNT_XYZ");
                        {if (true) return null;}
                }
                {if (true) return EMPTY_CAPL_VALUE;}
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final private CaplValue collectionManipulation(CaplValue referencedCaplValue, Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Mutability mutability,
                                                                                 Set<String> referencedIdentifiers, boolean evaluate) throws ParseException {
        CaplValue collectionKeyCaplValue = null,
                          collectionElementCaplValue = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ADD:
      jj_consume_token(ADD);
      jj_consume_token(LEFT_PARENTHESIS);
      collectionKeyCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COLON:
        jj_consume_token(COLON);
        collectionElementCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
        break;
      default:
        jj_la1[9] = jj_gen;
        ;
      }
                        if (evaluate)
                        {
                                if (!addCollectionValue(referencedCaplValue, collectionKeyCaplValue, collectionElementCaplValue, false))
                                        {if (true) return null;}
                                collectionElementCaplValue = null;
                        }
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[10] = jj_gen;
          break label_1;
        }
        jj_consume_token(COMMA);
        collectionKeyCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COLON:
          jj_consume_token(COLON);
          collectionElementCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
          break;
        default:
          jj_la1[11] = jj_gen;
          ;
        }
                                if (evaluate)
                                {
                                        if (!addCollectionValue(referencedCaplValue, collectionKeyCaplValue, collectionElementCaplValue, false))
                                                {if (true) return null;}
                                        collectionElementCaplValue = null;
                                }
      }
      jj_consume_token(RIGHT_PARENTHESIS);
      break;
    case REMOVE:
      jj_consume_token(REMOVE);
      jj_consume_token(LEFT_PARENTHESIS);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SET:
      case MAP:
      case LIST:
      case GET:
      case POST:
      case MAX:
      case MIN:
      case NUM_EVENTS:
      case NOW:
      case ABS:
      case CEIL:
      case FLOOR:
      case MINUS:
      case LOG:
      case NOT:
      case NUMBER:
      case STRING:
      case BOOLEAN:
      case IDENTIFIER:
      case EVENT:
      case LEFT_PARENTHESIS:
        collectionKeyCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
                            if (evaluate && !removeCollectionValue(referencedCaplValue, collectionKeyCaplValue))
                                {if (true) return null;}
        label_2:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[12] = jj_gen;
            break label_2;
          }
          jj_consume_token(COMMA);
          collectionKeyCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
                                    if (evaluate && !removeCollectionValue(referencedCaplValue, collectionKeyCaplValue))
                                        {if (true) return null;}
        }
        break;
      default:
        jj_la1[13] = jj_gen;
        ;
      }
      jj_consume_token(RIGHT_PARENTHESIS);
                if (evaluate && collectionKeyCaplValue == null && !removeCollectionValue(referencedCaplValue, new CaplValue(ALL_COLLECTION_VALUES_KEY)))
                            {if (true) return null;}
      break;
    case REMOVE_LAST:
      jj_consume_token(REMOVE_LAST);
                if (evaluate && !removeCollectionValue(referencedCaplValue, new CaplValue(Double.NaN)))
                        {if (true) return null;}
      break;
    case REMOVE_ALL:
      jj_consume_token(REMOVE_ALL);
                        if (evaluate && !removeCollectionValues(referencedCaplValue))
                        {if (true) return null;}
      break;
    default:
      jj_la1[14] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return referencedCaplValue;}
    throw new Error("Missing return statement in function");
  }

  final private CaplValue collectionInitializer(Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Mutability mutability,
                                                                                Set<String> referencedIdentifiers, boolean evaluate) throws ParseException {
        Token dataStructure;

        CaplValue referencedCaplValue,
                          collectionKeyCaplValue = null,
                          collectionElementCaplValue = null,
                          capacityCaplValue = null,
                          timeWindowLengthCaplValue = null;

        boolean hasCapacityValue = false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SET:
    case LIST:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SET:
        dataStructure = jj_consume_token(SET);
        break;
      case LIST:
        dataStructure = jj_consume_token(LIST);
        break;
      default:
        jj_la1[15] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFT_BRACKET:
        jj_consume_token(LEFT_BRACKET);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SET:
        case MAP:
        case LIST:
        case GET:
        case POST:
        case MAX:
        case MIN:
        case NUM_EVENTS:
        case NOW:
        case ABS:
        case CEIL:
        case FLOOR:
        case MINUS:
        case LOG:
        case NOT:
        case NUMBER:
        case STRING:
        case BOOLEAN:
        case IDENTIFIER:
        case EVENT:
        case LEFT_PARENTHESIS:
          capacityCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
                                                                                                                                                                hasCapacityValue = true;
          break;
        default:
          jj_la1[16] = jj_gen;
          ;
        }
        jj_consume_token(RIGHT_BRACKET);
        break;
      case LEFT_BRACE:
        jj_consume_token(LEFT_BRACE);
        timeWindowLengthCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
                                        if (mutability == Mutability.CONSTANT)
                                        {
                                                printMessage("Time-windowed data structures are not permitted as constants", Level.ERROR);
                                                {if (true) return null;}
                                        }
                                        hasCapacityValue = true;
        jj_consume_token(RIGHT_BRACE);
        break;
      default:
        jj_la1[17] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                        if (evaluate)
                        {
                                if (hasCapacityValue && capacityCaplValue == null && timeWindowLengthCaplValue == null)
                                        {if (true) return null;}

                                if (capacityCaplValue == null)
                                        if (timeWindowLengthCaplValue == null)
                                                if (dataStructure.kind == CaplInterpreterConstants.SET)
                                                        referencedCaplValue = CaplCollection.getSet();
                                                else referencedCaplValue = CaplCollection.getList();
                                        else if (isPositiveInteger(timeWindowLengthCaplValue))
                                                        if (dataStructure.kind == CaplInterpreterConstants.SET)
                                                                referencedCaplValue = CaplCollection.getSet(stateCaplValues.get("*now*"), new CaplValue(timeWindowLengthCaplValue.getNumberValue() * 60000d));
                                                        else referencedCaplValue = CaplCollection.getList(stateCaplValues.get("*now*"), new CaplValue(timeWindowLengthCaplValue.getNumberValue() * 60000d));
                                                else
                                                {
                                                        printOperandDataTypeError(new String[] { "INTEGER >= 1" }, timeWindowLengthCaplValue, "SET/LIST[<TIME_WINDOW_LENGTH>]");
                                                        {if (true) return null;}
                                                }
                                else if (isPositiveInteger(capacityCaplValue))
                                                if (dataStructure.kind == CaplInterpreterConstants.SET)
                                                        referencedCaplValue = CaplCollection.getSet(capacityCaplValue);
                                                else referencedCaplValue = CaplCollection.getList(capacityCaplValue);
                                        else
                                        {
                                                printOperandDataTypeError(new String[] { "INTEGER >= 1" }, capacityCaplValue, "SET/LIST[<CAPACITY>]");
                                                {if (true) return null;}
                                        }
                        }
                        else referencedCaplValue = EMPTY_CAPL_VALUE;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFT_PARENTHESIS:
        jj_consume_token(LEFT_PARENTHESIS);
        collectionElementCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
                                if (evaluate && !addCollectionValue(referencedCaplValue, collectionElementCaplValue, null, true))
                                        {if (true) return null;}
        label_3:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[18] = jj_gen;
            break label_3;
          }
          jj_consume_token(COMMA);
          collectionElementCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
                                        if (evaluate && !addCollectionValue(referencedCaplValue, collectionElementCaplValue, null, true))
                                                {if (true) return null;}
        }
        jj_consume_token(RIGHT_PARENTHESIS);
        break;
      default:
        jj_la1[19] = jj_gen;
        ;
      }
      break;
    case MAP:
      jj_consume_token(MAP);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFT_BRACKET:
        jj_consume_token(LEFT_BRACKET);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SET:
        case MAP:
        case LIST:
        case GET:
        case POST:
        case MAX:
        case MIN:
        case NUM_EVENTS:
        case NOW:
        case ABS:
        case CEIL:
        case FLOOR:
        case MINUS:
        case LOG:
        case NOT:
        case NUMBER:
        case STRING:
        case BOOLEAN:
        case IDENTIFIER:
        case EVENT:
        case LEFT_PARENTHESIS:
          capacityCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
                                                                                                                                                                hasCapacityValue = true;
          break;
        default:
          jj_la1[20] = jj_gen;
          ;
        }
        jj_consume_token(RIGHT_BRACKET);
        break;
      case LEFT_BRACE:
        jj_consume_token(LEFT_BRACE);
        timeWindowLengthCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
                                        if (mutability == Mutability.CONSTANT)
                                        {
                                                printMessage("Time-windowed data structures are not permitted as constants", Level.ERROR);
                                                {if (true) return null;}
                                        }
                                        hasCapacityValue = true;
        jj_consume_token(RIGHT_BRACE);
        break;
      default:
        jj_la1[21] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                        if (evaluate)
                        {
                                if (hasCapacityValue && capacityCaplValue == null && timeWindowLengthCaplValue == null)
                                        {if (true) return null;}

                                if (capacityCaplValue == null)
                                        if (timeWindowLengthCaplValue == null)
                                                referencedCaplValue = CaplCollection.getMap();
                                        else if (isPositiveInteger(timeWindowLengthCaplValue))
                                                referencedCaplValue = CaplCollection.getMap(stateCaplValues.get("*now*"), new CaplValue(timeWindowLengthCaplValue.getNumberValue() * 60000d));
                                        else
                                        {
                                                printOperandDataTypeError(new String[] { "INTEGER >= 1" }, timeWindowLengthCaplValue, "MAP[<TIME_WINDOW_LENGTH>]");
                                                {if (true) return null;}
                                        }
                                else if (isPositiveInteger(capacityCaplValue))
                                                referencedCaplValue = CaplCollection.getMap(capacityCaplValue);
                                        else
                                        {
                                                printOperandDataTypeError(new String[] { "INTEGER >= 1" }, timeWindowLengthCaplValue, "MAP[<CAPACITY>]");
                                                {if (true) return null;}
                                        }
                        }
                        else referencedCaplValue = EMPTY_CAPL_VALUE;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFT_PARENTHESIS:
        jj_consume_token(LEFT_PARENTHESIS);
        collectionKeyCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COLON:
          jj_consume_token(COLON);
          collectionElementCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
          break;
        default:
          jj_la1[22] = jj_gen;
          ;
        }
                                if (evaluate)
                                {
                                        if (!addCollectionValue(referencedCaplValue, collectionKeyCaplValue, collectionElementCaplValue, true))
                                                {if (true) return null;}
                                        collectionElementCaplValue = null;
                                }
        label_4:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[23] = jj_gen;
            break label_4;
          }
          jj_consume_token(COMMA);
          collectionKeyCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COLON:
            jj_consume_token(COLON);
            collectionElementCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
            break;
          default:
            jj_la1[24] = jj_gen;
            ;
          }
                                        if (evaluate)
                                        {
                                                if (!addCollectionValue(referencedCaplValue, collectionKeyCaplValue, collectionElementCaplValue, true))
                                                        {if (true) return null;}
                                                collectionElementCaplValue = null;
                                        }
        }
        jj_consume_token(RIGHT_PARENTHESIS);
        break;
      default:
        jj_la1[25] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[26] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return referencedCaplValue;}
    throw new Error("Missing return statement in function");
  }

  final private CaplValue collectionValueContains(CaplValue referencedCaplValue, Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Mutability mutability,
                                                                                  Set<String> referencedIdentifiers, boolean evaluate) throws ParseException {
        Token containsOperator,
                  caseInsensitiveMatch = null;

        CaplValue findExpressionCaplValue = null,
                          resultCaplValue = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CONTAINS_SOME:
      containsOperator = jj_consume_token(CONTAINS_SOME);
      break;
    case CONTAINS:
      containsOperator = jj_consume_token(CONTAINS);
      break;
    case CONTAINS_SOME_KEYS:
      containsOperator = jj_consume_token(CONTAINS_SOME_KEYS);
      break;
    case CONTAINS_KEYS:
      containsOperator = jj_consume_token(CONTAINS_KEYS);
      break;
    case CONTAINS_SOME_VALUES:
      containsOperator = jj_consume_token(CONTAINS_SOME_VALUES);
      break;
    case CONTAINS_VALUES:
      containsOperator = jj_consume_token(CONTAINS_VALUES);
      break;
    default:
      jj_la1[27] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CASE_INSENSITIVE_MATCH:
      caseInsensitiveMatch = jj_consume_token(CASE_INSENSITIVE_MATCH);
      break;
    default:
      jj_la1[28] = jj_gen;
      ;
    }
    jj_consume_token(LEFT_PARENTHESIS);
    findExpressionCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
                if (evaluate)
                {
                        if (containsOperator.kind == CaplInterpreterConstants.CONTAINS_SOME)
                                resultCaplValue = valueContains(referencedCaplValue, findExpressionCaplValue, caseInsensitiveMatch != null, true);
                        else if (containsOperator.kind == CaplInterpreterConstants.CONTAINS)
                                resultCaplValue = valueContains(referencedCaplValue, findExpressionCaplValue, caseInsensitiveMatch != null, false);
                        else if (containsOperator.kind == CaplInterpreterConstants.CONTAINS_SOME_KEYS)
                                resultCaplValue = containsKeys(referencedCaplValue, findExpressionCaplValue, caseInsensitiveMatch != null, true);
                        else if (containsOperator.kind == CaplInterpreterConstants.CONTAINS_KEYS)
                                resultCaplValue = containsKeys(referencedCaplValue, findExpressionCaplValue, caseInsensitiveMatch != null, false);
                        else if (containsOperator.kind == CaplInterpreterConstants.CONTAINS_SOME_VALUES)
                                resultCaplValue = containsValues(referencedCaplValue, findExpressionCaplValue, caseInsensitiveMatch != null, true);
                        else resultCaplValue = containsValues(referencedCaplValue, findExpressionCaplValue, caseInsensitiveMatch != null, false);
                        if (resultCaplValue == null)
                                {if (true) return null;}
                }
                else resultCaplValue = EMPTY_CAPL_VALUE;
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[29] = jj_gen;
        break label_5;
      }
      jj_consume_token(COMMA);
      findExpressionCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers,
                                                                                                                               evaluate && resultCaplValue.getBooleanValue());
                        if (evaluate && resultCaplValue.getBooleanValue())
                        {
                                if (containsOperator.kind == CaplInterpreterConstants.CONTAINS_SOME)
                                        resultCaplValue = valueContains(referencedCaplValue, findExpressionCaplValue, caseInsensitiveMatch != null, true);
                                else if (containsOperator.kind == CaplInterpreterConstants.CONTAINS)
                                        resultCaplValue = valueContains(referencedCaplValue, findExpressionCaplValue, caseInsensitiveMatch != null, false);
                                else if (containsOperator.kind == CaplInterpreterConstants.CONTAINS_SOME_KEYS)
                                        resultCaplValue = containsKeys(referencedCaplValue, findExpressionCaplValue, caseInsensitiveMatch != null, true);
                                else if (containsOperator.kind == CaplInterpreterConstants.CONTAINS_KEYS)
                                        resultCaplValue = containsKeys(referencedCaplValue, findExpressionCaplValue, caseInsensitiveMatch != null, false);
                                else if (containsOperator.kind == CaplInterpreterConstants.CONTAINS_SOME_VALUES)
                                        resultCaplValue = containsValues(referencedCaplValue, findExpressionCaplValue, caseInsensitiveMatch != null, true);
                                else resultCaplValue = containsValues(referencedCaplValue, findExpressionCaplValue, caseInsensitiveMatch != null, false);
                                if (resultCaplValue == null)
                                        {if (true) return null;}
                        }
    }
    jj_consume_token(RIGHT_PARENTHESIS);
                {if (true) return resultCaplValue;}
    throw new Error("Missing return statement in function");
  }

  final private CaplValue topOrBottom(CaplValue referencedCaplValue, Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Mutability mutability,
                                                          Set<String> referencedIdentifiers, boolean evaluate) throws ParseException {
        Token operatorToken,
                  unitToken,
                  caseInsensitiveMatch = null;

        CaplValue numberCaplValue = null,
                          findExpressionCaplValue = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TOP:
      operatorToken = jj_consume_token(TOP);
      break;
    case BOTTOM:
      operatorToken = jj_consume_token(BOTTOM);
      break;
    default:
      jj_la1[30] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CASE_INSENSITIVE_MATCH:
      caseInsensitiveMatch = jj_consume_token(CASE_INSENSITIVE_MATCH);
      break;
    default:
      jj_la1[31] = jj_gen;
      ;
    }
    jj_consume_token(LEFT_PARENTHESIS);
    numberCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
    jj_consume_token(COMMA);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NUM:
      unitToken = jj_consume_token(NUM);
      break;
    case PCT:
      unitToken = jj_consume_token(PCT);
      break;
    default:
      jj_la1[32] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
      findExpressionCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
      break;
    default:
      jj_la1[33] = jj_gen;
      ;
    }
    jj_consume_token(RIGHT_PARENTHESIS);
                if (evaluate)
                        switch (referencedCaplValue.getValueDataType())
                        {
                                case STRING: if (findExpressionCaplValue == null)
                                                         {
                                                                printMessage("TOP / BOTTOM for a string must specify a third parameter (regular expression) that allows a meaningful TOP / BOTTOM quantitative analysis of substrings in the given string");
                                                                {if (true) return null;}
                                                         }
                                                         {if (true) return rankCollection(referencedCaplValue.getStringValue(), operatorToken, numberCaplValue, unitToken, findExpressionCaplValue, caseInsensitiveMatch != null);}
                                case SET: {if (true) return rankCollection(referencedCaplValue.getSetValue(), operatorToken, numberCaplValue, unitToken, findExpressionCaplValue, caseInsensitiveMatch != null);}
                                case MAP: {if (true) return rankCollection(referencedCaplValue.getMapValue().values(), operatorToken, numberCaplValue, unitToken, findExpressionCaplValue, caseInsensitiveMatch != null);}
                                case LIST: {if (true) return rankCollection(referencedCaplValue.getListValue(), operatorToken, numberCaplValue, unitToken, findExpressionCaplValue, caseInsensitiveMatch != null);}
                                default: printOperandDataTypeError(new String[] { "SET", "MAP", "LIST", "STRING" }, referencedCaplValue, "TOP / BOTTOM");
                                                 {if (true) return null;}
                        }
                else {if (true) return EMPTY_CAPL_VALUE;}
    throw new Error("Missing return statement in function");
  }

  final private CaplValue indexOf(CaplValue referencedCaplValue, Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Mutability mutability,
                                                  Set<String> referencedIdentifiers, boolean evaluate) throws ParseException {
        Token indexToken = null;

        CaplValue collectionElementCaplValue = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FIRST_INDEX:
      indexToken = jj_consume_token(FIRST_INDEX);
      break;
    case LAST_INDEX:
      indexToken = jj_consume_token(LAST_INDEX);
      break;
    default:
      jj_la1[34] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(LEFT_PARENTHESIS);
    collectionElementCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
    jj_consume_token(RIGHT_PARENTHESIS);
                if (evaluate)
                        {if (true) return getListIndex(referencedCaplValue, indexToken, collectionElementCaplValue);}
                {if (true) return EMPTY_CAPL_VALUE;}
    throw new Error("Missing return statement in function");
  }

  final private CaplValue collectionElement(CaplValue referencedCaplValue, Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Mutability mutability,
                                                                        Set<String> referencedIdentifiers, boolean evaluate) throws ParseException {
        CaplValue collectionPathCaplValue = null;

        CaplValue listCaplValue,
                          collectionElementCaplValue;

        List<CaplValue> listCaplValues;

        String key;

        if (evaluate)
                if (referencedCaplValue == null)
                {
                        printMessage("Referenced collection element does not exist");
                        return null;
                }
                else if (!referencedCaplValue.hasCollectionValueDataType())
                {
                        printOperandDataTypeError(new String[] { "SET, MAP, LIST" }, referencedCaplValue, "COLLECTION ACCESSOR");
                        return null;
                }
    label_6:
    while (true) {
      jj_consume_token(LEFT_BRACKET);
      collectionPathCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
      jj_consume_token(RIGHT_BRACKET);
                        if (evaluate)
                                if (collectionPathCaplValue == null)
                                        {if (true) return null;}
                                else if (collectionPathCaplValue.getValueDataType() == ValueDataType.STRING)
                                {
                                        key = collectionPathCaplValue.getStringValue();
                                        if (referencedCaplValue.getValueDataType() == ValueDataType.MAP)
                                                if (key.startsWith(">"))
                                                {
                                                        key = key.substring(1).trim();
                                                        if (referencedCaplValue.getCapacity() < Integer.MAX_VALUE)
                                                                listCaplValue = CaplCollection.getList(referencedCaplValue.getCapacity());
                                                        else listCaplValue = CaplCollection.getList();

                                                        listCaplValues = listCaplValue.getListValue();
                                                        for (CaplValue oneMapValue: referencedCaplValue.getMapValue().values())
                                                                if (oneMapValue.getValueDataType() == ValueDataType.MAP)
                                                                {
                                                                        collectionElementCaplValue = oneMapValue.getMapValue().get(key);
                                                                        if (collectionElementCaplValue != null &&
                                                                                collectionElementCaplValue.getValueDataType() != ValueDataType.SET &&
                                                                                collectionElementCaplValue.getValueDataType() != ValueDataType.LIST)
                                                                                listCaplValues.add(collectionElementCaplValue);
                                                                }
                                                        referencedCaplValue = listCaplValue;
                                                }
                                                else
                                                {
                                                        referencedCaplValue = referencedCaplValue.getMapValue().get(key);
                                                        if (referencedCaplValue == null)
                                                                {if (true) return null;}
                                                }
                                        else if (referencedCaplValue.getValueDataType() == ValueDataType.LIST)
                                        {
                                                if (referencedCaplValue.getCapacity() < Integer.MAX_VALUE)
                                                        listCaplValue = CaplCollection.getList(referencedCaplValue.getCapacity());
                                                else listCaplValue = CaplCollection.getList();
                                                listCaplValues = listCaplValue.getListValue();
                                                for (CaplValue oneListElement: referencedCaplValue.getListValue())
                                                        if (oneListElement.getValueDataType() == ValueDataType.MAP)
                                                        {
                                                                collectionElementCaplValue = oneListElement.getMapValue().get(key);
                                                                if (collectionElementCaplValue != null)
                                                                        listCaplValues.add(collectionElementCaplValue);
                                                        }
                                                referencedCaplValue = listCaplValue;
                                        }
                                        else
                                        {
                                                printOperandDataTypeError(new String[] { "MAP", "LIST" }, referencedCaplValue, "STRING COLLECTION ACCESSOR");
                                                {if (true) return null;}
                                        }
                                }
                                else if (collectionPathCaplValue.getValueDataType() == ValueDataType.NUMBER)
                                        if (referencedCaplValue.getValueDataType() == ValueDataType.LIST)
                                        {
                                                listCaplValues = referencedCaplValue.getListValue();
                                                if (collectionPathCaplValue.getNumberValue() < 0d || collectionPathCaplValue.getNumberValue() >= listCaplValues.size())
                                                        {if (true) return null;}
                                                referencedCaplValue = listCaplValues.get((int) collectionPathCaplValue.getNumberValue());
                                        }
                                        else
                                        {
                                                printOperandDataTypeError(new String[] { "LIST" }, referencedCaplValue, "NUMBER COLLECTION ACCESSOR");
                                                {if (true) return null;}
                                        }
                                else
                                {
                                        printOperandDataTypeError(new String[] { "NUMBER", "STRING" }, collectionPathCaplValue, "COLLECTION ACCESSOR");
                                        {if (true) return null;}
                                }
                        else referencedCaplValue = EMPTY_CAPL_VALUE;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFT_BRACKET:
        ;
        break;
      default:
        jj_la1[35] = jj_gen;
        break label_6;
      }
    }
                {if (true) return referencedCaplValue;}
    throw new Error("Missing return statement in function");
  }

  final private CaplValue castFromValue(CaplValue referencedCaplValue, Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Mutability mutability, Set<String> referencedIdentifiers, boolean evaluate) throws ParseException {
        CaplValue datePatternCaplValue = null,
                          timeWindowLengthCaplValue = null,
                          firstTimestampCaplValue = null,
                          timeCaplValue;

        String booleanValue;

        if (referencedCaplValue == null)
                return null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DATE_TO_NUMBER:
      jj_consume_token(DATE_TO_NUMBER);
      jj_consume_token(LEFT_PARENTHESIS);
      datePatternCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
      jj_consume_token(RIGHT_PARENTHESIS);
                if (evaluate)
                        {if (true) return parseDate(referencedCaplValue, datePatternCaplValue);}
                {if (true) return EMPTY_CAPL_VALUE;}
      break;
    case DATE_TO_TIME_WINDOW:
      jj_consume_token(DATE_TO_TIME_WINDOW);
      jj_consume_token(LEFT_PARENTHESIS);
      datePatternCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
      jj_consume_token(COMMA);
      firstTimestampCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
      jj_consume_token(COMMA);
      timeWindowLengthCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
      jj_consume_token(RIGHT_PARENTHESIS);
                if (evaluate)
                {
                        if (firstTimestampCaplValue == null || timeWindowLengthCaplValue == null)
                                {if (true) return null;}
                        if (firstTimestampCaplValue.getValueDataType() == ValueDataType.NUMBER && timeWindowLengthCaplValue.getValueDataType() == ValueDataType.NUMBER)
                        {
                                timeCaplValue = parseDate(referencedCaplValue, datePatternCaplValue);
                                if (timeCaplValue == null)
                                        {if (true) return null;}
                                {if (true) return new CaplValue(Math.floor((timeCaplValue.getNumberValue() - firstTimestampCaplValue.getNumberValue()) / timeWindowLengthCaplValue.getNumberValue()));}
                        }
                        printOperandDataTypeError(new String[] { "NUMBER" }, timeWindowLengthCaplValue, firstTimestampCaplValue, "DATE_TO_TIME_WINDOW");
                        {if (true) return null;}
                }
                {if (true) return EMPTY_CAPL_VALUE;}
      break;
    case STRING_TO_NUMBER:
      jj_consume_token(STRING_TO_NUMBER);
                if (evaluate)
                {
                        if (referencedCaplValue.getValueDataType() == ValueDataType.STRING)
                                try
                                {
                                        {if (true) return new CaplValue(Double.parseDouble(referencedCaplValue.getStringValue()));}
                                } catch (NumberFormatException e)
                                {
                                        printOperandDataTypeError(new String[] { "NUMBER AS STRING" }, referencedCaplValue, "STRING_TO_NUMBER");
                                        {if (true) return null;}
                                }
                        printOperandDataTypeError(new String[] { "STRING" }, referencedCaplValue, "STRING_TO_NUMBER");
                        {if (true) return null;}
                }
                {if (true) return EMPTY_CAPL_VALUE;}
      break;
    case STRING_TO_BOOLEAN:
      jj_consume_token(STRING_TO_BOOLEAN);
                if (evaluate)
                {
                        if (referencedCaplValue.getValueDataType() == ValueDataType.STRING)
                        {
                                booleanValue = referencedCaplValue.getStringValue().toLowerCase();
                                if (booleanValue.equals("true"))
                                        {if (true) return new CaplValue(true);}
                                else if (booleanValue.equals("false"))
                                        {if (true) return new CaplValue(false);}
                                printOperandDataTypeError(new String[] { "BOOLEAN AS STRING" }, referencedCaplValue, "STRING_TO_BOOLEAN");
                                {if (true) return null;}
                        }
                        printOperandDataTypeError(new String[] { "STRING" }, referencedCaplValue, "STRING_TO_BOOLEAN");
                        {if (true) return null;}
                }
                {if (true) return EMPTY_CAPL_VALUE;}
      break;
    case NUMBER_TO_STRING:
      jj_consume_token(NUMBER_TO_STRING);
                if (evaluate)
                {
                        if (referencedCaplValue.getValueDataType() == ValueDataType.NUMBER)
                                {if (true) return new CaplValue("" + referencedCaplValue.getNumberValue());}
                        printOperandDataTypeError(new String[] { "NUMBER" }, referencedCaplValue, "NUMBER_TO_STRING");
                        {if (true) return null;}
                }
                {if (true) return EMPTY_CAPL_VALUE;}
      break;
    case NUMBER_TO_TIME_WINDOW:
      jj_consume_token(NUMBER_TO_TIME_WINDOW);
      jj_consume_token(LEFT_PARENTHESIS);
      firstTimestampCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
      jj_consume_token(COMMA);
      timeWindowLengthCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
      jj_consume_token(RIGHT_PARENTHESIS);
                if (evaluate)
                {
                        if (firstTimestampCaplValue == null || timeWindowLengthCaplValue == null)
                                {if (true) return null;}
                        if (referencedCaplValue.getValueDataType() == ValueDataType.STRING)
                                try
                                {
                                        referencedCaplValue = new CaplValue(Double.parseDouble(referencedCaplValue.getStringValue()));
                                } catch (NumberFormatException e)
                                {
                                        printOperandDataTypeError(new String[] { "NUMBER", "NUMBER AS STRING" }, referencedCaplValue, "NUMBER_TO_TIME_WINDOW");
                                        {if (true) return null;}
                                }
                        if (firstTimestampCaplValue.getValueDataType() == ValueDataType.NUMBER && timeWindowLengthCaplValue.getValueDataType() == ValueDataType.NUMBER)
                                {if (true) return new CaplValue(Math.floor((referencedCaplValue.getNumberValue() - firstTimestampCaplValue.getNumberValue()) / timeWindowLengthCaplValue.getNumberValue()));}
                        printOperandDataTypeError(new String[] { "NUMBER" }, firstTimestampCaplValue, timeWindowLengthCaplValue, "NUMBER_TO_TIME_WINDOW");
                        {if (true) return null;}
                }
                {if (true) return EMPTY_CAPL_VALUE;}
      break;
    case NUMBER_TO_DATE:
      jj_consume_token(NUMBER_TO_DATE);
      jj_consume_token(LEFT_PARENTHESIS);
      datePatternCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
      jj_consume_token(RIGHT_PARENTHESIS);
                if (evaluate)
                        {if (true) return formatDate(referencedCaplValue, datePatternCaplValue);}
                {if (true) return EMPTY_CAPL_VALUE;}
      break;
    default:
      jj_la1[36] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final private CaplValue valueExpression(Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Mutability mutability, Set<String> referencedIdentifiers, boolean evaluate) throws ParseException {
        String identifier = null;

        Token referencedToken = null;

        CaplValue referencedCaplValue;

        long now;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NUM_EVENTS:
    case NOW:
    case NUMBER:
    case STRING:
    case BOOLEAN:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NUM_EVENTS:
        referencedToken = jj_consume_token(NUM_EVENTS);
                                if (eventCaplValue == null)
                                {
                                        printMessage(referencedToken, "Illegal attempt to access number of events at this point");
                                        {if (true) return null;}
                                }
        break;
      case NOW:
        referencedToken = jj_consume_token(NOW);
        break;
      case NUMBER:
        referencedToken = jj_consume_token(NUMBER);
        break;
      case STRING:
        referencedToken = jj_consume_token(STRING);
        break;
      case BOOLEAN:
        referencedToken = jj_consume_token(BOOLEAN);
        break;
      default:
        jj_la1[37] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                        if (evaluate)
                                {if (true) return getValue(referencedToken, stateCaplValues);}
                        {if (true) return EMPTY_CAPL_VALUE;}
      break;
    case GET:
    case POST:
    case IDENTIFIER:
    case EVENT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        referencedToken = jj_consume_token(IDENTIFIER);
                        if (referencedIdentifiers != null)
                        {
                                identifier = referencedToken.toString();
                        referencedIdentifiers.add(identifier);
                    }
                        if (evaluate)
                        {
                                if (referencedIdentifiers == null)
                                        identifier = referencedToken.toString();
                        referencedCaplValue = stateCaplValues.get(identifier);
                                if (referencedCaplValue == null)
                                {
                                        printMessage(referencedToken, "Identififer has not been declared previously");
                                        {if (true) return null;}
                                }
                                if (referencedCaplValue.getTimeWindowStart() > 0L)
                                {
                                        now = (long) stateCaplValues.get("*now*").getNumberValue();
                                        if (now - referencedCaplValue.getTimeWindowStart() > referencedCaplValue.getTimeWindowLength())
                                        {
                                                if (referencedCaplValue.getValueDataType() == ValueDataType.SET)
                                                        referencedCaplValue.getSetValue().clear();
                                                else if(referencedCaplValue.getValueDataType() == ValueDataType.MAP)
                                                        referencedCaplValue.getMapValue().clear();
                                                else referencedCaplValue.getListValue().clear();
                                                referencedCaplValue.setTimeWindowStart(now);
                                        }
                                }
                        }
                        else referencedCaplValue = EMPTY_CAPL_VALUE;
        break;
      case EVENT:
        jj_consume_token(EVENT);
                        if (evaluate)
                                if (eventCaplValue == null)
                                {
                                        printMessage(referencedToken, "Illegal attempt to access event - event may not be accessed at this point");
                                        {if (true) return null;}
                                }
                                else referencedCaplValue = eventCaplValue;
                        else referencedCaplValue = EMPTY_CAPL_VALUE;
        break;
      case GET:
      case POST:
        referencedCaplValue = webServiceContent(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
                        if (evaluate)
                        {
                                if (referencedCaplValue == null)
                                {
                                        printMessage("Unable to retrieve value from Web service");
                                        {if (true) return null;}
                                }
                        }
                        else referencedCaplValue = EMPTY_CAPL_VALUE;
        break;
      default:
        jj_la1[38] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                {if (true) return referencedCaplValue;}
      break;
    default:
      jj_la1[39] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final private CaplValue valueExpression1(Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Mutability mutability, Set<String> referencedIdentifiers, boolean evaluate) throws ParseException {
        CaplValue expressionResult = null,
                      nextExpressionResult;
    expressionResult = valueExpression2(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
                if (expressionResult == null)
                        {if (true) return null;}
                evaluate =  evaluate && (expressionResult.getValueDataType() != ValueDataType.BOOLEAN || !expressionResult.getBooleanValue());
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR:
        ;
        break;
      default:
        jj_la1[40] = jj_gen;
        break label_7;
      }
      jj_consume_token(OR);
                        if (expressionResult.getValueDataType() != ValueDataType.BOOLEAN)
                        {
                                printOperandDataTypeError(new String[] { "BOOLEAN" }, expressionResult, expressionResult, "OR");
                                {if (true) return null;}
                        }
      nextExpressionResult = valueExpression2(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
                        if (evaluate)
                        {
                                if (nextExpressionResult == null)
                                        {if (true) return null;}
                                if (expressionResult.getValueDataType() != nextExpressionResult.getValueDataType())
                                {
                                        printOperandDataTypeError(new String[] { "BOOLEAN" }, nextExpressionResult, nextExpressionResult, "OR");
                                        {if (true) return null;}
                                }
                                expressionResult = new CaplValue(expressionResult.getBooleanValue() || nextExpressionResult.getBooleanValue());
                                evaluate = !nextExpressionResult.getBooleanValue();
                        }
    }
          {if (true) return expressionResult;}
    throw new Error("Missing return statement in function");
  }

  final private CaplValue valueExpression2(Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Mutability mutability, Set<String> referencedIdentifiers, boolean evaluate) throws ParseException {
        CaplValue expressionResult = null,
                      nextExpressionResult;
    expressionResult = valueExpression3(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
                if (expressionResult == null)
                        {if (true) return null;}
                evaluate = evaluate && (expressionResult.getValueDataType() != ValueDataType.BOOLEAN || expressionResult.getBooleanValue());
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        ;
        break;
      default:
        jj_la1[41] = jj_gen;
        break label_8;
      }
      jj_consume_token(AND);
      nextExpressionResult = valueExpression3(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
                        if (evaluate)
                        {
                                if (nextExpressionResult == null)
                                        {if (true) return null;}
                                if (expressionResult.getValueDataType() != nextExpressionResult.getValueDataType() || expressionResult.getValueDataType() != ValueDataType.BOOLEAN)
                                {
                                        printOperandDataTypeError(new String[] { "BOOLEAN" }, expressionResult, nextExpressionResult, "AND");
                                        {if (true) return null;}
                                }
                                expressionResult = new CaplValue(expressionResult.getBooleanValue() && nextExpressionResult.getBooleanValue());
                                evaluate = nextExpressionResult.getBooleanValue();
                        }
    }
          {if (true) return expressionResult;}
    throw new Error("Missing return statement in function");
  }

  final private CaplValue valueExpression3(Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Mutability mutability, Set<String> referencedIdentifiers, boolean evaluate) throws ParseException {
        CaplValue expressionResult = null,
                      nextExpressionResult;

        Token operator,
                  modifier = null;
    expressionResult = valueExpression4(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
                if (expressionResult == null)
                        {if (true) return null;}
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LESS:
      case EQUALS:
      case NOT_EQUALS:
      case GREATER:
        ;
        break;
      default:
        jj_la1[42] = jj_gen;
        break label_9;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUALS:
        operator = jj_consume_token(EQUALS);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CASE_INSENSITIVE_MATCH:
          modifier = jj_consume_token(CASE_INSENSITIVE_MATCH);
          break;
        default:
          jj_la1[43] = jj_gen;
          ;
        }
        break;
      case NOT_EQUALS:
        operator = jj_consume_token(NOT_EQUALS);
        break;
      case GREATER:
        operator = jj_consume_token(GREATER);
        break;
      case LESS:
        operator = jj_consume_token(LESS);
        break;
      default:
        jj_la1[44] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      nextExpressionResult = valueExpression4(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
                        if (evaluate)
                        {
                                if (nextExpressionResult == null)
                                        {if (true) return null;}
                                if (expressionResult.getValueDataType() != nextExpressionResult.getValueDataType())
                                {
                                        printMessage("Incompatible data types of operands for " + getTokenString(operator) + " operation");
                                        {if (true) return null;}
                                }
                                switch (operator.kind)
                                {
                                        case EQUALS: if (expressionResult.getValueDataType() == ValueDataType.NUMBER)
                                                                        expressionResult = new CaplValue(Math.abs(expressionResult.getNumberValue() - nextExpressionResult.getNumberValue()) < EPSILON);
                                                                 else if (expressionResult.getValueDataType() == ValueDataType.STRING)
                                                                        if (modifier == null)
                                                                                expressionResult = new CaplValue(expressionResult.getStringValue().equals(nextExpressionResult.getStringValue()));
                                                                        else expressionResult = new CaplValue(expressionResult.getStringValue().equalsIgnoreCase(nextExpressionResult.getStringValue()));
                                                                 else  if (expressionResult.getValueDataType() == ValueDataType.BOOLEAN)
                                                                        expressionResult = new CaplValue(expressionResult.getBooleanValue() == nextExpressionResult.getBooleanValue());
                                                                 else if (expressionResult.getValueDataType() == ValueDataType.SET)
                                                                        expressionResult = new CaplValue(expressionResult.getSetValue().equals(nextExpressionResult.getSetValue()));
                                                                 else if (expressionResult.getValueDataType() == ValueDataType.MAP)
                                                                        expressionResult = new CaplValue(expressionResult.getMapValue().equals(nextExpressionResult.getMapValue()));
                                                                 else expressionResult = new CaplValue(expressionResult.getListValue().equals(nextExpressionResult.getListValue()));
                                                                 break;
                                        case NOT_EQUALS: if (expressionResult.getValueDataType() == ValueDataType.NUMBER)
                                                                                expressionResult = new CaplValue(Math.abs(expressionResult.getNumberValue() - nextExpressionResult.getNumberValue()) > EPSILON);
                                                                         else if (expressionResult.getValueDataType() == ValueDataType.STRING)
                                                                                if (modifier == null)
                                                                                        expressionResult = new CaplValue(!expressionResult.getStringValue().equals(nextExpressionResult.getStringValue()));
                                                                                else expressionResult = new CaplValue(!expressionResult.getStringValue().equalsIgnoreCase(nextExpressionResult.getStringValue()));
                                                                         else  if (expressionResult.getValueDataType() == ValueDataType.BOOLEAN)
                                                                                expressionResult = new CaplValue(expressionResult.getBooleanValue() != nextExpressionResult.getBooleanValue());
                                                                         else if (expressionResult.getValueDataType() == ValueDataType.SET)
                                                                                expressionResult = new CaplValue(!expressionResult.getSetValue().equals(nextExpressionResult.getSetValue()));
                                                                         else if (expressionResult.getValueDataType() == ValueDataType.MAP)
                                                                                expressionResult = new CaplValue(!expressionResult.getMapValue().equals(nextExpressionResult.getMapValue()));
                                                                         else expressionResult = new CaplValue(!expressionResult.getListValue().equals(nextExpressionResult.getListValue()));
                                                                         break;
                                        case GREATER: if (expressionResult.getValueDataType() == ValueDataType.NUMBER)
                                                                        expressionResult = new CaplValue(expressionResult.getNumberValue() > nextExpressionResult.getNumberValue() + EPSILON);
                                                                  else
                                                                  {
                                                                        printOperandDataTypeError(new String[] { "NUMBER" }, expressionResult, operator);
                                                                        {if (true) return null;}
                                                                  }
                                                                  break;
                                        default: if (expressionResult.getValueDataType() == ValueDataType.NUMBER)
                                                                expressionResult = new CaplValue(expressionResult.getNumberValue() < nextExpressionResult.getNumberValue() - EPSILON);
                                                         else
                                                         {
                                                                printOperandDataTypeError(new String[] { "NUMBER" }, expressionResult, operator);
                                                                {if (true) return null;}
                                                         }
                                }
                        }
                        else expressionResult = new CaplValue(false);
    }
          {if (true) return expressionResult;}
    throw new Error("Missing return statement in function");
  }

  final private CaplValue valueExpression4(Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Mutability mutability, Set<String> referencedIdentifiers, boolean evaluate) throws ParseException {
        CaplValue expressionResult = null,
                      nextExpressionResult;

        Token operator;
    expressionResult = valueExpression5(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
                if (expressionResult == null)
                        {if (true) return null;}
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
        ;
        break;
      default:
        jj_la1[45] = jj_gen;
        break label_10;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        operator = jj_consume_token(PLUS);
        break;
      case MINUS:
        operator = jj_consume_token(MINUS);
        break;
      default:
        jj_la1[46] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      nextExpressionResult = valueExpression5(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
                        if (evaluate)
                        {
                                if (nextExpressionResult == null)
                                        {if (true) return null;}
                                if (operator.kind == CaplInterpreterConstants.PLUS)
                                {
                                        if (expressionResult.getValueDataType() == ValueDataType.NUMBER && nextExpressionResult.getValueDataType() == ValueDataType.NUMBER)
                                                expressionResult = new CaplValue(expressionResult.getNumberValue() + nextExpressionResult.getNumberValue());
                                        else if (expressionResult.getValueDataType() == ValueDataType.STRING && nextExpressionResult.getValueDataType() == ValueDataType.STRING)
                                                expressionResult = new CaplValue(expressionResult.getStringValue() + nextExpressionResult.getStringValue());
                                        else if (expressionResult.getValueDataType() == ValueDataType.NUMBER && nextExpressionResult.getValueDataType() == ValueDataType.STRING)
                                                expressionResult = new CaplValue(expressionResult.getNumberValue() + nextExpressionResult.getStringValue());
                                        else if (expressionResult.getValueDataType() == ValueDataType.STRING && nextExpressionResult.getValueDataType() == ValueDataType.NUMBER)
                                                expressionResult = new CaplValue(expressionResult.getStringValue() + nextExpressionResult.getNumberValue());
                                        else if (expressionResult.getValueDataType() == ValueDataType.SET && nextExpressionResult.getValueDataType() == ValueDataType.SET)
                                                expressionResult = CaplCollection.getCombinedSet(expressionResult, nextExpressionResult);
                                        else if (expressionResult.getValueDataType() == ValueDataType.SET && nextExpressionResult.getValueDataType() == ValueDataType.NUMBER)
                                                expressionResult = operateOnSet(expressionResult, nextExpressionResult, operator);
                                        else if (expressionResult.getValueDataType() == ValueDataType.NUMBER && nextExpressionResult.getValueDataType() == ValueDataType.SET)
                                                expressionResult = operateOnSet(nextExpressionResult, expressionResult, operator);
                                        else if (expressionResult.getValueDataType() == ValueDataType.MAP && nextExpressionResult.getValueDataType() == ValueDataType.MAP)
                                                expressionResult = CaplCollection.getCombinedMap(expressionResult, nextExpressionResult);
                                        else if (expressionResult.getValueDataType() == ValueDataType.MAP && nextExpressionResult.getValueDataType() == ValueDataType.NUMBER)
                                                expressionResult = operateOnMap(expressionResult, nextExpressionResult, operator);
                                        else if (expressionResult.getValueDataType() == ValueDataType.NUMBER && nextExpressionResult.getValueDataType() == ValueDataType.MAP)
                                                expressionResult = operateOnMap(nextExpressionResult, expressionResult, operator);
                                        else if (expressionResult.getValueDataType() == ValueDataType.LIST && nextExpressionResult.getValueDataType() == ValueDataType.LIST)
                                                expressionResult = CaplCollection.getCombinedList(expressionResult, nextExpressionResult);
                                        else if (expressionResult.getValueDataType() == ValueDataType.LIST && nextExpressionResult.getValueDataType() == ValueDataType.NUMBER)
                                                expressionResult = operateOnList(expressionResult, nextExpressionResult, operator);
                                        else if (expressionResult.getValueDataType() == ValueDataType.NUMBER && nextExpressionResult.getValueDataType() == ValueDataType.LIST)
                                                expressionResult = operateOnList(nextExpressionResult, expressionResult, operator);
                                        else
                                        {
                                        printOperandDataTypeError(new String[] { "NUMBER", "STRING", "SET", "MAP", "LIST" }, expressionResult, operator);
                                                {if (true) return null;}
                                        }
                                        if (expressionResult == null)
                                        {
                                                printOperandDataTypeIncompatibilityError("Either both operands must be time-windowed data structures or neither one is; if one is a time-windowed data structure, the time window start times and lengths must be equal", expressionResult, nextExpressionResult, operator);
                                                {if (true) return null;}
                                        }
                                }
                                else
                                {
                                        if (expressionResult.getValueDataType() == ValueDataType.NUMBER && nextExpressionResult.getValueDataType() == ValueDataType.NUMBER)
                                                expressionResult = new CaplValue(expressionResult.getNumberValue() - nextExpressionResult.getNumberValue());
                                        else if (expressionResult.getValueDataType() == ValueDataType.SET && nextExpressionResult.getValueDataType() == ValueDataType.SET)
                                                expressionResult = CaplCollection.getDifferenceSet(expressionResult, nextExpressionResult, false);
                                        else if (expressionResult.getValueDataType() == ValueDataType.SET && nextExpressionResult.getValueDataType() == ValueDataType.NUMBER)
                                                expressionResult = operateOnSet(expressionResult, nextExpressionResult, operator);
                                        else if (expressionResult.getValueDataType() == ValueDataType.MAP && nextExpressionResult.getValueDataType() == ValueDataType.NUMBER)
                                                expressionResult = operateOnMap(expressionResult, nextExpressionResult, operator);
                                        else if (expressionResult.getValueDataType() == ValueDataType.LIST && nextExpressionResult.getValueDataType() == ValueDataType.LIST)
                                                expressionResult = CaplCollection.getDifferenceList(expressionResult, nextExpressionResult, false);
                                        else if (expressionResult.getValueDataType() == ValueDataType.LIST && nextExpressionResult.getValueDataType() == ValueDataType.NUMBER)
                                                expressionResult = operateOnList(expressionResult, nextExpressionResult, operator);
                                        else
                                        {
                                                printOperandDataTypeError(new String[] { "NUMBER",      "SET", "LIST" }, expressionResult, operator);
                                                {if (true) return null;}
                                        }
                                        if (expressionResult == null)
                                                printOperandDataTypeIncompatibilityError("Either both operands must be time-windowed data structures or neither one is; if one is a time-windowed data structure, the time window start times and lengths must be equal", expressionResult, nextExpressionResult, operator);
                                }
                        }
    }
                {if (true) return expressionResult;}
    throw new Error("Missing return statement in function");
  }

  final private CaplValue valueExpression5(Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Mutability mutability, Set<String> referencedIdentifiers, boolean evaluate) throws ParseException {
        CaplValue expressionResult = null,
                      nextExpressionResult;

        Token operator;
    expressionResult = valueExpression6(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
                if (expressionResult == null)
                        {if (true) return null;}
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MULT:
      case DIV:
      case INT_DIV:
      case MODULO:
      case EXP:
        ;
        break;
      default:
        jj_la1[47] = jj_gen;
        break label_11;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MULT:
        operator = jj_consume_token(MULT);
        break;
      case DIV:
        operator = jj_consume_token(DIV);
        break;
      case INT_DIV:
        operator = jj_consume_token(INT_DIV);
        break;
      case MODULO:
        operator = jj_consume_token(MODULO);
        break;
      case EXP:
        operator = jj_consume_token(EXP);
        break;
      default:
        jj_la1[48] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      nextExpressionResult = valueExpression6(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
                        if (evaluate)
                        {
                                if (nextExpressionResult == null)
                                        {if (true) return null;}

                                if (expressionResult.getValueDataType() == nextExpressionResult.getValueDataType())
                                        if (expressionResult.getValueDataType() == ValueDataType.SET)
                                                if (operator.kind == CaplInterpreterConstants.DIV)
                                                        expressionResult = CaplCollection.getDifferenceSet(expressionResult, nextExpressionResult, true);
                                                else
                                                {
                                                        printMessage(operator, "< MULT >, < INT_DIV >, < MODULO >, and < EXP > operations not allowed on two SETs (< DIV > is allowed)");
                                                        {if (true) return null;}
                                                }
                                        else if (expressionResult.getValueDataType() == ValueDataType.LIST)
                                                if (operator.kind == CaplInterpreterConstants.DIV)
                                                        expressionResult = CaplCollection.getDifferenceList(expressionResult, nextExpressionResult, true);
                                                else
                                                {
                                                        printMessage(operator, "< MULT >, < INT_DIV >, < MODULO >, and < EXP > operations not allowed on two SETs (< DIV > is allowed)");
                                                        {if (true) return null;}
                                                }
                                        else if (expressionResult.getValueDataType() == ValueDataType.NUMBER)
                                        {
                                                if (operator.kind == CaplInterpreterConstants.MULT)
                                                        expressionResult = new CaplValue(expressionResult.getNumberValue() * nextExpressionResult.getNumberValue());
                                                else if (operator.kind == CaplInterpreterConstants.EXP)
                                                        expressionResult = new CaplValue(Math.pow(expressionResult.getNumberValue(), nextExpressionResult.getNumberValue()));
                                                else if (nextExpressionResult.getNumberValue() == 0d)
                                                {
                                                        printMessage(operator, "Division by zero");
                                                        {if (true) return null;}
                                                }
                                                else if (operator.kind == CaplInterpreterConstants.DIV)
                                                        expressionResult = new CaplValue(expressionResult.getNumberValue() / nextExpressionResult.getNumberValue());
                                                else if (operator.kind == CaplInterpreterConstants.INT_DIV)
                                                        expressionResult = new CaplValue(Math.floor(expressionResult.getNumberValue() / nextExpressionResult.getNumberValue()));
                                                else expressionResult = new CaplValue(expressionResult.getNumberValue() % nextExpressionResult.getNumberValue());
                                        }
                                        else
                                        {
                                                printOperandDataTypeError(new String[] { "NUMBER",      "SET", "LIST" }, expressionResult, operator);
                                                {if (true) return null;}
                                        }
                                else if (operator.kind == CaplInterpreterConstants.MULT)
                                        if (expressionResult.getValueDataType() == ValueDataType.SET && nextExpressionResult.getValueDataType() == ValueDataType.NUMBER)
                                                expressionResult = operateOnSet(expressionResult, nextExpressionResult, operator);
                                        else if (expressionResult.getValueDataType() == ValueDataType.NUMBER && nextExpressionResult.getValueDataType() == ValueDataType.SET)
                                                expressionResult = operateOnSet(nextExpressionResult, expressionResult, operator);
                                        else if (expressionResult.getValueDataType() == ValueDataType.MAP && nextExpressionResult.getValueDataType() == ValueDataType.NUMBER)
                                                expressionResult = operateOnMap(expressionResult, nextExpressionResult, operator);
                                        else if (expressionResult.getValueDataType() == ValueDataType.NUMBER && nextExpressionResult.getValueDataType() == ValueDataType.MAP)
                                                expressionResult = operateOnMap(nextExpressionResult, expressionResult, operator);
                                        else if (expressionResult.getValueDataType() == ValueDataType.LIST && nextExpressionResult.getValueDataType() == ValueDataType.NUMBER)
                                                expressionResult = operateOnList(expressionResult, nextExpressionResult, operator);
                                        else if (expressionResult.getValueDataType() == ValueDataType.NUMBER && nextExpressionResult.getValueDataType() == ValueDataType.LIST)
                                                expressionResult = operateOnList(nextExpressionResult, expressionResult, operator);
                                        else
                                        {
                                                printOperandDataTypeError(new String[] { "SET/NUMBER", "NUMBER/SET", "MAP/NUMBER", "NUMBER/MAP", "LIST/NUMBER", "NUMBER/LIST" }, expressionResult, nextExpressionResult, operator);
                                                {if (true) return null;}
                                        }
                                else if (expressionResult.getValueDataType() == ValueDataType.SET && nextExpressionResult.getValueDataType() == ValueDataType.NUMBER)
                                {
                                        if (nextExpressionResult.getNumberValue() == 0d)
                                        {
                                                printMessage(operator, "Division by zero");
                                                {if (true) return null;}
                                        }
                                        expressionResult = operateOnSet(expressionResult, nextExpressionResult, operator);
                                }
                                else if (expressionResult.getValueDataType() == ValueDataType.MAP && nextExpressionResult.getValueDataType() == ValueDataType.NUMBER)
                                {
                                        if (nextExpressionResult.getNumberValue() == 0d)
                                        {
                                                printMessage(operator, "Division by zero");
                                                {if (true) return null;}
                                        }
                                        expressionResult = operateOnMap(expressionResult, nextExpressionResult, operator);
                                }
                                else if (expressionResult.getValueDataType() == ValueDataType.LIST && nextExpressionResult.getValueDataType() == ValueDataType.NUMBER)
                                {
                                        if (nextExpressionResult.getNumberValue() == 0d)
                                        {
                                                printMessage(operator, "Division by zero");
                                                {if (true) return null;}
                                        }
                                        expressionResult = operateOnList(expressionResult, nextExpressionResult, operator);
                                }
                                else
                                {
                                        printOperandDataTypeError(new String[] { "SET/NUMBER", "MAP/NUMBER", "LIST/NUMBER" }, expressionResult, nextExpressionResult, operator);
                                        {if (true) return null;}
                                }
                        }
    }
          {if (true) return expressionResult;}
    throw new Error("Missing return statement in function");
  }

  final private CaplValue valueExpression6(Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Mutability mutability, Set<String> referencedIdentifiers, boolean evaluate) throws ParseException {
        CaplValue expressionResult;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT:
      jj_consume_token(NOT);
      expressionResult = valueExpression7(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
                        if (evaluate)
                                if (expressionResult == null)
                                        {if (true) return null;}
                                else if (expressionResult.getValueDataType() == ValueDataType.BOOLEAN)
                                        expressionResult = new CaplValue(!expressionResult.getBooleanValue());
                                else
                                {
                                        printOperandDataTypeError(new String[] { "BOOLEAN" }, expressionResult, "NOT");
                                        {if (true) return null;}
                                }
      break;
    case MINUS:
      jj_consume_token(MINUS);
      expressionResult = valueExpression7(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
                        if (evaluate)
                                if (expressionResult == null)
                                        {if (true) return null;}
                                else if (expressionResult.getValueDataType() == ValueDataType.NUMBER)
                                        expressionResult = new CaplValue(-expressionResult.getNumberValue());
                                else
                                {
                                        printOperandDataTypeError(new String[] { "NUMBER" }, expressionResult, "UNARY MINUS");
                                        {if (true) return null;}
                                }
      break;
    case SET:
    case MAP:
    case LIST:
    case GET:
    case POST:
    case MAX:
    case MIN:
    case NUM_EVENTS:
    case NOW:
    case ABS:
    case CEIL:
    case FLOOR:
    case LOG:
    case NUMBER:
    case STRING:
    case BOOLEAN:
    case IDENTIFIER:
    case EVENT:
    case LEFT_PARENTHESIS:
      expressionResult = valueExpression7(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
      break;
    default:
      jj_la1[49] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return expressionResult;}
    throw new Error("Missing return statement in function");
  }

  final private CaplValue valueExpression7(Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Mutability mutability, Set<String> referencedIdentifiers, boolean evaluate) throws ParseException {
        Token function = null;

        CaplValue expressionResult = null,
                          nextExpressionResult = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case GET:
    case POST:
    case NUM_EVENTS:
    case NOW:
    case NUMBER:
    case STRING:
    case BOOLEAN:
    case IDENTIFIER:
    case EVENT:
      expressionResult = valueExpression(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
      break;
    case ABS:
    case CEIL:
    case FLOOR:
    case LOG:
    case LEFT_PARENTHESIS:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABS:
      case CEIL:
      case FLOOR:
      case LOG:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LOG:
          function = jj_consume_token(LOG);
          break;
        case ABS:
          function = jj_consume_token(ABS);
          break;
        case FLOOR:
          function = jj_consume_token(FLOOR);
          break;
        case CEIL:
          function = jj_consume_token(CEIL);
          break;
        default:
          jj_la1[50] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[51] = jj_gen;
        ;
      }
      jj_consume_token(LEFT_PARENTHESIS);
      expressionResult = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
      jj_consume_token(RIGHT_PARENTHESIS);
                        if (function != null && evaluate)
                        {
                                if (expressionResult == null)
                                        {if (true) return null;}

                                if (expressionResult.getValueDataType() == ValueDataType.NUMBER)
                                        if (function.kind == CaplInterpreterConstants.LOG)
                                                expressionResult = new CaplValue(Math.log(expressionResult.getNumberValue()));
                                        else if (function.kind == CaplInterpreterConstants.ABS)
                                                expressionResult = new CaplValue(Math.abs(expressionResult.getNumberValue()));
                                        else if (function.kind == CaplInterpreterConstants.FLOOR)
                                                expressionResult = new CaplValue(Math.floor(expressionResult.getNumberValue()));
                                        else expressionResult = new CaplValue(Math.ceil(expressionResult.getNumberValue()));
                                else if (expressionResult.getValueDataType() == ValueDataType.SET)
                                                expressionResult = operateOnSet(expressionResult, null, function);
                                        else if (expressionResult.getValueDataType() == ValueDataType.MAP)
                                                expressionResult = operateOnMap(expressionResult, null, function);
                                        else if (expressionResult.getValueDataType() == ValueDataType.LIST)
                                                expressionResult = operateOnList(expressionResult, null, function);
                                        else
                                        {
                                                printOperandDataTypeError(new String[] { "NUMBER", "SET", "MAP", "LIST" }, expressionResult, function);
                                                {if (true) return null;}
                                        }
                        }
      break;
    case MAX:
    case MIN:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MIN:
        function = jj_consume_token(MIN);
        break;
      case MAX:
        function = jj_consume_token(MAX);
        break;
      default:
        jj_la1[52] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(LEFT_PARENTHESIS);
      expressionResult = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
      jj_consume_token(COMMA);
      nextExpressionResult = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
      jj_consume_token(RIGHT_PARENTHESIS);
                        if (evaluate)
                                if (expressionResult == null || nextExpressionResult == null)
                                        {if (true) return null;}
                                else if (expressionResult.getValueDataType() != ValueDataType.NUMBER)
                                {
                                        printOperandDataTypeError(new String[] { "NUMBER" }, expressionResult, function);
                                        {if (true) return null;}
                                }
                                else if (nextExpressionResult.getValueDataType() != ValueDataType.NUMBER)
                                {
                                        printOperandDataTypeError(new String[] { "NUMBER" }, nextExpressionResult, function);
                                        {if (true) return null;}
                                }
                                else if (function.kind == CaplInterpreterConstants.MIN)
                                        expressionResult = new CaplValue(Math.min(expressionResult.getNumberValue(), nextExpressionResult.getNumberValue()));
                                else expressionResult = new CaplValue(Math.max(expressionResult.getNumberValue(), nextExpressionResult.getNumberValue()));
      break;
    case SET:
    case MAP:
    case LIST:
      expressionResult = collectionInitializer(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, true);
      break;
    default:
      jj_la1[53] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEFT_BRACKET:
      expressionResult = collectionElement(expressionResult, stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXISTS:
      case NOT_NULL:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EXISTS:
          jj_consume_token(EXISTS);
                                if (evaluate)
                                        if (expressionResult == null)
                                                {if (true) return new CaplValue(false);}
                                        else {if (true) return new CaplValue(true);}
                                {if (true) return EMPTY_CAPL_VALUE;}
          break;
        case NOT_NULL:
          jj_consume_token(NOT_NULL);
                                if (evaluate)
                                        if (expressionResult == null || expressionResult.getValueDataType() == ValueDataType.NA)
                                                {if (true) return new CaplValue(false);}
                                        else {if (true) return new CaplValue(true);}
                                {if (true) return EMPTY_CAPL_VALUE;}
          break;
        default:
          jj_la1[54] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[55] = jj_gen;
        ;
      }
                        if (expressionResult == null)
                        {
                                printMessage("Referenced collection element does not exist");
                                {if (true) return null;}
                        }
      break;
    default:
      jj_la1[56] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CONTAINS_SOME:
    case CONTAINS:
    case CONTAINS_SOME_KEYS:
    case CONTAINS_KEYS:
    case CONTAINS_SOME_VALUES:
    case CONTAINS_VALUES:
    case COUNT:
    case COUNT_KEYS:
    case COUNT_VALUES:
    case FIRST_INDEX:
    case LAST_INDEX:
    case ADD:
    case REMOVE:
    case REMOVE_LAST:
    case REMOVE_ALL:
    case SUM:
    case AVG:
    case MAX:
    case MIN:
    case STD_DEV:
    case AVG_DIFF:
    case AVG_SQR_DIFF:
    case HISTO:
    case TOP:
    case BOTTOM:
    case SORT_ASC:
    case SORT_ASC_KEYS:
    case SORT_ASC_VALUES:
    case SORT_DESC:
    case SORT_DESC_KEYS:
    case SORT_DESC_VALUES:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COUNT:
      case COUNT_KEYS:
      case COUNT_VALUES:
      case SUM:
      case AVG:
      case MAX:
      case MIN:
      case STD_DEV:
      case AVG_DIFF:
      case AVG_SQR_DIFF:
      case HISTO:
      case SORT_ASC:
      case SORT_ASC_KEYS:
      case SORT_ASC_VALUES:
      case SORT_DESC:
      case SORT_DESC_KEYS:
      case SORT_DESC_VALUES:
        expressionResult = aggregation(expressionResult, stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
                        if (expressionResult == null)
                                {if (true) return null;}
        break;
      case CONTAINS_SOME:
      case CONTAINS:
      case CONTAINS_SOME_KEYS:
      case CONTAINS_KEYS:
      case CONTAINS_SOME_VALUES:
      case CONTAINS_VALUES:
        expressionResult = collectionValueContains(expressionResult, stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
                        if (expressionResult == null)
                                {if (true) return null;}
        break;
      case FIRST_INDEX:
      case LAST_INDEX:
        expressionResult = indexOf(expressionResult, stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
                        if (expressionResult == null)
                                {if (true) return null;}
        break;
      case ADD:
      case REMOVE:
      case REMOVE_LAST:
      case REMOVE_ALL:
        expressionResult = collectionManipulation(expressionResult, stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
                        if (expressionResult == null)
                                {if (true) return null;}
        break;
      case TOP:
      case BOTTOM:
        expressionResult = topOrBottom(expressionResult, stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
                        if (expressionResult == null)
                                {if (true) return null;}
        break;
      default:
        jj_la1[57] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[58] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DATE_TO_NUMBER:
    case DATE_TO_TIME_WINDOW:
    case NUMBER_TO_TIME_WINDOW:
    case STRING_TO_NUMBER:
    case STRING_TO_BOOLEAN:
    case NUMBER_TO_STRING:
    case NUMBER_TO_DATE:
      expressionResult = castFromValue(expressionResult, stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate);
      break;
    default:
      jj_la1[59] = jj_gen;
      ;
    }
                {if (true) return expressionResult;}
    throw new Error("Missing return statement in function");
  }

  final private boolean assignment(Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Mutability mutability, Set<String> referencedIdentifiers, boolean debug) throws ParseException {
        String identifierAsString = null;

        CaplValue caplValue;

        if (debug)
                printMessage("Parsing \u005c"assignment\u005c"", Level.TRACE);
    jj_consume_token(IDENTIFIER);
            identifierAsString = token.toString();
            if (stateCaplValues.containsKey(identifierAsString))
                {
                        printMessage("Attempt to define " + mutability + " \u005c"" + identifierAsString + "\u005c" more than once");
                        {if (true) return false;}
                }
    jj_consume_token(COLON);
    caplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, true);
                if (caplValue == null)
                        {if (true) return false;}
                stateCaplValues.put(identifierAsString, caplValue);
                if (debug)
                        LOGGER.debug("[Line " + token.beginLine + "] >> " + identifierAsString + " = " + caplValue);
                {if (true) return true;}
    throw new Error("Missing return statement in function");
  }

  final private boolean settings(Map<String, CaplValue> stateCaplValues, Set<String> referencedIdentifiers) throws ParseException {
        CaplValue debugCaplValue = new CaplValue(false),
                          eventRecordingCaplValue = new CaplValue(false),
                          expiresCaplValue;

        printMessage("Parsing \u005c"settings\u005c"", Level.TRACE);

        stateCaplValues.put("*eventRecording*", eventRecordingCaplValue);
    jj_consume_token(SETTINGS);
    jj_consume_token(COLON);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DEBUG:
      jj_consume_token(DEBUG);
      jj_consume_token(COLON);
      debugCaplValue = valueExpression1(stateCaplValues, null, Mutability.CONSTANT, referencedIdentifiers, true);
                        if (debugCaplValue == null)
                                {if (true) return false;}
                        if (debugCaplValue.getValueDataType() == ValueDataType.BOOLEAN)
                                stateCaplValues.put("*debug*", debugCaplValue);
                        else
                        {
                                printOperandDataTypeError(new String[] { "BOOLEAN" }, debugCaplValue, ":");
                                {if (true) return false;}
                        }
      jj_consume_token(COMMA);
      break;
    default:
      jj_la1[60] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EVENT_RECORDING:
      jj_consume_token(EVENT_RECORDING);
      jj_consume_token(COLON);
      eventRecordingCaplValue = valueExpression1(stateCaplValues, null, Mutability.CONSTANT, referencedIdentifiers, true);
                        if (eventRecordingCaplValue == null)
                                {if (true) return false;}
                        if (eventRecordingCaplValue.getValueDataType() == ValueDataType.BOOLEAN)
                                stateCaplValues.put("*eventRecording*", eventRecordingCaplValue);
                        else
                        {
                                printOperandDataTypeError(new String[] { "BOOLEAN" }, eventRecordingCaplValue, ":");
                                {if (true) return false;}
                        }
      jj_consume_token(COMMA);
      break;
    default:
      jj_la1[61] = jj_gen;
      ;
    }
    jj_consume_token(EXPIRES);
    jj_consume_token(COLON);
    expiresCaplValue = valueExpression1(stateCaplValues, null, Mutability.CONSTANT, referencedIdentifiers, true);
                if (expiresCaplValue == null)
                        {if (true) return false;}
                if (expiresCaplValue.getValueDataType() == ValueDataType.NUMBER)
                        if (expiresCaplValue.getNumberValue() >= 0d)
                                stateCaplValues.put("*expires*", expiresCaplValue);
                        else
                        {
                                printOperandDataTypeError(new String[] { "NON-NEGATIVE NUMBER" }, expiresCaplValue, ":");
                                {if (true) return false;}
                        }
                else
                {
                        printOperandDataTypeError(new String[] { "NUMBER" }, expiresCaplValue, ":");
                        {if (true) return false;}
                }
    jj_consume_token(SEMICOLON);
                        {if (true) return true;}
    throw new Error("Missing return statement in function");
  }

  final private boolean constants(Map<String, CaplValue> stateCaplValues, Set<String> referencedIdentifiers, boolean debug) throws ParseException {
        boolean result = true;

        if (debug)
                printMessage("Parsing \u005c"constants\u005c"", Level.TRACE);
    jj_consume_token(CONSTANTS);
    jj_consume_token(COLON);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      result = assignment(stateCaplValues, null, Mutability.CONSTANT, referencedIdentifiers, debug);
                                                                        if (!result)
                                                                                {if (true) return false;}
      label_12:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[62] = jj_gen;
          break label_12;
        }
        jj_consume_token(COMMA);
        result = assignment(stateCaplValues, null, Mutability.CONSTANT, referencedIdentifiers, debug);
                                                                                if (!result)
                                                                                        {if (true) return false;}
      }
      break;
    default:
      jj_la1[63] = jj_gen;
      ;
    }
    jj_consume_token(SEMICOLON);
                                                                makeImmutable(stateCaplValues);
                                                                {if (true) return true;}
    throw new Error("Missing return statement in function");
  }

  final private boolean variables(Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Set<String> referencedIdentifiers, boolean debug) throws ParseException {
        boolean result = true;

        if (debug)
                printMessage("Parsing \u005c"variables\u005c"", Level.TRACE);
    jj_consume_token(VARIABLES);
    jj_consume_token(COLON);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      result = assignment(stateCaplValues, eventCaplValue, Mutability.VARIABLE, referencedIdentifiers, debug);
                                                                        if (!result)
                                                                                {if (true) return false;}
      label_13:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[64] = jj_gen;
          break label_13;
        }
        jj_consume_token(COMMA);
        result = assignment(stateCaplValues, eventCaplValue, Mutability.VARIABLE, referencedIdentifiers, debug);
                                                                                if (!result)
                                                                                        {if (true) return false;}
      }
      break;
    default:
      jj_la1[65] = jj_gen;
      ;
    }
    jj_consume_token(SEMICOLON);
                                                                        {if (true) return true;}
    throw new Error("Missing return statement in function");
  }

  final private boolean thenElse(Map<String, CaplValue> stateCaplValues, Map<String, CaplValue> outputCaplValues, CaplValue eventCaplValue,
                                                 Set<String> referencedIdentifiers, boolean isUpdateRule,
                                                 String identifierAsString, CaplValue referencedCaplValue, boolean preCondition, boolean debug) throws ParseException {
        CaplValue updateCaplValue = null;

        if (debug)
                printMessage("Parsing \u005c"thenElse\u005c"", Level.TRACE);
    updateCaplValue = valueExpression1(stateCaplValues, eventCaplValue, Mutability.VARIABLE, referencedIdentifiers, preCondition);
                if (preCondition)
                {
                        if (updateCaplValue == null)
                        {
                                printMessage("The rule for identifier \u005c"" + (identifierAsString == null ? "< NOT SPECIFIED >" : identifierAsString) + "\u005c" in this rules section produced an invalid value");
                                {if (true) return false;}
                        }
                        if (isUpdateRule && identifierAsString != null && updateCaplValue.getValueDataType() != referencedCaplValue.getValueDataType())
                        {
                                printMessage("Incompatible data types between identifier \u005c"" + identifierAsString + "\u005c" and the specified rule: " + referencedCaplValue.getValueDataType() + " versus " + updateCaplValue.getValueDataType());
                                {if (true) return false;}
                        }
                        if (identifierAsString != null)
                        {
                                updateCaplValue.setMutability(Mutability.VARIABLE); // Even if the updateCaplValue is a CONSTANT, the left side of the assignment is a VARIABLE and we want the new value to be a VARIABLE as well.
                                outputCaplValues.put(identifierAsString, updateCaplValue);
                                if (debug)
                                        LOGGER.debug("[Line " + token.beginLine + "] >> " + identifierAsString + " = " + updateCaplValue);
                        }
                }
                {if (true) return true;}
    throw new Error("Missing return statement in function");
  }

  final private boolean evaluateAssignment(Map<String, CaplValue> stateCaplValues, Map<String, CaplValue> outputCaplValues, CaplValue eventCaplValue,
                                                                   Set<String> referencedIdentifiers, boolean isUpdateRule, boolean preCondition, boolean debug) throws ParseException {
        String identifierAsString = null;

        CaplValue referencedCaplValue = null;

        boolean success;

        if (debug)
                printMessage("Parsing \u005c"evaluateAssignment\u005c"", Level.TRACE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      jj_consume_token(IDENTIFIER);
                    identifierAsString = token.toString();
                    if (isUpdateRule)
                    {
                            referencedCaplValue = stateCaplValues.get(identifierAsString);
                                if (referencedCaplValue == null)
                                {
                                        printMessage("Identifier \u005c"" + identifierAsString + "\u005c" has not been defined in the \u005c"variables\u005c" section");
                                        {if (true) return false;}
                                }
                                if (referencedCaplValue.getMutability() == Mutability.CONSTANT)
                                {
                                        printMessage("Identifier \u005c"" + identifierAsString + "\u005c" references a constant and thus cannot be updated in this rules section");
                                        {if (true) return false;}
                                }
                        }
                        // else the identifier is an output label rather than a previously defined variable.
                        else if (outputCaplValues.containsKey(identifierAsString))
                        {
                                printMessage("Duplicate output label \u005c"" + identifierAsString + "\u005c"");
                                {if (true) return false;}
                        }
      break;
    default:
      jj_la1[66] = jj_gen;
      ;
    }
    jj_consume_token(COLON);
    success = thenElse(stateCaplValues, outputCaplValues, eventCaplValue, referencedIdentifiers, isUpdateRule, identifierAsString, referencedCaplValue, preCondition, debug);
                if (!success)
                        {if (true) return false;}
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ELSE:
      jj_consume_token(ELSE);
      success = thenElse(stateCaplValues, outputCaplValues, eventCaplValue, referencedIdentifiers, isUpdateRule, identifierAsString, referencedCaplValue, !preCondition, debug);
                        if (!success)
                                {if (true) return false;}
      break;
    default:
      jj_la1[67] = jj_gen;
      ;
    }
                {if (true) return true;}
    throw new Error("Missing return statement in function");
  }

  final private boolean rule(Map<String, CaplValue> stateCaplValues, Map<String, CaplValue> outputCaplValues, CaplValue eventCaplValue,
                                         Set<String> referencedIdentifiers, boolean isUpdateRule, boolean debug) throws ParseException {
        CaplValue conditionCaplValue = null;

        boolean preCondition = true,
                        success;

        if (debug)
                printMessage("Parsing \u005c"rule\u005c"", Level.TRACE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SET:
    case MAP:
    case LIST:
    case GET:
    case POST:
    case MAX:
    case MIN:
    case NUM_EVENTS:
    case NOW:
    case ABS:
    case CEIL:
    case FLOOR:
    case MINUS:
    case LOG:
    case NOT:
    case NUMBER:
    case STRING:
    case BOOLEAN:
    case IDENTIFIER:
    case EVENT:
    case LEFT_PARENTHESIS:
      conditionCaplValue = valueExpression1(stateCaplValues, eventCaplValue, Mutability.VARIABLE, referencedIdentifiers, true);
                        if (conditionCaplValue == null)
                        {
                                printMessage("The condition in this rules section is invalid");
                                {if (true) return false;}
                    }
                        if (conditionCaplValue.getValueDataType() != ValueDataType.BOOLEAN)
                        {
                                printMessage("The condition in this rules section is not a BOOLEAN value");
                                {if (true) return false;}
                        }
                        preCondition = conditionCaplValue.getBooleanValue();
                        if (debug)
                                LOGGER.debug("[Line " + token.beginLine + "] >> precondition is " + preCondition);
      break;
    default:
      jj_la1[68] = jj_gen;
      ;
    }
    jj_consume_token(COLON);
    success = evaluateAssignment(stateCaplValues, outputCaplValues, eventCaplValue, referencedIdentifiers, isUpdateRule, preCondition, debug);
                if (!success)
                        {if (true) return false;}
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NEXT_EVAL:
        ;
        break;
      default:
        jj_la1[69] = jj_gen;
        break label_14;
      }
      jj_consume_token(NEXT_EVAL);
      success = evaluateAssignment(stateCaplValues, outputCaplValues, eventCaplValue, referencedIdentifiers, isUpdateRule, preCondition, debug);
                        if (!success)
                                {if (true) return false;}
    }
                {if (true) return true;}
    throw new Error("Missing return statement in function");
  }

  final private boolean updateRules(Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Set<String> referencedIdentifiers, boolean debug) throws ParseException {
        boolean result = true;

        if (debug)
                printMessage("Parsing \u005c"updateRules\u005c"", Level.TRACE);
    jj_consume_token(UPDATES);
    jj_consume_token(COLON);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SET:
    case MAP:
    case LIST:
    case GET:
    case POST:
    case MAX:
    case MIN:
    case NUM_EVENTS:
    case NOW:
    case ABS:
    case CEIL:
    case FLOOR:
    case MINUS:
    case LOG:
    case NOT:
    case NUMBER:
    case STRING:
    case BOOLEAN:
    case IDENTIFIER:
    case EVENT:
    case LEFT_PARENTHESIS:
    case COLON:
      result = rule(stateCaplValues, stateCaplValues, eventCaplValue, referencedIdentifiers, true, debug);
                                                                if (!result)
                                                                        {if (true) return false;}
      label_15:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[70] = jj_gen;
          break label_15;
        }
        jj_consume_token(COMMA);
        result = rule(stateCaplValues, stateCaplValues, eventCaplValue, referencedIdentifiers, true, debug);
                                                                if (!result)
                                                                        {if (true) return false;}
      }
      break;
    default:
      jj_la1[71] = jj_gen;
      ;
    }
    jj_consume_token(SEMICOLON);
                                                                  {if (true) return true;}
    throw new Error("Missing return statement in function");
  }

  final private HashMap<String, CaplValue> outputRules(Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Set<String> referencedIdentifiers, boolean debug) throws ParseException {
        final HashMap<String, CaplValue> outputCaplValues = new LinkedHashMap<String, CaplValue>();

        boolean result = true;

        if (debug)
                printMessage("Parsing \u005c"outputRules\u005c"", Level.TRACE);
    jj_consume_token(OUTPUTS);
    jj_consume_token(COLON);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SET:
    case MAP:
    case LIST:
    case GET:
    case POST:
    case MAX:
    case MIN:
    case NUM_EVENTS:
    case NOW:
    case ABS:
    case CEIL:
    case FLOOR:
    case MINUS:
    case LOG:
    case NOT:
    case NUMBER:
    case STRING:
    case BOOLEAN:
    case IDENTIFIER:
    case EVENT:
    case LEFT_PARENTHESIS:
    case COLON:
      result = rule(stateCaplValues, outputCaplValues, eventCaplValue, referencedIdentifiers, false, debug);
                                                                if (!result)
                                                                        {if (true) return null;}
      label_16:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[72] = jj_gen;
          break label_16;
        }
        jj_consume_token(COMMA);
        result = rule(stateCaplValues, outputCaplValues, eventCaplValue, referencedIdentifiers, false, debug);
                                                                if (!result)
                                                                        {if (true) return null;}
      }
      break;
    default:
      jj_la1[73] = jj_gen;
      ;
    }
    jj_consume_token(SEMICOLON);
                                                                  {if (true) return outputCaplValues;}
    throw new Error("Missing return statement in function");
  }

  final private HashMap<String, CaplValue> rules(Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Set<String> referencedIdentifiers, boolean debug) throws ParseException {
        HashMap<String, CaplValue> outputCaplValues = null;

        boolean result;

        if (debug)
                printMessage("Parsing \u005c"rules\u005c"", Level.TRACE);
    result = updateRules(stateCaplValues, eventCaplValue, referencedIdentifiers, debug);
                                                                                              if (!result) {if (true) return null;}
    outputCaplValues = outputRules(stateCaplValues, eventCaplValue, referencedIdentifiers, debug);
                                                                                                        if (outputCaplValues == null) {if (true) return null;}
    jj_consume_token(0);
                if (referencedIdentifiers != null && referencedIdentifiers.size() < stateCaplValues.size())
                        for (String identifier: stateCaplValues.keySet())
                                if (!referencedIdentifiers.contains(identifier) && !identifier.startsWith("*"))
                                        printMessage("Declared " + stateCaplValues.get(identifier).getMutability() + " \u005c"" + identifier + "\u005c" is not used", Level.WARN);
                {if (true) return outputCaplValues;}
    throw new Error("Missing return statement in function");
  }

  /** Generated Token Manager. */
  public CaplInterpreterTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[74];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x0,0x0,0x0,0x0,0x0,0xe000000,0x1000000,0x0,0xe000000,0x0,0x0,0x0,0x0,0x38000,0xc0000000,0x28000,0x38000,0x0,0x0,0x0,0x38000,0x0,0x0,0x0,0x0,0x0,0x38000,0xfc0000,0x1000000,0x0,0x0,0x1000000,0x0,0x0,0x30000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000000,0x0,0x0,0x0,0x0,0x0,0x38000,0x0,0x0,0x0,0x38000,0x0,0x0,0x0,0xfefc0000,0xfefc0000,0x0,0x100,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x38000,0x0,0x0,0x38000,0x0,0x38000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0xc,0x0,0x620,0x0,0xfcff0,0x0,0x0,0x0,0xfcff0,0x0,0x0,0x0,0x0,0xe03000cc,0x3,0x0,0xe03000cc,0x0,0x0,0x0,0xe03000cc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3000,0x0,0x0,0x0,0x0,0x0,0x1fc00000,0x300000,0xc,0x30000c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe03000cc,0xe0000000,0xe0000000,0xc0,0xe03000cc,0x0,0x0,0x0,0xffff3,0xffff3,0x1fc00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe03000cc,0x0,0x0,0xe03000cc,0x0,0xe03000cc,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x80000000,0x0,0x2000000,0x0,0x0,0x0,0x2000000,0x0,0x0,0x80000000,0x0,0x80000000,0x39c4082,0x0,0x0,0x39c4082,0x28000000,0x80000000,0x2000000,0x39c4082,0x28000000,0x0,0x80000000,0x0,0x2000000,0x0,0x0,0x0,0x80000000,0x0,0x0,0x600000,0x80000000,0x0,0x8000000,0x0,0x1c0000,0x1800000,0x19c0000,0x2000,0x1000,0xf00,0x0,0xf00,0x3,0x3,0x7c,0x7c,0x39c4082,0x80,0x80,0x0,0x39c0080,0x30000,0x30000,0x8000000,0x0,0x0,0x0,0x0,0x0,0x80000000,0x800000,0x80000000,0x800000,0x800000,0x8000,0x39c4082,0x0,0x80000000,0x39c4082,0x80000000,0x39c4082,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x1,0x0,0x1,};
   }

  /** Constructor with InputStream. */
  public CaplInterpreter(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public CaplInterpreter(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new CaplInterpreterTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 74; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 74; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public CaplInterpreter(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new CaplInterpreterTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 74; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 74; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public CaplInterpreter(CaplInterpreterTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 74; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(CaplInterpreterTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 74; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[99];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 74; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 99; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
