/**
 *
 * @author Reinhard Klemm, Avaya
 *
 */

options
{
  	BUILD_PARSER = true;
  	BUILD_TOKEN_MANAGER = true;
  	CHOICE_AMBIGUITY_CHECK = 1;
  	COMMON_TOKEN_ACTION = false;
  	DEBUG_PARSER = false;
  	DEBUG_TOKEN_MANAGER = false;
  	ERROR_REPORTING = true;
  	SANITY_CHECK = true;
	STATIC = false;
}

PARSER_BEGIN(CaplInterpreter)

package com.avaya.cap;

import com.avaya.messaging.commons.io.StackTraceLogger;

import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import java.util.Collection;
import java.util.Map;
import java.util.Set;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map.Entry;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.PatternSyntaxException;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.Iterator;
import java.util.Date;
import java.text.SimpleDateFormat;
import com.google.gson.JsonElement;
import com.fasterxml.jackson.databind.JsonNode;
import static com.avaya.messaging.commons.utilities.StringUtils.isEmpty;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.avaya.cap.comparators.*;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;

public class CaplInterpreter
{
	private static final CaplValueComparator ASCENDING_CAPL_VALUE_COMPARATOR = new CaplValueComparator(true),
  											 DESCENDING_CAPL_VALUE_COMPARATOR = new CaplValueComparator(false);

  	private static final StringComparator ASCENDING_KEY_COMPARATOR = new StringComparator(true),
  									   	  DESCENDING_KEY_COMPARATOR = new StringComparator(false); 

  	private static final CaplMapValueComparator ASCENDING_MAP_VALUE_COMPARATOR = new CaplMapValueComparator(true),
  												DESCENDING_MAP_VALUE_COMPARATOR = new CaplMapValueComparator(false);

  	private static final FrequencyMapComparator ASCENDING_FREQUENCY_MAP_COMPARATOR = new FrequencyMapComparator(true),
  												DESCENDING_FREQUENCY_MAP_COMPARATOR = new FrequencyMapComparator(false);
  	
	private static final Logger LOGGER = Logger.getLogger(CaplInterpreter.class);

	private final static double EPSILON = 0.000001d;

	private final static String ALL_COLLECTION_VALUES_KEY = "*ALL*";

	private final static CaplValue EMPTY_CAPL_VALUE = new CaplValue();

	private static CapHttpClient capHttpClientField = null;

	private static EventRecorder eventRecorderField = null;

	private String getTokenString(Token token)
	{
	  	return CaplInterpreterConstants.tokenImage[token.kind];
	}

	private void printMessage(Token errorToken, String message, Level logLevel)
	{
	  	if (errorToken == null)
	  		errorToken = token;
	  	message = "Line " + errorToken.beginLine + ", column " + errorToken.beginColumn + ", token \"" + errorToken.image + "\" (" + getTokenString(errorToken) + "): " + message;
	  	LOGGER.log(logLevel, message);
	}

	private void printMessage(Token errorToken, String message)
	{
	  	if (errorToken == null)
	  		errorToken = token;
	  	message = "Line " + errorToken.beginLine + ", column " + errorToken.beginColumn + ", token \"" + errorToken.image + "\" (" + getTokenString(errorToken) + "): " + message;
	  	LOGGER.error(message);
	}

	private void printMessage(String message, Level logLevel)
	{
	  	printMessage(token, message, logLevel);
	}

	private void printMessage(String message)
	{
	  	printMessage(token, message, Level.ERROR);
	}

	private void printOperandDataTypeError(String[] allowedOperandDataTypes, CaplValue operand, Token operator)
	{
	  	final String allowedDataTypes = String.join(", ", allowedOperandDataTypes);
	  	
	  	printMessage("Data type of operand for \"" + operator + "\" operation must be an element of set { " + allowedDataTypes + " } but is " + operand.getValueDataType(), Level.ERROR);
	}

	private void printOperandDataTypeError(String[] allowedOperandDataTypes, CaplValue operand1, CaplValue operand2, Token operator)
	{
	  	final String allowedDataTypes = String.join(", ", allowedOperandDataTypes);
	  	
	  	printMessage("Data types of operands for \"" + operator + "\" operation must be an element of set { " + allowedDataTypes + " } but are " + operand1.getValueDataType() + ", " + operand2.getValueDataType(), Level.ERROR);
	}

	private void printOperandDataTypeIncompatibilityError(String message, CaplValue operand1, CaplValue operand2, Token operator)
	{
	  	printMessage("Operands with data types " + operand1.getValueDataType() + " and " + operand2.getValueDataType() + ", respectively, are incompatible with respect to operator " + operator + ": " + message, Level.ERROR);
	}

	private void printOperandDataTypeError(String[] allowedOperandDataTypes, CaplValue operand, String operator)
	{
	  	final String allowedDataTypes = String.join(", ", allowedOperandDataTypes);
	  	
	  	printMessage("Data type of operand for \"" + operator + "\" operation must be an element of set { " + allowedDataTypes + " } but is " + operand.getValueDataType(), Level.ERROR);
	}

	private void printOperandDataTypeError(String[] allowedOperandDataTypes, CaplValue operand1, CaplValue operand2, String operator)
	{
	  	final String allowedDataTypes = String.join(", ", allowedOperandDataTypes);
	  	
	  	printMessage("Data types of operands for \"" + operator + "\" operation must be elements of set { " + allowedDataTypes + " } but are " + operand1.getValueDataType() + ", " + operand2.getValueDataType(), Level.ERROR);
	}

	private boolean isPositiveInteger(CaplValue numberCaplValue)
	{
		return numberCaplValue.getValueDataType() == ValueDataType.NUMBER && numberCaplValue.getNumberValue() > 0d && Math.floor(numberCaplValue.getNumberValue()) == Math.ceil(numberCaplValue.getNumberValue());
	}

	private void makeImmutable(Map<String, CaplValue> caplValues)
	{
		if (caplValues == null)
			return;
		for (CaplValue oneCaplValue: caplValues.values())
		  	oneCaplValue.setMutability(Mutability.CONSTANT);
	}

	private boolean validateMatchingProperties(CaplValue findExpressionCaplValue, boolean caseInsensitiveMatch, boolean partialMatch) 
	{
	  	if (caseInsensitiveMatch && (findExpressionCaplValue.getValueDataType() == ValueDataType.NUMBER || findExpressionCaplValue.getValueDataType() == ValueDataType.BOOLEAN))
	  	{
	  	  	printOperandDataTypeError(new String[] { "SET", "MAP", "LIST", "STRING" }, findExpressionCaplValue, "CONTAINS - CASE-INSENSITIVE");
	  	  	return false;
	  	}
	  	if (partialMatch && !findExpressionCaplValue.hasCollectionValueDataType())
	  	{
	  	  	printOperandDataTypeError(new String[] { "SET", "MAP", "LIST" }, findExpressionCaplValue, "CONTAINS - PARTIAL");
	  	  	return false;
	  	}
	  	return true;
	}

	private CaplValue sortSet(CaplValue caplValuesSet, Token sortOperation)
	{
	  	final CaplValue sortedCaplValue = CaplCollection.getList(Math.max(1, caplValuesSet.getSetValue().size()));
	  	
		final List<CaplValue> setEntriesAsList = sortedCaplValue.getListValue();

		for (CaplValue oneElement: caplValuesSet.getSetValue())
			setEntriesAsList.add(oneElement);

		try
		{
			if (sortOperation.kind == CaplInterpreterConstants.SORT_ASC)
				setEntriesAsList.sort(ASCENDING_CAPL_VALUE_COMPARATOR);
			else setEntriesAsList.sort(DESCENDING_CAPL_VALUE_COMPARATOR);
		} catch (ClassCastException e)
		{
		  	printMessage("SET entries must be consistently numeric or strings");
		  	return null;
		}
  
		return sortedCaplValue;
	}

	private CaplValue sortMap(CaplValue caplValuesMap, Token sortOperation)
	{
	  	final CaplValue sortedCaplValue = CaplCollection.getMap(Math.max(1, caplValuesMap.getMapValue().size())); // We use the CaplCollection generator to ensure that the map is backed by a LinkedHashMap that is ordered.
	  	
		final Map<String, CaplValue> originalCaplValuesMap = caplValuesMap.getMapValue(),
									 sortedCaplValuesMap = sortedCaplValue.getMapValue();

		final List<String> mapKeysAsList;

		final List<Entry<String, CaplValue>> mapEntriesAsList;

		if (sortOperation.kind == CaplInterpreterConstants.SORT_ASC_KEYS || sortOperation.kind == CaplInterpreterConstants.SORT_DESC_KEYS)
		{
			mapKeysAsList = new ArrayList<String>(originalCaplValuesMap.size());
			for (String oneKey: originalCaplValuesMap.keySet())
				mapKeysAsList.add(oneKey);
			if (sortOperation.kind == CaplInterpreterConstants.SORT_ASC_KEYS)
				mapKeysAsList.sort(ASCENDING_KEY_COMPARATOR);
			else mapKeysAsList.sort(DESCENDING_KEY_COMPARATOR);

			for (String oneKey: mapKeysAsList)
				sortedCaplValuesMap.put(oneKey, originalCaplValuesMap.get(oneKey));
		}
		else
		{
			mapEntriesAsList = new ArrayList<Entry<String, CaplValue>>(originalCaplValuesMap.size());
			for (Entry<String, CaplValue> oneEntry: originalCaplValuesMap.entrySet())
				mapEntriesAsList.add(oneEntry);
			try
			{
				if (sortOperation.kind == CaplInterpreterConstants.SORT_ASC_VALUES)
					mapEntriesAsList.sort(ASCENDING_MAP_VALUE_COMPARATOR);
				else mapEntriesAsList.sort(DESCENDING_MAP_VALUE_COMPARATOR);
			} catch (ClassCastException e)
			{
			  	printMessage("MAP entries must be consistently numeric or strings");
			  	return null;
			}
			for (Entry<String, CaplValue> oneEntry: mapEntriesAsList)
				sortedCaplValuesMap.put(oneEntry.getKey(), oneEntry.getValue());
		}

		return sortedCaplValue;
	}

	private CaplValue sortList(CaplValue caplValuesList, Token sortOperation)
	{
	  	final CaplValue sortedCaplValue = CaplCollection.getList(Math.max(1, caplValuesList.getCapacity()));
	  	
		final List<CaplValue> sortedCaplValuesList = sortedCaplValue.getListValue();

		for (CaplValue oneElement: caplValuesList.getListValue())
			sortedCaplValuesList.add(oneElement);

		try
		{
			if (sortOperation.kind == CaplInterpreterConstants.SORT_ASC)
				sortedCaplValuesList.sort(ASCENDING_CAPL_VALUE_COMPARATOR);
			else sortedCaplValuesList.sort(DESCENDING_CAPL_VALUE_COMPARATOR);
		} catch (ClassCastException e)
		{
		  	printMessage("LIST entries must be consistently numeric or strings");
		  	return null;
		}
  
		return sortedCaplValue;
	}

	private CaplValue countOccurrences(CaplValue findExpressionIn, CaplValue findExpression, boolean caseInsensitiveMatch)
	{
	  	Pattern regexPattern;

	  	Matcher regexMatcher;

	  	int numberMatches = 0;
	  	
	  	try
	  	{
	  	  	if (caseInsensitiveMatch)
	  	  		regexPattern = Pattern.compile(findExpression.getStringValue(), Pattern.CASE_INSENSITIVE);
	  	  	else regexPattern = Pattern.compile(findExpression.getStringValue());
	  	} catch (PatternSyntaxException e)
	  	{
	  	  	printMessage("Invalid regular expression \"" + findExpression.getStringValue() + "\"");
			return null;
	  	}
		regexMatcher = regexPattern.matcher(findExpressionIn.getStringValue());
	  	while (regexMatcher.find())
	  		numberMatches++;

	  	return new CaplValue(numberMatches);
	}

	private CaplValue rankCollection(Collection<CaplValue> collection, Token aggregationToken, CaplValue rankingNumber, Token rankingNumberUnit, CaplValue findExpression, boolean caseInsensitiveMatch)
	{
	  	Map<CaplValue, CaplValue> valueFrequencyMap;

	  	int rankedNumber;

	  	Pattern regexPattern = null;

	  	Matcher regexMatcher;

	  	String elementAsString;

	  	CaplValue frequency,
	  			  matchedSubstringCaplValue;

	  	Iterator<Entry<CaplValue, CaplValue>> valueFrequencyIterator;

	  	List<CaplValue> rankedList;

		HashMap<String, CaplValue> oneRankedListEntry;

	  	Entry<CaplValue, CaplValue> oneValueFrequencyEntry;

		if (rankingNumber.getValueDataType() == ValueDataType.NUMBER)
		{
		  	if (rankingNumberUnit.kind == CaplInterpreterConstants.PCT)
		  	{ 
			    if (rankingNumber.getNumberValue() < 0 || rankingNumber.getNumberValue() > 100)
			    {
			      	printMessage("The numeric argument of TOP / BOTTOM must be in the range [0, 100]");
					return null;
			    }
			}
			else if (Math.ceil(rankingNumber.getNumberValue()) > Math.floor(rankingNumber.getNumberValue()))
			{
			  	printMessage("The numeric argument of TOP / BOTTOM must be an integer");
				return null;
			}
			
			if (findExpression == null || findExpression.getValueDataType() == ValueDataType.STRING)
			{
				valueFrequencyMap = new HashMap<CaplValue, CaplValue>();
				if (findExpression != null)
				  	try
				  	{
				  	  	if (caseInsensitiveMatch)
				  	  		regexPattern = Pattern.compile(findExpression.getStringValue(), Pattern.CASE_INSENSITIVE);
				  	  	else regexPattern = Pattern.compile(findExpression.getStringValue());
				  	} catch (PatternSyntaxException e)
				  	{
				  	  	printMessage("Invalid regular expression \"" + findExpression.getStringValue() + "\"");
						return null;
				  	}
					
				for (CaplValue oneCollectionElement: collection)
				{
				  	if (oneCollectionElement.getValueDataType() == ValueDataType.NUMBER ||
						oneCollectionElement.getValueDataType() == ValueDataType.STRING && findExpression == null)
					{
					  	frequency = valueFrequencyMap.get(oneCollectionElement);
					  	if (frequency == null)
					  		valueFrequencyMap.put(oneCollectionElement, new CaplValue(1d));
					  	else frequency.addNumberValue(1d);
					}
					else if (oneCollectionElement.getValueDataType() == ValueDataType.STRING)
					{
					  	elementAsString = oneCollectionElement.getStringValue();
					  	regexMatcher = regexPattern.matcher(elementAsString);
					  	while (regexMatcher.find())
					  	{
					  	  	matchedSubstringCaplValue = new CaplValue(elementAsString.substring(regexMatcher.start(), regexMatcher.end()));
						  	frequency = valueFrequencyMap.get(matchedSubstringCaplValue);
						  	if (frequency == null)
						  		valueFrequencyMap.put(matchedSubstringCaplValue, new CaplValue(1d));
						  	else frequency.addNumberValue(1d);
						}
					}
				}
				if (rankingNumberUnit.kind == CaplInterpreterConstants.PCT)
					rankedNumber = (int) Math.ceil(valueFrequencyMap.size() * (rankingNumber.getNumberValue() / 100d));
				else rankedNumber = (int) rankingNumber.getNumberValue();
				rankedNumber = Math.min(rankedNumber, valueFrequencyMap.size());
				rankedList = new ArrayList<CaplValue>(rankedNumber);
				valueFrequencyIterator = valueFrequencyMap.entrySet().iterator();
				while (valueFrequencyIterator.hasNext())
				{
				  	oneValueFrequencyEntry = valueFrequencyIterator.next();
				  	oneRankedListEntry = new HashMap<String, CaplValue>();
				  	oneRankedListEntry.put("k", oneValueFrequencyEntry.getKey()); // k = key
				  	oneRankedListEntry.put("f", oneValueFrequencyEntry.getValue()); // f = frequency
				  	rankedList.add(new CaplValue(Mutability.CONSTANT, oneRankedListEntry, Integer.MAX_VALUE));
				}
				rankedList.sort(aggregationToken.kind == CaplInterpreterConstants.TOP ? DESCENDING_FREQUENCY_MAP_COMPARATOR : ASCENDING_FREQUENCY_MAP_COMPARATOR);
				return new CaplValue(Mutability.CONSTANT, rankedList.subList(0, rankedNumber), Integer.MAX_VALUE);
			}
			else
			{
			  	printMessage("The third argument of TOP / BOTTOM, if present, must be a STRING (regular expression)");
				return null;
			}
		}
		printMessage("TOP / BOTTOM must have a numeric (ranking) argument");
		return null;
	}

	private CaplValue rankCollection(String text, Token aggregationToken, CaplValue rankingNumber, Token rankingNumberUnit, CaplValue findExpression, boolean caseInsensitiveMatch)
	{
	  	Map<CaplValue, CaplValue> valueFrequencyMap;

	  	int rankedNumber;

	  	Pattern regexPattern = null;

	  	Matcher regexMatcher;

	  	CaplValue frequency,
	  			  matchedSubstringCaplValue;

	  	Iterator<Entry<CaplValue, CaplValue>> valueFrequencyIterator;

	  	List<CaplValue> rankedList;

		HashMap<String, CaplValue> oneRankedListEntry;

	  	Entry<CaplValue, CaplValue> oneValueFrequencyEntry;

		if (rankingNumber.getValueDataType() == ValueDataType.NUMBER)
		{
		  	if (rankingNumberUnit.kind == CaplInterpreterConstants.PCT)
		  	{ 
			    if (rankingNumber.getNumberValue() < 0 || rankingNumber.getNumberValue() > 100)
			    {
			      	printMessage("The numeric argument of TOP / BOTTOM must be in the range [0, 100]");
					return null;
			    }
			}
			else if (Math.ceil(rankingNumber.getNumberValue()) > Math.floor(rankingNumber.getNumberValue()))
			{
			  	printMessage("The numeric argument of TOP / BOTTOM must be an integer");
				return null;
			}
			
			if (findExpression.getValueDataType() == ValueDataType.STRING)
			{
				valueFrequencyMap = new HashMap<CaplValue, CaplValue>();
			  	try
			  	{
			  	  	if (caseInsensitiveMatch)
			  	  		regexPattern = Pattern.compile(findExpression.getStringValue(), Pattern.CASE_INSENSITIVE);
			  	  	else regexPattern = Pattern.compile(findExpression.getStringValue());
			  	} catch (PatternSyntaxException e)
			  	{
			  	  	printMessage("Invalid regular expression \"" + findExpression.getStringValue() + "\"");
					return null;
			  	}
					
				regexMatcher = regexPattern.matcher(text);
			  	while (regexMatcher.find())
			  	{
			  	  	matchedSubstringCaplValue = new CaplValue(text.substring(regexMatcher.start(), regexMatcher.end()));
				  	frequency = valueFrequencyMap.get(matchedSubstringCaplValue);
				  	if (frequency == null)
				  		valueFrequencyMap.put(matchedSubstringCaplValue, new CaplValue(1d));
				  	else frequency.addNumberValue(1d);
				}
				
				if (rankingNumberUnit.kind == CaplInterpreterConstants.PCT)
					rankedNumber = (int) Math.ceil(valueFrequencyMap.size() * (rankingNumber.getNumberValue() / 100d));
				else rankedNumber = (int) rankingNumber.getNumberValue();
				rankedNumber = Math.min(rankedNumber, valueFrequencyMap.size());
				rankedList = new ArrayList<CaplValue>(rankedNumber);
				valueFrequencyIterator = valueFrequencyMap.entrySet().iterator();
				while (valueFrequencyIterator.hasNext())
				{
				  	oneValueFrequencyEntry = valueFrequencyIterator.next();
				  	oneRankedListEntry = new HashMap<String, CaplValue>();
				  	oneRankedListEntry.put("k", oneValueFrequencyEntry.getKey()); // k = key
				  	oneRankedListEntry.put("f", oneValueFrequencyEntry.getValue()); // f = frequency
				  	rankedList.add(new CaplValue(Mutability.CONSTANT, oneRankedListEntry, Integer.MAX_VALUE));
				}
				rankedList.sort(aggregationToken.kind == CaplInterpreterConstants.TOP ? DESCENDING_FREQUENCY_MAP_COMPARATOR : ASCENDING_FREQUENCY_MAP_COMPARATOR);
				return new CaplValue(Mutability.CONSTANT, rankedList.subList(0, rankedNumber), Integer.MAX_VALUE);
			}
			else
			{
			  	printMessage("The third argument of TOP / BOTTOM, if present, must be a STRING (regular expression)");
				return null;
			}
		}
		printMessage("TOP / BOTTOM must have a numeric (ranking) argument");
		return null;
	}

	private double getNumericValue(CaplValue caplValue) throws IllegalArgumentException
	{
		switch (caplValue.getValueDataType())
		{
			case NUMBER: return caplValue.getNumberValue();
  		    case STRING: return caplValue.getStringValue().length();
  			case SET: return caplValue.getSetValue().size();
  	  		case MAP: return caplValue.getMapValue().size();
  	  		case LIST: return caplValue.getListValue().size();
  	  		default: printOperandDataTypeError(new String[] { "NUMBER", "SET", "MAP", "LIST", "STRING" }, caplValue, "aggregation operation (collection element must have a numeric value or property [size/length])");
					 throw new IllegalArgumentException("Argument does not have a numeric property");
  	 	}
	}

	private CaplValue getAggregationValue(CaplValue referencedCaplValue, Token aggregationToken, CaplValue[] aggregationParameterCaplValues)
	{
		double aggregatedValue = 0d,
		  	   stdDev,
		  	   alpha,
		  	   oneMinusAlpha,
		  	   startOfFirstBucket,
		  	   bucketWidth;

	  	double[] valuesToAggregate;

	  	int[] histogramBuckets;
		
		int index = 0,
			numberCoreBuckets,
			totalNumberBuckets = 0,
			bucketIndex;

		Map<String, CaplValue> histogram;

		CaplValue histogramCaplValue;

		if (referencedCaplValue.hasCollectionValueDataType())
			switch (aggregationToken.kind)
			{ 
		  		case SORT_ASC:
				case SORT_DESC: switch (referencedCaplValue.getValueDataType())
							   	{
							  	  	case SET: return sortSet(referencedCaplValue, aggregationToken);
									case LIST: return sortList(referencedCaplValue, aggregationToken);
									default: printOperandDataTypeError(new String[] { "SET / LIST" }, referencedCaplValue, "SORT_ASC / SORT_DESC");
											 return null;
							   	}
				case SORT_ASC_KEYS:
				case SORT_ASC_VALUES:
				case SORT_DESC_KEYS:
				case SORT_DESC_VALUES: if (referencedCaplValue.getValueDataType() == ValueDataType.MAP)
											return sortMap(referencedCaplValue, aggregationToken);
									   printOperandDataTypeError(new String[] { "MAP" }, referencedCaplValue, "SORT_ASC_KEYS / SORT_ASC_VALUES / SORT_DESC_KEYS / SORT_DESC_VALUES");
									   return null;
				default: switch (referencedCaplValue.getValueDataType())
					  	 {
					  	  	case SET: valuesToAggregate = new double[referencedCaplValue.getSetValue().size()];
					  	  			  for (CaplValue oneCollectionElement: referencedCaplValue.getSetValue())
					  	  			  		try
					  	  			  		{ 
						  	  			  		valuesToAggregate[index++] = getNumericValue(oneCollectionElement);
						  	  			 	} catch (Exception e)
							  	  	  		{
								 	  		  	printOperandDataTypeError(new String[] { "NUMBER", "SET", "MAP", "LIST", "STRING" }, oneCollectionElement, "aggregation operation (collection element must have a numeric value or property [size/length])");
												return null;
								 	  	 	}
								 	  break;
					  		case MAP: valuesToAggregate = new double[referencedCaplValue.getMapValue().size()];
							  	  	  for (CaplValue oneCollectionElement: referencedCaplValue.getMapValue().values())
							  	  	  		try
					  	  			  		{ 
						  	  			  		valuesToAggregate[index++] = getNumericValue(oneCollectionElement);
						  	  			 	} catch (Exception e)
							  	  	  		{
								 	  		  	printOperandDataTypeError(new String[] { "NUMBER", "SET", "MAP", "LIST", "STRING" }, oneCollectionElement, "aggregation operation (collection element must have a numeric value or property [size/length])");
												return null;
								 	  	 	}
									  break;
					  		default: valuesToAggregate = new double[referencedCaplValue.getListValue().size()];
							  	  	 for (CaplValue oneCollectionElement: referencedCaplValue.getListValue())
							  	  	 	try
				  	  			  		{ 
					  	  			  		valuesToAggregate[index++] = getNumericValue(oneCollectionElement);
					  	  			 	} catch (Exception e)
						  	  	  		{
							 	  		  	printOperandDataTypeError(new String[] { "NUMBER", "SET", "MAP", "LIST", "STRING" }, oneCollectionElement, "aggregation operation (collection element must have a numeric value or property [size/length])");
											return null;
							 	  	 	}
					  	 }
		
					  	 switch (aggregationToken.kind)
						 {
					  		case SUM: aggregatedValue = 0d;
						  			  if (valuesToAggregate.length > 0)
						  			  	for (double oneNumber: valuesToAggregate)
						  			  		aggregatedValue += oneNumber;
						  			  return new CaplValue(aggregatedValue);
						  	case MIN: aggregatedValue = Double.MAX_VALUE;
						  			  if (valuesToAggregate.length > 0)
						  				for (double oneNumber: valuesToAggregate)
						  					if (oneNumber < aggregatedValue)
						  						aggregatedValue = oneNumber;
						  			  return new CaplValue(aggregatedValue);
						  	case MAX: aggregatedValue = Double.MIN_VALUE;
						  			  if (valuesToAggregate.length > 0)
						  			  	for (double oneNumber: valuesToAggregate)
						  			  		if (oneNumber > aggregatedValue)
						  			  			aggregatedValue = oneNumber;
						  			  return new CaplValue(aggregatedValue);
						  	case STD_DEV: aggregatedValue = 0d;
						  			 	  stdDev = 0d;
							  			  if (valuesToAggregate.length > 0)
							  			  { 
							  			  	for (double oneNumber: valuesToAggregate)
							  			  		aggregatedValue += oneNumber;
											aggregatedValue /= valuesToAggregate.length;
							  			  	for (double oneNumber: valuesToAggregate)
							  			  		stdDev += Math.pow(oneNumber - aggregatedValue, 2d);
							  			  	stdDev /= valuesToAggregate.length;
							  			  	aggregatedValue = Math.sqrt(stdDev);
							  			  }
							  			  return new CaplValue(aggregatedValue);
							case HISTO: histogramCaplValue = CaplCollection.getMap(Integer.MAX_VALUE);
										histogram = histogramCaplValue.getMapValue();
										if (valuesToAggregate.length > 0)
										{
										  	startOfFirstBucket = aggregationParameterCaplValues[0].getNumberValue();
										  	numberCoreBuckets = (int) aggregationParameterCaplValues[1].getNumberValue();
										  	totalNumberBuckets = 2 + numberCoreBuckets;
							  			  	bucketWidth = aggregationParameterCaplValues[2].getNumberValue();
							  			  	histogramBuckets = new int[totalNumberBuckets];
							  			  	for (double oneNumber: valuesToAggregate)
							  			  		if (oneNumber < startOfFirstBucket)
							  			  			histogramBuckets[0]++;
							  			  		else
							  			  		{
							  			  		  	bucketIndex = (int) Math.floor((oneNumber - startOfFirstBucket) / bucketWidth);
							  			  		  	if (bucketIndex >= numberCoreBuckets)
							  			  		  		histogramBuckets[totalNumberBuckets - 1]++;
							  			  		   	else histogramBuckets[bucketIndex + 1]++;
							  			  		}
							  			  	histogram.put("< " + startOfFirstBucket, new CaplValue(histogramBuckets[0])); 
							  			  	for (index = 1; index < totalNumberBuckets - 1; index++)
							  			  		histogram.put("" + (startOfFirstBucket + (index - 1) * bucketWidth), new CaplValue(histogramBuckets[index]));
							  			  	histogram.put("> "+ (startOfFirstBucket + numberCoreBuckets * bucketWidth), new CaplValue(histogramBuckets[totalNumberBuckets - 1]));
										}
										return histogramCaplValue;
							case AVG: if (valuesToAggregate.length > 0)
						  			  	if (aggregationParameterCaplValues[0] == null)
									    {
									      	aggregatedValue = 0d;
										  	for (double oneNumber: valuesToAggregate)
						  			  			aggregatedValue += oneNumber;
						  			  		aggregatedValue /= valuesToAggregate.length;
									    }
									    else
									    {
									      	aggregatedValue = valuesToAggregate[0];
				 					      	alpha = aggregationParameterCaplValues[0].getNumberValue();
									      	oneMinusAlpha = 1d - alpha;
									      	for (index = 1; index < valuesToAggregate.length; index++)
								  			  	aggregatedValue = alpha * valuesToAggregate[index] + oneMinusAlpha * aggregatedValue;
									    }
									  else aggregatedValue = 0d;
						  			  return new CaplValue(aggregatedValue);
						  	case AVG_DIFF: if (referencedCaplValue.getValueDataType() == ValueDataType.LIST)
										   {
										     	aggregatedValue = 0d;
										     	if (valuesToAggregate.length > 1)
													if (aggregationParameterCaplValues[0] == null)
												    {
													  	for (index = 1; index < valuesToAggregate.length; index++)
											  			  	aggregatedValue += Math.abs(valuesToAggregate[index] - valuesToAggregate[index - 1]);
											  			aggregatedValue /= (valuesToAggregate.length - 1);
												    }
												    else
												    {
												      	alpha = aggregationParameterCaplValues[0].getNumberValue();
												      	oneMinusAlpha = 1d - alpha;
												      	for (index = 1; index < valuesToAggregate.length; index++)
											  			  	aggregatedValue = alpha * Math.abs(valuesToAggregate[index] - valuesToAggregate[index - 1]) + oneMinusAlpha * aggregatedValue;
												    }
										     	return new CaplValue(aggregatedValue);
										   }
									       printOperandDataTypeError(new String[] { "LIST" }, referencedCaplValue, "AVG_DIFF");
									   	   return null;
							default: if (referencedCaplValue.getValueDataType() == ValueDataType.LIST)
								     {
								   		if (valuesToAggregate.length > 0)
									   		if (aggregationParameterCaplValues[0] == null)
										    {
										      	aggregatedValue = 0d;
											  	for (index = 1; index < valuesToAggregate.length; index++)
							  			  			aggregatedValue += Math.pow(valuesToAggregate[index] - valuesToAggregate[index - 1], 2d);
							  					aggregatedValue = Math.sqrt(aggregatedValue / (valuesToAggregate.length - 1));
										    }
										    else
										    {
										      	aggregatedValue = 0;
										      	alpha = aggregationParameterCaplValues[0].getNumberValue();
										      	oneMinusAlpha = 1d - alpha;
										      	for (index = 1; index < valuesToAggregate.length; index++)
							  			  			aggregatedValue = alpha * Math.pow(valuesToAggregate[index] - valuesToAggregate[index - 1], 2d) + oneMinusAlpha * aggregatedValue;
							  					aggregatedValue = Math.sqrt(aggregatedValue);
										    }
										else aggregatedValue = 0d;
							  			return new CaplValue(aggregatedValue);
								     }
							         printOperandDataTypeError(new String[] { "LIST" }, referencedCaplValue, "AVG_SQR_DIFF");
							   	     return null;
						 }
			}
		
	  	printMessage(aggregationToken, "Unable to aggregate primitive data", Level.ERROR);
  		return null;
	}

	private CaplValue getListIndex(CaplValue referencedCaplValue, Token indexToken, CaplValue collectionElementParameterCaplValue)
	{
		int index = 0;
		
		if (referencedCaplValue.getValueDataType() == ValueDataType.LIST)
		{
		  	if (collectionElementParameterCaplValue.hasCollectionValueDataType())
	  	  	{
	  	  	  	printOperandDataTypeError(new String[] { "NUMBER", "STRING", "BOOLEAN" }, collectionElementParameterCaplValue, "FIRST/LAST_INDEX(...)");
	  	  	  	return null;
	  	  	}
	  		if (indexToken.kind == CaplInterpreterConstants.FIRST_INDEX)
  				for (CaplValue oneListElement: referencedCaplValue.getListValue())
  				{
  					if (oneListElement.equals(collectionElementParameterCaplValue))
  						return new CaplValue(index);
  					index++;
  				}
  			else for (CaplValue oneListElement: referencedCaplValue.getListValue())
  			{ 
  				if (oneListElement.equals(collectionElementParameterCaplValue))
					return new CaplValue(index);
				index++;
			}
	  	  	return new CaplValue(-1d);
		 }
		 printOperandDataTypeError(new String[] { "LIST" }, referencedCaplValue, "FIRST_INDEX");
		 return null;
	}

	private CaplValue getValue(Token referenceValueToken, Map<String, CaplValue> stateCaplValues)
	{
	  	final String referencedValue = referenceValueToken.toString();

		switch (referenceValueToken.kind)
		{
		    case NUMBER: return new CaplValue(Double.parseDouble(referencedValue));
		    case NUM_EVENTS: if (stateCaplValues.containsKey("*numberEvents*"))
		    					return new CaplValue(stateCaplValues.get("*numberEvents*").getNumberValue());
		    				 printMessage(referenceValueToken, "*numberEvents* is not present in the entity state, indicating an invalid persistent entity state");
			  	   	   		 return null;
		    case NOW: return stateCaplValues.get("*now*");
			case STRING: return new CaplValue(referencedValue.substring(1, referencedValue.length() - 1));
			default: return new CaplValue(Boolean.parseBoolean(referencedValue));
		}
	}

	private CaplValue collectionContainsText(Collection<CaplValue> collection, CaplValue findExpressionCaplValue, boolean caseInsensitiveMatch)
	{
		Pattern regexPattern;

		try
	  	{
	  	  	if (caseInsensitiveMatch)
	  	  		regexPattern = Pattern.compile(findExpressionCaplValue.getStringValue(), Pattern.CASE_INSENSITIVE);
	  	  	else regexPattern = Pattern.compile(findExpressionCaplValue.getStringValue());
	  	} catch (PatternSyntaxException e)
	  	{
	  	  	printMessage("Invalid regular expression \"" + findExpressionCaplValue.getStringValue() + "\"");
			return null;
	  	}

		for (CaplValue oneCollectionElement: collection)
			if (oneCollectionElement.getValueDataType() == ValueDataType.STRING && regexPattern.matcher(oneCollectionElement.getStringValue()).matches())
			  	return new CaplValue(true);
		
		return new CaplValue(false);
	}

	private CaplValue textContainsText(String text, String findExpression, boolean caseInsensitiveMatch)
	{
		Pattern regexPattern;

		try
	  	{
	  	  	if (caseInsensitiveMatch)
	  	  		regexPattern = Pattern.compile(findExpression, Pattern.CASE_INSENSITIVE);
	  	  	else regexPattern = Pattern.compile(findExpression);
	  	} catch (PatternSyntaxException e)
	  	{
	  	  	printMessage("Invalid regular expression \"" + findExpression + "\"");
			return null;
	  	}

		return new CaplValue(regexPattern.matcher(text).find());
	}

	private CaplValue collectionContainsCount(Collection<CaplValue> collection, CaplValue findExpressionCaplValue, boolean caseInsensitiveMatch)
	{
		Pattern regexPattern;

		int numberMatches = 0;

		if (findExpressionCaplValue.getValueDataType() == ValueDataType.STRING)
		{
			try
		  	{
		  	  	if (caseInsensitiveMatch)
		  	  		regexPattern = Pattern.compile(findExpressionCaplValue.getStringValue(), Pattern.CASE_INSENSITIVE);
		  	  	else regexPattern = Pattern.compile(findExpressionCaplValue.getStringValue());
		  	} catch (PatternSyntaxException e)
		  	{
		  	  	printMessage("Invalid regular expression \"" + findExpressionCaplValue.getStringValue() + "\"");
				return null;
		  	}

			for (CaplValue oneCollectionElement: collection)
				if (oneCollectionElement.getValueDataType() == ValueDataType.STRING && regexPattern.matcher(oneCollectionElement.getStringValue()).matches())
				  	numberMatches++;
		}
		else for (CaplValue oneCollectionElement: collection)
				if (oneCollectionElement.equals(findExpressionCaplValue))
				  	numberMatches++;
		
		return new CaplValue(numberMatches);
	}

	private CaplValue collectionContainsCount(Set<String> collection, CaplValue findExpressionCaplValue, boolean caseInsensitiveMatch)
	{
		Pattern regexPattern;

		int numberMatches = 0;

		try
	  	{
	  	  	if (caseInsensitiveMatch)
	  	  		regexPattern = Pattern.compile(findExpressionCaplValue.getStringValue(), Pattern.CASE_INSENSITIVE);
	  	  	else regexPattern = Pattern.compile(findExpressionCaplValue.getStringValue());
	  	} catch (PatternSyntaxException e)
	  	{
	  	  	printMessage("Invalid regular expression \"" + findExpressionCaplValue.getStringValue() + "\"");
			return null;
	  	}

		for (String oneCollectionElement: collection)
			if (regexPattern.matcher(oneCollectionElement).matches())
			  	numberMatches++;
		
		return new CaplValue(numberMatches);
	}

	private CaplValue collectionContainsText(Set<String> collection, CaplValue findExpressionCaplValue, boolean caseInsensitiveMatch)
	{
	  	Pattern regexPattern;
	  	
		try
	  	{
	  	  	if (caseInsensitiveMatch)
	  	  		regexPattern = Pattern.compile(findExpressionCaplValue.getStringValue(), Pattern.CASE_INSENSITIVE);
	  	  	else regexPattern = Pattern.compile(findExpressionCaplValue.getStringValue());
	  	} catch (PatternSyntaxException e)
	  	{
	  	  	printMessage("Invalid regular expression \"" + findExpressionCaplValue.getStringValue() + "\"");
			return null;
	  	}

		for (String oneCollectionElement: collection)
		{
		  	if (regexPattern.matcher(oneCollectionElement).matches())
		  		return new CaplValue(true);
		}

		return new CaplValue(false);
	}

	private CaplValue textContainsCollection(String text, Collection<CaplValue> collection, boolean caseInsensitiveMatch, boolean partialMatch)
	{
	  	int numElements = 0;

	  	Pattern regexPattern;

	  	String oneStringElement;

	  	if (collection.size() == 0)
	  		return new CaplValue(true);

		for (CaplValue oneCollectionElement: collection)
			if (oneCollectionElement.getValueDataType() == ValueDataType.STRING)
			{
			  	numElements++;
			  	oneStringElement = oneCollectionElement.getStringValue();
			  	  	
				try
			  	{
			  	  	if (caseInsensitiveMatch)
			  	  		regexPattern = Pattern.compile(oneStringElement, Pattern.CASE_INSENSITIVE);
			  	  	else regexPattern = Pattern.compile(oneStringElement);
			  	  	if (regexPattern.matcher(text).find())
			  	  	{ 
			  	  		if (partialMatch)
		  					return new CaplValue(true);
		  			}
		  			else if (!partialMatch)
		  				return new CaplValue(false);
			  	} catch (PatternSyntaxException e)
			  	{
			  	  	if (caseInsensitiveMatch)
			  	  	{
			  	  		if (text.toLowerCase().indexOf(oneStringElement.toLowerCase()) >= 0)
			  	  		{
							if (partialMatch)
								return new CaplValue(true);
						}
						else if (!partialMatch)
							return new CaplValue(false);
					}
					else if (text.indexOf(oneStringElement) >= 0)
		  	  		{ 
						if (partialMatch)
							return new CaplValue(true);
					}
					else if (!partialMatch)
						return new CaplValue(false);
			  	}
			}

		if (numElements == 0)
			return new CaplValue(true);
		if (partialMatch)
    		return new CaplValue(false);
    	return new CaplValue(true);
	}

	private CaplValue collectionContains(Collection<CaplValue> collection1, Collection<CaplValue> collection2, boolean caseInsensitiveMatch, boolean partialMatch)
	{
	  	int numElements = 0;

	  	CaplValue foundMatch;

	  	if (collection2.size() == 0)
	  		return new CaplValue(true);

	  	for (CaplValue oneCollectionElement: collection2)
	  	{
	  	  	numElements++;
			if (oneCollectionElement.getValueDataType() == ValueDataType.STRING)
			{
			  	foundMatch = collectionContainsText(collection1, oneCollectionElement, caseInsensitiveMatch);
			  	if (foundMatch == null)
			  		return null;
			  	if (foundMatch.getBooleanValue())
			  	{
			  		if (partialMatch)
			  			return new CaplValue(true);
			  	}
			  	else if (!partialMatch)
			  		return new CaplValue(false);
			  	
			}
			else if (collection1.contains(oneCollectionElement))
			{
			  	if (partialMatch)
			  		return new CaplValue(true);
			}
			else if (!partialMatch)
				return new CaplValue(false);
		}

		if (numElements == 0)
			return new CaplValue(true);
		if (partialMatch)
    		return new CaplValue(false);
    	return new CaplValue(true);
	}

	private CaplValue collectionContains(Set<String> collection1, Collection<CaplValue> collection2, boolean caseInsensitiveMatch, boolean partialMatch)
	{
	  	int numElements = 0;

	  	CaplValue foundMatch;

	  	if (collection2.size() == 0)
	  		return new CaplValue(true);

	  	for (CaplValue oneCollectionElement: collection2)
	  	{
	  	  	numElements++;
			if (oneCollectionElement.getValueDataType() == ValueDataType.STRING)
			{
			  	foundMatch = collectionContainsText(collection1, oneCollectionElement, caseInsensitiveMatch);
			  	if (foundMatch == null)
			  		return null;
			  	if (foundMatch.getBooleanValue())
			  	{
			  		if (partialMatch)
			  			return new CaplValue(true);
			  	}
			  	else if (!partialMatch)
			  		return new CaplValue(false);
			}
		}

		if (numElements == 0)
			return new CaplValue(true);
		if (partialMatch)
    		return new CaplValue(false);
    	return new CaplValue(true);
	}

	private CaplValue valueContains(CaplValue referencedCaplValue, CaplValue findExpressionCaplValue, boolean caseInsensitiveMatch, boolean partialMatch)
  	{
  	  	if (referencedCaplValue == null)
		{
	  	  	printMessage("Specified referenced value does not exist");
	  	  	return null;
		}
		if (findExpressionCaplValue == null)
		{
			printMessage("Invalid SET/LIST/STRING CONTAINS element value");
			return null;
		}
		if (!validateMatchingProperties(findExpressionCaplValue, caseInsensitiveMatch, partialMatch))
			return null;

		switch (referencedCaplValue.getValueDataType())
  		{
  		  	case SET: switch (findExpressionCaplValue.getValueDataType())
				  	  {
				  	  	  	case NUMBER: return new CaplValue(referencedCaplValue.getSetValue().contains(findExpressionCaplValue));
				  	  	  	case STRING: return collectionContainsText(referencedCaplValue.getSetValue(), findExpressionCaplValue, caseInsensitiveMatch);
				  	  	  	case BOOLEAN: return new CaplValue(referencedCaplValue.getSetValue().contains(findExpressionCaplValue));
				  	  	  	case SET: return collectionContains(referencedCaplValue.getSetValue(), findExpressionCaplValue.getSetValue(), caseInsensitiveMatch, partialMatch);
				  	  	  	case LIST: return collectionContains(referencedCaplValue.getSetValue(), findExpressionCaplValue.getListValue(), caseInsensitiveMatch, partialMatch);
				  	  	  	default: printOperandDataTypeError(new String[] { "NUMBER", "STRING", "BOOLEAN", "SET", "LIST" }, findExpressionCaplValue, "CONTAINS");
				  	  	  			 return null;
				  	  }
		 	case LIST: switch (findExpressionCaplValue.getValueDataType())
				  	   {
				  	     	case NUMBER: return new CaplValue(referencedCaplValue.getListValue().contains(findExpressionCaplValue));
				  	  	  	case STRING: return collectionContainsText(referencedCaplValue.getListValue(), findExpressionCaplValue, caseInsensitiveMatch);
				  	  	  	case BOOLEAN: return new CaplValue(referencedCaplValue.getListValue().contains(findExpressionCaplValue));
				  	  	  	case SET: return collectionContains(referencedCaplValue.getListValue(), findExpressionCaplValue.getSetValue(), caseInsensitiveMatch, partialMatch);
				  	  	  	case LIST: return collectionContains(referencedCaplValue.getListValue(), findExpressionCaplValue.getListValue(), caseInsensitiveMatch, partialMatch);
				  	  	  	default: printOperandDataTypeError(new String[] { "NUMBER", "STRING", "BOOLEAN", "SET", "LIST" }, findExpressionCaplValue, "CONTAINS");
				  	  	  			 return null;
				  	   }
		 	case STRING: switch (findExpressionCaplValue.getValueDataType())
				  	     {
				  	     	case STRING: return textContainsText(referencedCaplValue.getStringValue(), findExpressionCaplValue.getStringValue(), caseInsensitiveMatch);
				  	  	  	case SET: return textContainsCollection(referencedCaplValue.getStringValue(), findExpressionCaplValue.getSetValue(), caseInsensitiveMatch, partialMatch);
				  	  	  	case LIST: return textContainsCollection(referencedCaplValue.getStringValue(), findExpressionCaplValue.getListValue(), caseInsensitiveMatch, partialMatch);
				  	  	  	default: printOperandDataTypeError(new String[] { "STRING", "SET", "LIST" }, findExpressionCaplValue, "CONTAINS");
				  	  	  			 return null;
				  	     }
	   		default: printOperandDataTypeError(new String[] { "SET", "LIST", "STRING" }, referencedCaplValue, "CONTAINS");
	   				 return null;
	   	}
  	}

  	private CaplValue containsKeys(CaplValue referencedCaplValue, CaplValue findExpressionCaplValue, boolean caseInsensitiveMatch, boolean partialMatch)
  	{
  	  	if (referencedCaplValue == null)
		{
	  	  	printMessage("Specified referenced value does not exist");
	  	  	return null;
		}
		if (findExpressionCaplValue == null)
		{
			printMessage("Invalid MAP KEY CONTAINS value");
			return null;
		}
		if (!validateMatchingProperties(findExpressionCaplValue, caseInsensitiveMatch, partialMatch))
			return null;

		if (referencedCaplValue.getValueDataType() == ValueDataType.MAP)
			switch (findExpressionCaplValue.getValueDataType())
		  	{
	  	  	  	case STRING: return collectionContainsText(referencedCaplValue.getMapValue().keySet(), findExpressionCaplValue, caseInsensitiveMatch);
	  	  	  	case SET: return collectionContains(referencedCaplValue.getMapValue().keySet(), findExpressionCaplValue.getSetValue(), caseInsensitiveMatch, partialMatch);
	  	  	  	case LIST: return collectionContains(referencedCaplValue.getMapValue().keySet(), findExpressionCaplValue.getListValue(), caseInsensitiveMatch, partialMatch);
	  	  	  	default: printOperandDataTypeError(new String[] { "STRING", "SET", "LIST" }, findExpressionCaplValue, "CONTAINS KEYS");
	  	  	  			 return null;
		  	}

		printOperandDataTypeError(new String[] { "MAP" }, referencedCaplValue, "CONTAINS KEYS");
	   	return null;
  	}

  	private CaplValue containsValues(CaplValue referencedCaplValue, CaplValue findExpressionCaplValue, boolean caseInsensitiveMatch, boolean partialMatch)
  	{
  	  	if (referencedCaplValue == null)
		{
	  	  	printMessage("Specified referenced value does not exist");
	  	  	return null;
		}
		if (findExpressionCaplValue == null)
		{
			printMessage("Invalid MAP VALUE CONTAINS value");
			return null;
		}
		if (!validateMatchingProperties(findExpressionCaplValue, caseInsensitiveMatch, partialMatch))
			return null;
		
		if (referencedCaplValue.getValueDataType() == ValueDataType.MAP)
		    switch (findExpressionCaplValue.getValueDataType())
		  	{
	  	  	  	case NUMBER: return new CaplValue(referencedCaplValue.getMapValue().values().contains(findExpressionCaplValue));
	  	  	  	case STRING: return collectionContainsText(referencedCaplValue.getMapValue().values(), findExpressionCaplValue, caseInsensitiveMatch);
	  	  	  	case BOOLEAN:return new CaplValue(referencedCaplValue.getMapValue().values().contains(findExpressionCaplValue));
	  	  	  	case SET: return collectionContains(referencedCaplValue.getMapValue().values(), findExpressionCaplValue.getSetValue(), caseInsensitiveMatch, partialMatch);
	  	  	  	case LIST: return collectionContains(referencedCaplValue.getMapValue().values(), findExpressionCaplValue.getListValue(), caseInsensitiveMatch, partialMatch);
	  	  	  	default: printOperandDataTypeError(new String[] { "NUMBER", "STRING", "BOOLEAN", "SET", "LIST" }, findExpressionCaplValue, "CONTAINS");
	  	  	  			 return null;
		  	}

		printOperandDataTypeError(new String[] { "MAP" }, referencedCaplValue, "CONTAINS VALUES");
	   	return null;
  	}

	private CaplValue count(CaplValue referencedCaplValue, Token aggregationToken, CaplValue countExpression, boolean caseInsensitiveMatch)
	{
		  	switch (aggregationToken.kind)
		  	{ 
				case COUNT: switch (referencedCaplValue.getValueDataType())
							{
								case STRING: if (countExpression == null)
												return new CaplValue(referencedCaplValue.getStringValue().length());
											 if (countExpression.getValueDataType() == ValueDataType.STRING)
											 	return countOccurrences(referencedCaplValue, countExpression, caseInsensitiveMatch);
											 printOperandDataTypeError(new String[] { "STRING" }, countExpression, "COUNT");
							   			 	 return null;
								case SET: if (countExpression == null)
											return new CaplValue(referencedCaplValue.getSetValue().size());
										  return collectionContainsCount(referencedCaplValue.getSetValue(), countExpression, caseInsensitiveMatch);
								case LIST: if (countExpression == null)
											return new CaplValue(referencedCaplValue.getListValue().size());
										  return collectionContainsCount(referencedCaplValue.getListValue(), countExpression, caseInsensitiveMatch);
								default: printOperandDataTypeError(new String[] { "STRING, SET, LIST" }, referencedCaplValue, "COUNT");
							   			 return null;
							}
				case COUNT_KEYS: if (referencedCaplValue.getValueDataType() == ValueDataType.MAP)
								 {
									if (countExpression == null)
										return new CaplValue(referencedCaplValue.getMapValue().size());
									if (countExpression.getValueDataType() == ValueDataType.STRING)
										return collectionContainsCount(referencedCaplValue.getMapValue().keySet(), countExpression, caseInsensitiveMatch);
									printOperandDataTypeError(new String[] { "STRING" }, countExpression, "COUNT_KEYS");
							   		return null;
								 }
								 printOperandDataTypeError(new String[] { "MAP" }, referencedCaplValue, "COUNT_KEYS");
							   	 return null;
				default: if (referencedCaplValue.getValueDataType() == ValueDataType.MAP)
							if (countExpression == null)
								return new CaplValue(referencedCaplValue.getMapValue().values().size());
							else return collectionContainsCount(referencedCaplValue.getMapValue().values(), countExpression, caseInsensitiveMatch);
						 printOperandDataTypeError(new String[] { "MAP" }, referencedCaplValue, "COUNT_VALUES");
						 return null;
			}
	}

  	private boolean addCollectionValue(CaplValue referencedCaplValue, CaplValue collectionKeyCaplValue, CaplValue collectionCaplValueElement, boolean isInitializer)
  	{
  	  	Set<CaplValue> setValues;

  	  	Map<String, CaplValue> mapValues;

  	  	List<CaplValue> listValues;

  	  	int removeListElements;

  	  	if (referencedCaplValue == null)
		{
	  	  	printMessage("Specified referenced value does not exist");
	  	  	return false;
		}
		if (referencedCaplValue.getMutability() == Mutability.CONSTANT)
		{
			printMessage("Specified collection value is a CONSTANT and cannot be modified (added to)");
	  	  	return false;
		}
		if (collectionKeyCaplValue == null)
		{
			printMessage("Invalid SET or LIST element or MAP key value");
			return false;
		}
		
		switch (referencedCaplValue.getValueDataType())
		{
		  	case SET: if (collectionCaplValueElement == null)
				  	  {
				  		  	setValues = referencedCaplValue.getSetValue();
				  		  	switch (collectionKeyCaplValue.getValueDataType())
					  	  	{
					  	  	  	case NUMBER: 
					  	  	  	case STRING: 
					  	  	  	case BOOLEAN: setValues.add(collectionKeyCaplValue); return true;
					  	  	  	case SET: setValues.addAll(collectionKeyCaplValue.getSetValue()); return true;
					  	  	  	default: printOperandDataTypeError(new String[] { "NUMBER", "STRING", "BOOLEAN", "SET" }, collectionKeyCaplValue, "ADD");
					  	  	  			 return false;
					  	  	}
					  }
					  printMessage("SET ADD operation must have a single operand, not a pair of operands");
					  return false;
			case MAP: mapValues = referencedCaplValue.getMapValue();
					  if (collectionKeyCaplValue.getValueDataType() == ValueDataType.MAP)
							if (collectionCaplValueElement == null)
							{ 
							  	mapValues.putAll(collectionKeyCaplValue.getMapValue());
							  	return true;
							}
							else printMessage("MAP ADD operation must have a single operand if the key is another MAP (i.e., if you are adding a MAP to a MAP), not a pair of operands");
					  else if (collectionCaplValueElement == null)
					  {
					    	printMessage("Value to add to the map is null");
					    	return false;
					  }
					  else if (collectionKeyCaplValue.getValueDataType() == ValueDataType.NUMBER)
					  { 
					  		mapValues.put("" + collectionKeyCaplValue.getNumberValue(), collectionCaplValueElement);
					  		return true;
					  }
					  else if (collectionKeyCaplValue.getValueDataType() == ValueDataType.STRING)
					  { 
					  		mapValues.put(collectionKeyCaplValue.getStringValue(), collectionCaplValueElement);
					  		return true;
					  }
					  else if (collectionKeyCaplValue.getValueDataType() == ValueDataType.BOOLEAN)
					  { 
					  		mapValues.put("" + collectionKeyCaplValue.getBooleanValue(), collectionCaplValueElement);
					  		return true;
					  }
					  printOperandDataTypeError(new String[] { "STRING" }, collectionKeyCaplValue, "ADD");
					  return false;
			case LIST: if (collectionCaplValueElement == null)
				  	   {
				  		  	listValues = referencedCaplValue.getListValue();
						  	switch (collectionKeyCaplValue.getValueDataType())
					  	  	{
					  	  	  	case NUMBER: 
					  	  	  	case STRING: 
					  	  	  	case BOOLEAN:
					  	  	  	case SET: 
					  	  	  	case MAP: listValues.add(collectionKeyCaplValue); break;
					  	  	  	default: listValues.addAll(collectionKeyCaplValue.getListValue());
					  	  	}
					  	  	if (!isInitializer && referencedCaplValue.getTimeWindowStart() == 0L)
					  	  	{
					  	  	  	removeListElements = listValues.size() - referencedCaplValue.getCapacity();
					  	  	  	while (removeListElements > 0)
					  	  	  	{ 
						  	  		listValues.remove(0);
						  	  		removeListElements--;
						  	  	}
						  	}
					  	  	return true;
					   }
					   else printMessage("LIST ADD operation must have a single operand, not a pair of operands");
					   return false;
			default: printOperandDataTypeError(new String[] { "SET", "MAP", "LIST" }, referencedCaplValue, "ADD");
					 return false;
		}
  	}

  	private boolean removeCollectionValue(CaplValue referencedCaplValue, CaplValue collectionKeyCaplValue)
  	{
  	  	Set<CaplValue> setValues;
  	  	
  	  	Map<String, CaplValue> mapValues;

		List<CaplValue> listValues;

  	  	int listIndex;

  	  	if (referencedCaplValue == null)
		{
	  	  	printMessage("Specified referenced value does not exist");
	  	  	return false;
		}
		if (referencedCaplValue.getMutability() == Mutability.CONSTANT)
		{
			printMessage("Specified collection value is a CONSTANT and cannot be modified (removed from)");
	  	  	return false;
		}
		if (collectionKeyCaplValue == null)
		{
			printMessage("Invalid SET or LIST element or MAP key value");
			return false;
		}

		switch (referencedCaplValue.getValueDataType())
  		{
		  	case SET: setValues = referencedCaplValue.getSetValue();
					  switch (collectionKeyCaplValue.getValueDataType())
				  	  {
				  	  	  	case NUMBER: setValues.remove(collectionKeyCaplValue); return true;
				  	  	  	case STRING: if (isEmpty(collectionKeyCaplValue.getStringValue()))
							  	  	  	 {
											printMessage("STRING key for collection operation must not be empty");
											return false;
							  	  	  	 }
							  	  	  	 if (collectionKeyCaplValue.getStringValue().equals(ALL_COLLECTION_VALUES_KEY))
							  	  	  	 	setValues.clear();
				  	  	  				 else setValues.remove(collectionKeyCaplValue);
				  	  	  				 return true;
				  	  	  	case BOOLEAN: setValues.remove(collectionKeyCaplValue); return true;
				  	  	  	case SET: setValues.removeAll(collectionKeyCaplValue.getSetValue()); return true;
				  	  	  	default: printOperandDataTypeError(new String[] { "NUMBER", "STRING", "BOOLEAN", "SET" }, collectionKeyCaplValue, "REMOVE");
				  	  	  			 return false;
				  	  }
			case MAP: mapValues = referencedCaplValue.getMapValue();
					  if (collectionKeyCaplValue.getValueDataType() == ValueDataType.STRING)
					  {
					     if (isEmpty(collectionKeyCaplValue.getStringValue()))
			  	  	  	 {
							printMessage("STRING key for collection operation must not be empty");
							return false;
			  	  	  	 }
			  	  	  	 if (collectionKeyCaplValue.getStringValue().equals(ALL_COLLECTION_VALUES_KEY))
						 	mapValues.clear();
					  	 else mapValues.remove(collectionKeyCaplValue.getStringValue());
					  	 return true;
					  }
					  printOperandDataTypeError(new String[] { "STRING", "MAP" }, collectionKeyCaplValue, "REMOVE");
					  return false;
			case LIST: listValues = referencedCaplValue.getListValue();
					   if (collectionKeyCaplValue.getValueDataType() == ValueDataType.NUMBER && Double.isNaN(collectionKeyCaplValue.getNumberValue()))
					   {
					   	  	listIndex = listValues.size() - 1;
							listValues.remove(listIndex);
					     	return true;
					   }
					   switch (collectionKeyCaplValue.getValueDataType())
				  	   {
				  	  	  	case NUMBER: listValues.remove(collectionKeyCaplValue); return true;
				  	  	  	case STRING: if (collectionKeyCaplValue.getStringValue().equals(ALL_COLLECTION_VALUES_KEY))
							  	  	  	 	listValues.clear();
							  	  	  	 else listValues.remove(collectionKeyCaplValue);
							  	  	  	 return true;
				  	  	  	case BOOLEAN: listValues.remove(collectionKeyCaplValue); return true;
				  	  	  	case LIST: listValues.removeAll(collectionKeyCaplValue.getListValue()); return true;
				  	  	  	default: printOperandDataTypeError(new String[] { "NUMBER", "STRING", "BOOLEAN", "LIST" }, collectionKeyCaplValue, "REMOVE");
				  	  	  			 return false;
				  	   }
			default: printOperandDataTypeError(new String[] { "SET", "MAP", "LIST" }, referencedCaplValue, "REMOVE");
					 return false;
		}
  	}

  	private boolean removeCollectionValues(CaplValue referencedCaplValue)
  	{
  	  	if (referencedCaplValue == null)
		{
	  	  	printMessage("Specified referenced value does not exist");
	  	  	return false;
		}
		if (referencedCaplValue.getMutability() == Mutability.CONSTANT)
		{
			printMessage("Specified collection value is a CONSTANT and cannot be modified (removed from)");
	  	  	return false;
		}

		switch (referencedCaplValue.getValueDataType())
  		{
		  	case SET: referencedCaplValue.getSetValue().clear(); break;
			case MAP: referencedCaplValue.getMapValue().clear(); break;
			case LIST: referencedCaplValue.getListValue().clear(); break;
			default: printOperandDataTypeError(new String[] { "SET", "MAP", "LIST" }, referencedCaplValue, "REMOVE_ALL");
					 return false;
		}

		return true;
  	}

	private CaplValue parseDate(CaplValue dateCaplValue, CaplValue datePatternCaplValue)
	{
		SimpleDateFormat dateParser;

		if (dateCaplValue == null || datePatternCaplValue == null)
			return null;

		if (dateCaplValue.getValueDataType() == ValueDataType.STRING)
		{
	  	  	if (datePatternCaplValue.getValueDataType() == ValueDataType.STRING)
				try
				{
				  	dateParser = new SimpleDateFormat(datePatternCaplValue.getStringValue());
				  	return new CaplValue(dateParser.parse(dateCaplValue.getStringValue()).getTime()); // Return date as a number of milliseconds since epoch beginning.
				} catch (Exception e)
				{
				  	printMessage("Unable to parse date string \"" + dateCaplValue.getStringValue() + "\" with date/time pattern \"" + datePatternCaplValue.getStringValue() + "\"");
				  	return null;
				}
			printOperandDataTypeError(new String[] { "STRING" }, datePatternCaplValue, "DATE");
			return null;
		}

		printOperandDataTypeError(new String[] { "STRING" }, dateCaplValue, "DATE");
		return null;
	}

	private CaplValue formatDate(CaplValue dateCaplValue, CaplValue datePatternCaplValue)
	{
		SimpleDateFormat dateParser;

		if (dateCaplValue == null || datePatternCaplValue == null)
			return null;

		if (dateCaplValue.getValueDataType() == ValueDataType.STRING)
			try
			{
			  	dateCaplValue = new CaplValue(Double.parseDouble(dateCaplValue.getStringValue()));
			} catch (NumberFormatException e)
			{
			  	printOperandDataTypeError(new String[] { "NUMBER", "NUMBER_AS_STRING" }, datePatternCaplValue, "NUMBER_TO_DATE");
				return null;
			}
		if (dateCaplValue.getValueDataType() == ValueDataType.NUMBER)
		{
	  	  	if (datePatternCaplValue.getValueDataType() == ValueDataType.STRING)
				try
				{
				  	dateParser = new SimpleDateFormat(datePatternCaplValue.getStringValue());
				  	return new CaplValue(dateParser.format(new Date((long) dateCaplValue.getNumberValue())));
				} catch (Exception e)
				{
				  	printMessage("Unable to parse date string \"" + dateCaplValue.getNumberValue() + "\" with date/time pattern \"" + datePatternCaplValue.getStringValue() + "\"");
				  	return null;
				}
			printOperandDataTypeError(new String[] { "STRING" }, datePatternCaplValue, "NUMBER_TO_DATE");
			return null;
		}

		printOperandDataTypeError(new String[] { "NUMBER", "NUMBER_AS_STRING" }, dateCaplValue, "NUMBER_TO_DATE");
		return null;
	}

	private String urlEncodeMap(CaplValue mapCaplValue)
	{
	  	String urlEncodedMap = "",
	  		   parameterValue;
	  		   
		for (Entry<String, CaplValue> mapValue: mapCaplValue.getMapValue().entrySet())
		{
			parameterValue = CapHttpClient.getAsString(mapValue.getValue());
			if (parameterValue == null)
			{
				printMessage("Invalid value \"" + mapValue.getValue() + "\" for map entry \"" + mapValue.getKey() + "\" - map entry value must be of primitive NUMBER, STRING, or BOOLEAN type");
				return null;
			}
			if (urlEncodedMap.length() > 0)
				urlEncodedMap += "&";
			try
			{ 
				urlEncodedMap += mapValue.getKey() + "=" + URLEncoder.encode(parameterValue, StandardCharsets.UTF_8.toString());
			} catch (Exception e)
			{
			  	printMessage("Invalid value \"" + parameterValue + "\" for map entry \"" + mapValue.getKey() + "\" - unable to URLEncode the map entry value");
			  	return null;
			}
		}

		return urlEncodedMap;
	}

	private CaplValue operateOnSet(CaplValue setCaplValue, CaplValue numberCaplValue, Token operator)
	{
	  	final CaplValue clonedSetCaplValue = CaplCollection.getSet(setCaplValue.getCapacity());

	  	final Set<CaplValue> setValue = clonedSetCaplValue.getSetValue();

	  	final double number;

	  	if (operator.kind == CaplInterpreterConstants.LOG)
	  		number = 0d;
	  	else number = numberCaplValue.getNumberValue();

	  	for (CaplValue oneSetValue: setCaplValue.getSetValue())
	  		if (oneSetValue.getValueDataType() == ValueDataType.NUMBER)
	  			switch (operator.kind)
	  			{ 
	  				case PLUS: setValue.add(new CaplValue(oneSetValue.getNumberValue() + number)); break;
	  				case MINUS: setValue.add(new CaplValue(oneSetValue.getNumberValue() - number)); break;
	  				case MULT: setValue.add(new CaplValue(oneSetValue.getNumberValue() * number)); break;
	  				case DIV: setValue.add(new CaplValue(oneSetValue.getNumberValue() / number)); break;
	  				case INT_DIV: setValue.add(new CaplValue(Math.floor(oneSetValue.getNumberValue() / number))); break;
	  				case MODULO: setValue.add(new CaplValue(oneSetValue.getNumberValue() % number)); break;
	  				case LOG: setValue.add(new CaplValue(Math.log(oneSetValue.getNumberValue()))); break;
	  				case ABS: setValue.add(new CaplValue(Math.abs(oneSetValue.getNumberValue()))); break;
	  				case FLOOR: setValue.add(new CaplValue(Math.floor(oneSetValue.getNumberValue()))); break;
	  				case CEIL: setValue.add(new CaplValue(Math.ceil(oneSetValue.getNumberValue()))); break;
	  				default: // EXP
	  						 setValue.add(new CaplValue(Math.pow(oneSetValue.getNumberValue(), number)));
	  			}
	  		else
	  		{
	  		  	printOperandDataTypeError(new String[] { "SET contains non-numeric values, thus performing an numeric function on all elements is not allowed" }, setCaplValue, operator);
	  		  	return null;
	  		}

	  	return clonedSetCaplValue;
	}

	private CaplValue operateOnMap(CaplValue mapCaplValue, CaplValue numberCaplValue, Token operator)
	{
	  	final CaplValue clonedMapCaplValue = CaplCollection.getMap(mapCaplValue.getCapacity());

	  	final Map<String, CaplValue> mapValue = clonedMapCaplValue.getMapValue();

	  	final double number;

	  	if (operator.kind == CaplInterpreterConstants.LOG)
	  		number = 0d;
	  	else number = numberCaplValue.getNumberValue();

	  	for (Entry<String, CaplValue> oneMapValue: mapCaplValue.getMapValue().entrySet())
	  		if (oneMapValue.getValue().getValueDataType() == ValueDataType.NUMBER)
	  			switch (operator.kind)
	  			{ 
	  				case PLUS: mapValue.put(oneMapValue.getKey(), new CaplValue(oneMapValue.getValue().getNumberValue() + number)); break;
	  				case MINUS: mapValue.put(oneMapValue.getKey(), new CaplValue(oneMapValue.getValue().getNumberValue() - number)); break;
	  				case MULT: mapValue.put(oneMapValue.getKey(), new CaplValue(oneMapValue.getValue().getNumberValue() * number)); break;
	  				case DIV: mapValue.put(oneMapValue.getKey(), new CaplValue(oneMapValue.getValue().getNumberValue() / number)); break;
	  				case INT_DIV: mapValue.put(oneMapValue.getKey(), new CaplValue(Math.floor(oneMapValue.getValue().getNumberValue() / number))); break;
	  				case MODULO: mapValue.put(oneMapValue.getKey(), new CaplValue(oneMapValue.getValue().getNumberValue() % number)); break;
	  				case LOG: mapValue.put(oneMapValue.getKey(), new CaplValue(Math.log(oneMapValue.getValue().getNumberValue()))); break;
	  				case ABS: mapValue.put(oneMapValue.getKey(), new CaplValue(Math.abs(oneMapValue.getValue().getNumberValue()))); break;
	  				case FLOOR: mapValue.put(oneMapValue.getKey(), new CaplValue(Math.floor(oneMapValue.getValue().getNumberValue()))); break;
	  				case CEIL: mapValue.put(oneMapValue.getKey(), new CaplValue(Math.ceil(oneMapValue.getValue().getNumberValue()))); break;
	  				default: // EXP
	  						 mapValue.put(oneMapValue.getKey(), new CaplValue(Math.pow(oneMapValue.getValue().getNumberValue(), number)));
	  			}
	  		else
	  		{
	  		  	printOperandDataTypeError(new String[] { "MAP contains non-numeric values, thus performing an numeric function on all elements is not allowed" }, mapCaplValue, operator);
	  		  	return null;
	  		}

	  	return clonedMapCaplValue;
	}

	private CaplValue operateOnList(CaplValue listCaplValue, CaplValue numberCaplValue, Token operator)
	{
	  	final CaplValue clonedListCaplValue = CaplCollection.getList(listCaplValue.getCapacity());

	  	final List<CaplValue> listValue = clonedListCaplValue.getListValue();

	  	final double number;

	  	if (operator.kind == CaplInterpreterConstants.LOG)
	  		number = 0d;
	  	else number = numberCaplValue.getNumberValue();

	  	for (CaplValue oneListValue: listCaplValue.getListValue())
	  		if (oneListValue.getValueDataType() == ValueDataType.NUMBER)
	  			switch (operator.kind)
	  			{ 
	  				case PLUS: listValue.add(new CaplValue(oneListValue.getNumberValue() + number)); break;
	  				case MINUS: listValue.add(new CaplValue(oneListValue.getNumberValue() - number)); break;
	  				case MULT: listValue.add(new CaplValue(oneListValue.getNumberValue() * number)); break;
	  				case DIV: listValue.add(new CaplValue(oneListValue.getNumberValue() / number)); break;
	  				case INT_DIV: listValue.add(new CaplValue(Math.floor(oneListValue.getNumberValue() / number))); break;
	  				case MODULO: listValue.add(new CaplValue(oneListValue.getNumberValue() % number)); break;
	  				case LOG: listValue.add(new CaplValue(Math.log(oneListValue.getNumberValue()))); break;
	  				case ABS: listValue.add(new CaplValue(Math.abs(oneListValue.getNumberValue()))); break;
	  				case FLOOR: listValue.add(new CaplValue(Math.floor(oneListValue.getNumberValue()))); break;
	  				case CEIL: listValue.add(new CaplValue(Math.ceil(oneListValue.getNumberValue()))); break;
	  				default: // EXP
	  						 listValue.add(new CaplValue(Math.pow(oneListValue.getNumberValue(), number)));
	  			}
	  		else
	  		{
	  		  	printOperandDataTypeError(new String[] { "LIST contains non-numeric values, thus performing an numeric function on all elements is not allowed" }, listCaplValue, operator);
	  		  	return null;
	  		}

	  	return clonedListCaplValue;
	}

  	public static void setCapHttpClient(CapHttpClient capHttpClient)
  	{
  	  	capHttpClientField = capHttpClient;
  	}

  	public static void setEventRecorder(EventRecorder eventRecorder)
  	{
  	  	eventRecorderField = eventRecorder;
  	}

  	public ObjectNode analyzeEvent(String analysisId, Map<String, CaplValue> analysisStateCaplValues, Map<String, CaplValue> entityStateCaplValues, JsonNode eventObject)
	{
		Map<String, CaplValue> outputCaplValues;

		Set<String> referencedIdentifiers = null;

  		final boolean firstExecutionForEntity = entityStateCaplValues.get("*numberEvents*").getNumberValue() == 1d;

  		boolean debug;

  		CaplValue eventCaplValue;

  		if (LOGGER.isTraceEnabled())
			LOGGER.trace("Starting CAP analysis interpretation...");

		if (firstExecutionForEntity)
	  		referencedIdentifiers = new HashSet<String>();

		try
	    {
			eventCaplValue = JsonManager.convertJsonToCaplValue(eventObject, Mutability.CONSTANT);
			if (eventCaplValue == null) 
				return JsonManager.generateResponseObject("The event object is not valid JSON");
	      
	      	if (firstExecutionForEntity)
	      	{
	      	  	if (analysisStateCaplValues.size() == 0)
				{
				  	if (!settings(analysisStateCaplValues, referencedIdentifiers))
				  		return JsonManager.generateResponseObject("Unable to parse and interpret specified CAP analysis - the \"settings\" section is invalid");
				  	debug = analysisStateCaplValues.get("*debug*").getBooleanValue();
		      		// Parse the "constants section" to populate the analysis constants state. If the analysis state is empty because there are no defined constants,
		      		// we end up here as well but parsing the constants section in this case is just as fast as skipping it (else branch below). Note that the constants
		      		// section needs to be parsed only once for each analysis.
		      		if (!constants(analysisStateCaplValues, referencedIdentifiers, debug))
		      			return JsonManager.generateResponseObject("Unable to parse and interpret specified CAP analysis - the \"constants\" section is invalid");
		      	}
		      	else
		      	{
		      	  	debug = analysisStateCaplValues.get("*debug*").getBooleanValue();
		      	  	if (!section(CaplInterpreterConstants.SETTINGS, CaplInterpreterConstants.SEMICOLON, debug)) // Skip "settings" section".
		      			return JsonManager.generateResponseObject("Unable to parse and interpret specified CAP analysis - the \"trace\" section is invalid");
		      	   	if (!section(CaplInterpreterConstants.CONSTANTS, CaplInterpreterConstants.SEMICOLON, debug)) // Skip "constants" section".
		      			return JsonManager.generateResponseObject("Unable to parse and interpret specified CAP analysis - the \"constants\" section is invalid");
		      	}
		      	entityStateCaplValues.putAll(analysisStateCaplValues);

	      	  	// Need to parse the "variables" section to populate the entity variables state. Note that the variables section must be parsed only once for each entity.
	      		if (!variables(entityStateCaplValues, eventCaplValue, referencedIdentifiers, debug))
		      		return JsonManager.generateResponseObject("Unable to parse and interpret specified CAP analysis - the \"variables\" section is invalid");
	      	}
	      	else
	      	{
	      	  	debug = analysisStateCaplValues.get("*debug*").getBooleanValue();
	      	  	if (!section(CaplInterpreterConstants.SETTINGS, CaplInterpreterConstants.SEMICOLON, debug)) // Skip "settings" section".
		      		return JsonManager.generateResponseObject("Unable to parse and interpret specified CAP analysis - the \"trace\" section is invalid");
		      	if (!section(CaplInterpreterConstants.CONSTANTS, CaplInterpreterConstants.SEMICOLON, debug)) // Skip "constants section".
		      		return JsonManager.generateResponseObject("Unable to parse and interpret specified CAP analysis - the \"constants\" section is invalid");
		      	entityStateCaplValues.putAll(analysisStateCaplValues);
	
			    if (!section(CaplInterpreterConstants.VARIABLES, CaplInterpreterConstants.SEMICOLON, debug)) // Skip "variables" section.
		      		return JsonManager.generateResponseObject("Unable to parse and interpret specified CAP analysis - the \"variables\" section is invalid");
		    }

		    outputCaplValues = rules(entityStateCaplValues, eventCaplValue, referencedIdentifiers, debug);
	      	if (outputCaplValues == null)
	      	{
	      	  	LOGGER.error("Failed to parse and interpret CAP analysis");
	        	return JsonManager.generateResponseObject("Unable to parse and interpret specified CAP analysis");
	        }

	        if (analysisStateCaplValues.get("*eventRecording*").getBooleanValue())
	        	eventRecorderField.recordJsonObject(analysisId, eventObject);

	        if (firstExecutionForEntity)
	        	return JsonManager.generateResponseObject("Successfully parsed CAP analysis",
	        											  new String[] { "analysisState", "entityState", "output" },
	        											  new ObjectNode[] {
								      	  										JsonManager.caplValuesMapToObjectNode(analysisStateCaplValues, true),
								      	  										JsonManager.caplValuesMapToObjectNode(entityStateCaplValues, Mutability.VARIABLE, true),
								      	  										JsonManager.caplValuesMapToObjectNode(outputCaplValues, false)
								      	  								   });
	        return JsonManager.generateResponseObject("Successfully parsed CAP analysis",
	        										  new String[] { "entityState", "output" },
	        										  new ObjectNode[] {
								      	  									JsonManager.caplValuesMapToObjectNode(entityStateCaplValues, Mutability.VARIABLE, true),
								      	  									JsonManager.caplValuesMapToObjectNode(outputCaplValues, false)
								      	  							   });
	    } catch (Exception e)
	    {
	      	if (LOGGER.isTraceEnabled())
	      		StackTraceLogger.log("Unable to parse and interpret specified CAP analysis", Level.ERROR, e, LOGGER);
	      	else LOGGER.error("Unable to parse and interpret specified CAP analysis: " + e.getMessage());
	      	return JsonManager.generateResponseObject("Unable to parse and interpret specified CAP analysis");
	   	}
	}
}

PARSER_END(CaplInterpreter)

SKIP:
{
	"\r"
	| "\n"
	| "\t"
	| "\f"
	| " "
	| < "#"(~["\n"])* >
}

TOKEN:
{
  	< SETTINGS: "settings" >
 	| < DEBUG: "debug" >
 	| < EVENT_RECORDING: "recording" >
 	| < EXPIRES: "expires" >
 	| < CONSTANTS: "constants" >
	| < VARIABLES: "variables" >
	| < UPDATES: "updateRules" >
	| < OUTPUTS: "outputRules" >
	| < SET: "set" >
	| < MAP: "map" >
	| < LIST: "list" >
	| < CONTAINS_SOME: "containsSome" >
	| < CONTAINS: "contains" >
	| < CONTAINS_SOME_KEYS: "containsSomeKeys" >
	| < CONTAINS_KEYS: "containsKeys" >
	| < CONTAINS_SOME_VALUES: "containsSomeValues" >
	| < CONTAINS_VALUES: "containsValues" >
	| < CASE_INSENSITIVE_MATCH: "?" >
	| < COUNT: "count" >
	| < COUNT_KEYS: "countKeys" >
	| < COUNT_VALUES: "countValues" >
	| < FIRST_INDEX: "firstIndex" >
	| < LAST_INDEX: "lastIndex" >
	| < ADD: "add" >
	| < REMOVE: "remove" >
	| < REMOVE_LAST: "removeLast" >
	| < REMOVE_ALL: "removeAll" >
	| < GET: "get" >
	| < POST: "post" >
	| < SUM: "sum" >
	| < AVG: "avg" >
	| < MAX: "max" >
	| < MIN: "min" >
	| < STD_DEV: "stdDev" >
	| < AVG_DIFF: "avgDiff" >
	| < AVG_SQR_DIFF: "avgSqrDiff" >
	| < HISTO: "histo" >
	| < TOP: "top" >
	| < BOTTOM: "bottom" >
	| < SORT_ASC: "sortAsc" >
	| < SORT_ASC_KEYS: "sortAscKeys" >
	| < SORT_ASC_VALUES: "sortAscValues" >
	| < SORT_DESC: "sortDesc" >
	| < SORT_DESC_KEYS: "sortDescKeys" >
	| < SORT_DESC_VALUES: "sortDescValues" > 
	| < NUM_EVENTS: "numEvents" >
	| < NOW: "now" >
	| < DATE_TO_NUMBER: "dateToNumber" >
	| < DATE_TO_TIME_WINDOW: "dateToTimeWindow" >
	| < NUMBER_TO_TIME_WINDOW: "numberToTimeWindow" >
	| < STRING_TO_NUMBER: "stringToNumber" >
	| < STRING_TO_BOOLEAN: "stringToBoolean" >
	| < NUMBER_TO_STRING: "numberToString" >
	| < NUMBER_TO_DATE: "numberToDate" >
 	| < ABS: "abs" >
 	| < CEIL: "ceil" >
 	| < FLOOR: "floor" >
 	| < PLUS: "+" >
	| < MINUS: "-" >
	| < MULT: "*" >
	| < DIV: "/" >
	| < INT_DIV: "//" >
	| < MODULO: "%" >
	| < EXP: "^" >
	| < LOG: "log" >
	| < LESS: "< " >
	| < EQUALS: "=" >
	| < NOT_EQUALS: "~" >
	| < GREATER: " >" >
	| < AND: "&" >
	| < OR: "|" >
	| < NOT: "!" >
	| < ELSE: "else" >
	| < EXISTS: "exists" >
	| < NOT_NULL: "notNull" >
  	| < NUMBER: ( ["1"-"9"] (["0"-"9"])* | "0")("."(["0"-"9"])+)? >
 	| < STRING: "\""(~["\""])*"\"" >
 	| < BOOLEAN: "true" | "false" >
 	| < NUM: "num" >
 	| < PCT: "pct" >
	| < IDENTIFIER: ["a"-"z","A"-"Z","_"] ( ["a"-"z","A"-"Z","0"-"9","_"] )* >
 	| < EVENT: "@" >
 	| < LEFT_PARENTHESIS: "(" >
	| < RIGHT_PARENTHESIS: ")" >
	| < LEFT_BRACKET: "[" >
	| < RIGHT_BRACKET: "]" >
	| < LEFT_BRACE: "{" >
	| < RIGHT_BRACE: "}" >
	| < COMMA: "," >
	| < COLON: ":" >
	| < SEMICOLON: ";" >
	| < NEXT_EVAL: "\\" >
}

private boolean section(int skipFromToken, int skipToToken, boolean debug):
{
  	Token currentToken = token_source.getNextToken();

	if (debug)
 		printMessage("Skipping section", Level.TRACE);

  	if (currentToken.kind == skipFromToken)
  	{
		do
			currentToken = token_source.getNextToken();
		while(currentToken.kind != CaplInterpreterConstants.EOF && currentToken.kind != skipToToken);

		return currentToken.kind == skipToToken;
	}
	return false;
}
{
    {}
}

private CaplValue averageParameterExpression(Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Mutability mutability,
											 Set<String> referencedIdentifiers, Token aggregationToken, boolean evaluate):
{
  	CaplValue avgParameterCaplValue;
}
{
	< LEFT_PARENTHESIS > avgParameterCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate) < RIGHT_PARENTHESIS >
	{
	  	if (evaluate)
	  	{ 
			if (avgParameterCaplValue == null)
				return null;
			if (avgParameterCaplValue.getValueDataType() != ValueDataType.NUMBER)
			{
			  	printOperandDataTypeError(new String[] { "NUMBER" }, avgParameterCaplValue, aggregationToken);
			  	return null;
			}
		}
		return avgParameterCaplValue;
	}
}

private CaplValue webServiceContent(Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Mutability mutability,
									Set<String> referencedIdentifiers, boolean evaluate):
{
  	Token operator;
  	
	CaplValue urlCaplValue,
			  queryParametersCaplValue = null,
			  headerParametersCaplValue = null,
			  payloadParametersCaplValue = null,
			  returnCaplValue;

	Map<String, CaplValue> headerParametersMap = null;

	String[] queryParametersArray,
			 nameValueArray;

	String queryParameters;

	JsonElement httpResponse;
}
{
  	(
	    operator = < GET > < LEFT_PARENTHESIS >
		urlCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
		< COMMA > queryParametersCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
		|
	  	operator = < POST > < LEFT_PARENTHESIS >
		urlCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
		< COMMA > queryParametersCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
		< COMMA > payloadParametersCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
		{
		  	if (evaluate && payloadParametersCaplValue == null)
		  	{
		  	  	printMessage("Invalid payload for HTTP request"); 
				return null;
		 	}
	  	}
	)
	[
		< COMMA > headerParametersCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
		{
		  	if (evaluate && headerParametersCaplValue == null)
		  	{
		  	  	printMessage("Invalid headers for HTTP request"); 
				return null;
		 	}
		}
	]
	< RIGHT_PARENTHESIS >
  	{
  	  	if (evaluate)
  	  	{ 
		    if (urlCaplValue == null)
		    {
		      	printMessage("Invalid URL for HTTP request"); 
		    	return null;
			}
		   	if (urlCaplValue.getValueDataType() == ValueDataType.STRING)
		   	{
		   	  	if (queryParametersCaplValue == null)
			  	{
			  	  	printMessage("Invalid query parameters for HTTP request"); 
					return null;
			  	}
			  	if (queryParametersCaplValue.getValueDataType() == ValueDataType.MAP)
			  	{ 
				  	queryParameters = urlEncodeMap(queryParametersCaplValue);
				  	if (queryParameters == null)
				  		return null;
				}
				else if (queryParametersCaplValue.getValueDataType() == ValueDataType.STRING)
				{
				  	queryParameters = queryParametersCaplValue.getStringValue();
				  	if (queryParameters.indexOf('&') >= 0)
				  	{ 
					  	queryParametersArray = queryParameters.split("&");
					  	if (queryParametersArray != null && queryParametersArray.length > 0)
					  	{
						  	queryParameters = "";
						  	for (String queryParameter: queryParametersArray)
						  	{
						  	  	nameValueArray = queryParameter.split("=");
								if (nameValueArray == null || nameValueArray.length != 2)
							  	{
							  	  	printMessage("Invalid HTTP parameters \"" + queryParameters + "\" - parameters are not in the expected <name>=<value>&<name>=<value>... format");
					  				return null;
							  	}
							  	if (queryParameters.length() > 0)
							  		queryParameters += "&";
							  	try
								{ 
							  	  	queryParameters += nameValueArray[0] + "=" + URLEncoder.encode(nameValueArray[1], StandardCharsets.UTF_8.toString());
							  	} catch (Exception e)
								{
						  			printMessage("Invalid HTTP parameter \"" + queryParametersCaplValue.getStringValue() + "\" - unable to URLEncode this string value value");
						  			return null;
								}
						  	}
						 }
					}
				}
				else
				{
			  	  	printOperandDataTypeError(new String[] { "MAP", "STRING" }, queryParametersCaplValue, "GET/POST");
	  				return null; 
			  	}

			  	if (headerParametersCaplValue != null)
			    	if (headerParametersCaplValue.getValueDataType() == ValueDataType.MAP)
			    		headerParametersMap = headerParametersCaplValue.getMapValue();
			    	else
				  	{
				  	  	printOperandDataTypeError(new String[] { "MAP" }, headerParametersCaplValue, "GET/POST");
		  				return null; 
				  	}
				  
				if (payloadParametersCaplValue != null)
					if (!payloadParametersCaplValue.hasCollectionValueDataType())
				  	{
				  	  	printOperandDataTypeError(new String[] { "SET", "MAP", "LIST" }, payloadParametersCaplValue, "GET/POST");
		  				return null; 
				  	}
	
		   		httpResponse = capHttpClientField.httpRequest(operator.kind == CaplInterpreterConstants.GET, urlCaplValue.getStringValue(),
		   													  queryParameters, headerParametersMap, payloadParametersCaplValue);
		   		if (httpResponse == null)
				{
				  	printMessage("Unable to perform HTTP GET/POST request");
				  	return null;
				}
				returnCaplValue = JsonManager.convertJsonToCaplValue(httpResponse, Mutability.VARIABLE);
				if (returnCaplValue == null)
					printMessage("Unable to parse HTTP response");
				return returnCaplValue;
	    	}
	  		printOperandDataTypeError(new String[] { "STRING" }, urlCaplValue, "GET");
	  		return null;
	  	}
	  	return EMPTY_CAPL_VALUE;
	}
}

private CaplValue aggregation(CaplValue referencedCaplValue, Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Mutability mutability,
							  Set<String> referencedIdentifiers, boolean evaluate):
{
  	Token aggregationToken = null,
  		  caseInsensitiveMatch = null;

	CaplValue[] aggregationParameterCaplValues = new CaplValue[3];

	int index;
}
{
  	(	  	aggregationToken = < SUM >
	  	|
	  	aggregationToken = < MIN >
	  	|
	  	aggregationToken = < MAX >
	  	|
	  	aggregationToken = < STD_DEV >
	  	|
	  	aggregationToken = < SORT_ASC >
		|
		aggregationToken = < SORT_ASC_KEYS >
		|
		aggregationToken = < SORT_ASC_VALUES > 
		|
		aggregationToken = < SORT_DESC >
		|
		aggregationToken = < SORT_DESC_KEYS >
		|
		aggregationToken = < SORT_DESC_VALUES >
		|
	  	(
	  	  	(
		  	  	aggregationToken = < AVG >
		  	  	|
	  		  	aggregationToken = < AVG_DIFF >
	  	  		|
	  	  		aggregationToken = < AVG_SQR_DIFF >
	  		)
			[
				aggregationParameterCaplValues[0] = averageParameterExpression(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, aggregationToken, evaluate)
				{
					if (evaluate)
						if (aggregationParameterCaplValues[0] == null)
							return null;
				}
			]
		)
		|
		aggregationToken = < HISTO >
	  	< LEFT_PARENTHESIS >
	  		aggregationParameterCaplValues[0] = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate) // Start of first bucket.
	  		< COMMA >
	  		aggregationParameterCaplValues[1] = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate) // Number of buckets.
	  		< COMMA >
	  		aggregationParameterCaplValues[2] = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate) // Bucket width (= size).
	  	< RIGHT_PARENTHESIS >
	  	{
	  	  	if (evaluate)
	  	  	{
	  	  	  	for (index = 0; index < 3; index++)
	  	  			if (aggregationParameterCaplValues[index] == null)
	  	  				return null;
		  	  		else if (aggregationParameterCaplValues[index].getValueDataType() != ValueDataType.NUMBER)
		  	  		{ 
						printOperandDataTypeError(new String[] { "NUMBER" }, aggregationParameterCaplValues[index], "HISTO");
						return null;
					}
				if (!isPositiveInteger(aggregationParameterCaplValues[1]))
				{
				  	printOperandDataTypeError(new String[] { "INTEGER >= 1" }, aggregationParameterCaplValues[1], "HISTO");
					return null;
				}
				if (aggregationParameterCaplValues[2].getNumberValue() <= 0d)
				{
				  	printOperandDataTypeError(new String[] { "NUMBER > 0" }, aggregationParameterCaplValues[2], "HISTO");
					return null;
				}
			}
	  	}
	)
  	{
  	  	if (evaluate)
			return getAggregationValue(referencedCaplValue, aggregationToken, aggregationParameterCaplValues);
		return EMPTY_CAPL_VALUE;
  	}
 	|
 	(  		aggregationToken = < COUNT >
		|
		aggregationToken = < COUNT_KEYS >
		|
		aggregationToken = < COUNT_VALUES >
	)
	[
		caseInsensitiveMatch = < CASE_INSENSITIVE_MATCH >
	]
  	[
  		< LEFT_PARENTHESIS >
  			aggregationParameterCaplValues[0] = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
  		< RIGHT_PARENTHESIS >
  	]
  	{
  	  	if (evaluate)
  	  	{
  	  	  	if (aggregationParameterCaplValues[0] == null || aggregationParameterCaplValues[0].getValueDataType() == ValueDataType.NUMBER ||
  	  	  		aggregationParameterCaplValues[0].getValueDataType() == ValueDataType.STRING ||
  	  	  		aggregationParameterCaplValues[0].getValueDataType() == ValueDataType.BOOLEAN)
				return count(referencedCaplValue, aggregationToken, aggregationParameterCaplValues[0], caseInsensitiveMatch != null);
			printOperandDataTypeError(new String[] { "NUMBER", "STRING", "BOOLEAN" }, aggregationParameterCaplValues[0], "COUNT_XYZ");
			return null;
		}
		return EMPTY_CAPL_VALUE;
  	}
}

private CaplValue collectionManipulation(CaplValue referencedCaplValue, Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Mutability mutability,
										 Set<String> referencedIdentifiers, boolean evaluate):
{
	CaplValue collectionKeyCaplValue = null,
			  collectionElementCaplValue = null;
}
{
  	(		< ADD > < LEFT_PARENTHESIS >
	  	collectionKeyCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
	  	[ < COLON > collectionElementCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate) ]
	  	{
	  	  	if (evaluate)
	  	  	{ 
		  		if (!addCollectionValue(referencedCaplValue, collectionKeyCaplValue, collectionElementCaplValue, false))
		  			return null;
		  		collectionElementCaplValue = null;
		  	}
	  	}
	  	(
	  	  	< COMMA > collectionKeyCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
	  	  	[ < COLON > collectionElementCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate) ]
		  	{
		  	  	if (evaluate)
		  	  	{ 
			  		if (!addCollectionValue(referencedCaplValue, collectionKeyCaplValue, collectionElementCaplValue, false))
			  			return null;
			  		collectionElementCaplValue = null;
			  	}
		  	} 
		)*
	  	< RIGHT_PARENTHESIS >
	 	|
	 	< REMOVE > < LEFT_PARENTHESIS >
	  	[
		  	collectionKeyCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
			{
			    if (evaluate && !removeCollectionValue(referencedCaplValue, collectionKeyCaplValue))
			    	return null;
			}
			(
				< COMMA > collectionKeyCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
				{
				    if (evaluate && !removeCollectionValue(referencedCaplValue, collectionKeyCaplValue))
				    	return null;
				}
			)*
		]
		< RIGHT_PARENTHESIS >
	  	{
	    	if (evaluate && collectionKeyCaplValue == null && !removeCollectionValue(referencedCaplValue, new CaplValue(ALL_COLLECTION_VALUES_KEY)))
			    return null;
	  	}
	 	|
	 	< REMOVE_LAST >
	  	{
	    	if (evaluate && !removeCollectionValue(referencedCaplValue, new CaplValue(Double.NaN)))
	    		return null;
	  	}
	 	|
	 	< REMOVE_ALL >
	 	{
	 	  	if (evaluate && !removeCollectionValues(referencedCaplValue))
	    		return null;
	 	} 
	)
	{
		return referencedCaplValue;
	}
}

private CaplValue collectionInitializer(Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Mutability mutability,
										Set<String> referencedIdentifiers, boolean evaluate):
{
  	Token dataStructure;
  	
	CaplValue referencedCaplValue,
			  collectionKeyCaplValue = null,
			  collectionElementCaplValue = null,
		  	  capacityCaplValue = null,
		  	  timeWindowLengthCaplValue = null;

	boolean hasCapacityValue = false;
}
{
  	(
		(		  	dataStructure = < SET > | dataStructure = < LIST >
		)
		(			< LEFT_BRACKET > [ capacityCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate) { hasCapacityValue = true; } ] < RIGHT_BRACKET >
			|
			< LEFT_BRACE >
				timeWindowLengthCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
				{
				  	if (mutability == Mutability.CONSTANT)
				  	{
				  	  	printMessage("Time-windowed data structures are not permitted as constants", Level.ERROR);
				  	  	return null;
				  	}
				  	hasCapacityValue = true;
				}
			< RIGHT_BRACE >
		)
		{
		  	if (evaluate)
		  	{
		  	  	if (hasCapacityValue && capacityCaplValue == null && timeWindowLengthCaplValue == null)
		  	  		return null;
		  	  		 
			  	if (capacityCaplValue == null)
			  		if (timeWindowLengthCaplValue == null)
				  		if (dataStructure.kind == CaplInterpreterConstants.SET)
				  	  		referencedCaplValue = CaplCollection.getSet();
					 	else referencedCaplValue = CaplCollection.getList();
					else if (isPositiveInteger(timeWindowLengthCaplValue))
						 	if (dataStructure.kind == CaplInterpreterConstants.SET)
					  	  		referencedCaplValue = CaplCollection.getSet(stateCaplValues.get("*now*"), new CaplValue(timeWindowLengthCaplValue.getNumberValue() * 60000d));
						 	else referencedCaplValue = CaplCollection.getList(stateCaplValues.get("*now*"), new CaplValue(timeWindowLengthCaplValue.getNumberValue() * 60000d));
						else
						{
						  	printOperandDataTypeError(new String[] { "INTEGER >= 1" }, timeWindowLengthCaplValue, "SET/LIST[<TIME_WINDOW_LENGTH>]");
						  	return null;
						}
			  	else if (isPositiveInteger(capacityCaplValue))
			  	  		if (dataStructure.kind == CaplInterpreterConstants.SET)
				  	  		referencedCaplValue = CaplCollection.getSet(capacityCaplValue);
				  		else referencedCaplValue = CaplCollection.getList(capacityCaplValue);
				  	else
				  	{
				  	  	printOperandDataTypeError(new String[] { "INTEGER >= 1" }, capacityCaplValue, "SET/LIST[<CAPACITY>]");
				  	  	return null;
				  	}
			}
			else referencedCaplValue = EMPTY_CAPL_VALUE;
		}
		[
			< LEFT_PARENTHESIS >
		  	collectionElementCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
		  	{
		  	  	if (evaluate && !addCollectionValue(referencedCaplValue, collectionElementCaplValue, null, true))
		  	  		return null;
		  	}
		  	(
		  	  	< COMMA > collectionElementCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
		  		{
		  	  		if (evaluate && !addCollectionValue(referencedCaplValue, collectionElementCaplValue, null, true))
		  	  			return null;
		  		}
		  	)*
	  		< RIGHT_PARENTHESIS >
	  	]
		|
		< MAP >
		(			< LEFT_BRACKET > [ capacityCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate) { hasCapacityValue = true; } ] < RIGHT_BRACKET >
			| 
			< LEFT_BRACE >
				timeWindowLengthCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
				{
				  	if (mutability == Mutability.CONSTANT)
				  	{
				  	  	printMessage("Time-windowed data structures are not permitted as constants", Level.ERROR);
				  	  	return null;
				  	}
				  	hasCapacityValue = true;
				}
			< RIGHT_BRACE >
		)
		{
		  	if (evaluate)
		  	{
		  	  	if (hasCapacityValue && capacityCaplValue == null && timeWindowLengthCaplValue == null)
		  	  		return null;
		  	  		 
			  	if (capacityCaplValue == null)
			  		if (timeWindowLengthCaplValue == null)
			  			referencedCaplValue = CaplCollection.getMap();
			  		else if (isPositiveInteger(timeWindowLengthCaplValue))
			  			referencedCaplValue = CaplCollection.getMap(stateCaplValues.get("*now*"), new CaplValue(timeWindowLengthCaplValue.getNumberValue() * 60000d));
			  		else
			  		{
			  		  	printOperandDataTypeError(new String[] { "INTEGER >= 1" }, timeWindowLengthCaplValue, "MAP[<TIME_WINDOW_LENGTH>]");
						return null;
			  		}
			  	else if (isPositiveInteger(capacityCaplValue))
			  	  		referencedCaplValue = CaplCollection.getMap(capacityCaplValue);
				  	else
				  	{
				  	  	printOperandDataTypeError(new String[] { "INTEGER >= 1" }, timeWindowLengthCaplValue, "MAP[<CAPACITY>]");
						return null;
				  	}
			}
			else referencedCaplValue = EMPTY_CAPL_VALUE;
		}
		[
			< LEFT_PARENTHESIS >
		  	collectionKeyCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
		  	[ < COLON > collectionElementCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate) ]
		  	{
		  	  	if (evaluate)
		  	  	{ 
		  	  		if (!addCollectionValue(referencedCaplValue, collectionKeyCaplValue, collectionElementCaplValue, true))
		  	  			return null;
		  	  		collectionElementCaplValue = null;
		  	  	}
		  	}
		  	(
		  	  	< COMMA > collectionKeyCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
			  	[ < COLON > collectionElementCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate) ]
			  	{
			  	  	if (evaluate)
			  	  	{ 
			  	  		if (!addCollectionValue(referencedCaplValue, collectionKeyCaplValue, collectionElementCaplValue, true))
			  	  			return null;
			  	  		collectionElementCaplValue = null;
					}
			  	}
		  	)*
	  		< RIGHT_PARENTHESIS >
		]
	 )
	 {	return referencedCaplValue; }
}

private CaplValue collectionValueContains(CaplValue referencedCaplValue, Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Mutability mutability,
										  Set<String> referencedIdentifiers, boolean evaluate):
{
  	Token containsOperator,
  		  caseInsensitiveMatch = null;
  	
	CaplValue findExpressionCaplValue = null,
			  resultCaplValue = null;
}
{
	(		containsOperator = < CONTAINS_SOME >
		|
		containsOperator = < CONTAINS >
		|
		containsOperator = < CONTAINS_SOME_KEYS >
		|
		containsOperator = < CONTAINS_KEYS >
		|
 		containsOperator = < CONTAINS_SOME_VALUES >
 		|
 		containsOperator = < CONTAINS_VALUES >
 	)
 	[
 		caseInsensitiveMatch = < CASE_INSENSITIVE_MATCH >
 	]
	< LEFT_PARENTHESIS >
	findExpressionCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
	{
	  	if (evaluate)
	  	{
	  	  	if (containsOperator.kind == CaplInterpreterConstants.CONTAINS_SOME)
	  			resultCaplValue = valueContains(referencedCaplValue, findExpressionCaplValue, caseInsensitiveMatch != null, true);
	  		else if (containsOperator.kind == CaplInterpreterConstants.CONTAINS)
	  			resultCaplValue = valueContains(referencedCaplValue, findExpressionCaplValue, caseInsensitiveMatch != null, false);
	  		else if (containsOperator.kind == CaplInterpreterConstants.CONTAINS_SOME_KEYS)
	  			resultCaplValue = containsKeys(referencedCaplValue, findExpressionCaplValue, caseInsensitiveMatch != null, true);
	  		else if (containsOperator.kind == CaplInterpreterConstants.CONTAINS_KEYS)
	  			resultCaplValue = containsKeys(referencedCaplValue, findExpressionCaplValue, caseInsensitiveMatch != null, false);
	  		else if (containsOperator.kind == CaplInterpreterConstants.CONTAINS_SOME_VALUES)
	  			resultCaplValue = containsValues(referencedCaplValue, findExpressionCaplValue, caseInsensitiveMatch != null, true);
	  		else resultCaplValue = containsValues(referencedCaplValue, findExpressionCaplValue, caseInsensitiveMatch != null, false);
	  		if (resultCaplValue == null)
	  			return null;
	  	}
	  	else resultCaplValue = EMPTY_CAPL_VALUE;
	}
	(
	  	< COMMA > findExpressionCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers,
	  														 evaluate && resultCaplValue.getBooleanValue())
		{
		  	if (evaluate && resultCaplValue.getBooleanValue())
		  	{ 
		  		if (containsOperator.kind == CaplInterpreterConstants.CONTAINS_SOME)
		  			resultCaplValue = valueContains(referencedCaplValue, findExpressionCaplValue, caseInsensitiveMatch != null, true);
		  		else if (containsOperator.kind == CaplInterpreterConstants.CONTAINS)
		  			resultCaplValue = valueContains(referencedCaplValue, findExpressionCaplValue, caseInsensitiveMatch != null, false);
		  		else if (containsOperator.kind == CaplInterpreterConstants.CONTAINS_SOME_KEYS)
		  			resultCaplValue = containsKeys(referencedCaplValue, findExpressionCaplValue, caseInsensitiveMatch != null, true);
		  		else if (containsOperator.kind == CaplInterpreterConstants.CONTAINS_KEYS)
		  			resultCaplValue = containsKeys(referencedCaplValue, findExpressionCaplValue, caseInsensitiveMatch != null, false);
		  		else if (containsOperator.kind == CaplInterpreterConstants.CONTAINS_SOME_VALUES)
		  			resultCaplValue = containsValues(referencedCaplValue, findExpressionCaplValue, caseInsensitiveMatch != null, true);
		  		else resultCaplValue = containsValues(referencedCaplValue, findExpressionCaplValue, caseInsensitiveMatch != null, false);
			  	if (resultCaplValue == null)
	  				return null;
	  		}
		}	 
	)*
  	< RIGHT_PARENTHESIS >
  	{
  	  	return resultCaplValue;
  	}
}

private CaplValue topOrBottom(CaplValue referencedCaplValue, Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Mutability mutability,
							  Set<String> referencedIdentifiers, boolean evaluate):
{
  	Token operatorToken,
  		  unitToken,
  		  caseInsensitiveMatch = null;
  	
	CaplValue numberCaplValue = null,
			  findExpressionCaplValue = null;
}
{
	( operatorToken = < TOP > | operatorToken = < BOTTOM > )
	[
 		caseInsensitiveMatch = < CASE_INSENSITIVE_MATCH >
 	]
	< LEFT_PARENTHESIS >
	numberCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
	< COMMA >
	(
	  	unitToken = < NUM >
	  	|
	  	unitToken = < PCT >
	)
	[
		< COMMA > findExpressionCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
	]
	< RIGHT_PARENTHESIS >
	{ 
		if (evaluate)
	  	  	switch (referencedCaplValue.getValueDataType())
	  	  	{
	  	  	  	case STRING: if (findExpressionCaplValue == null)
						  	 {
						  	  	printMessage("TOP / BOTTOM for a string must specify a third parameter (regular expression) that allows a meaningful TOP / BOTTOM quantitative analysis of substrings in the given string");
						  	  	return null;
						  	 }
							 return rankCollection(referencedCaplValue.getStringValue(), operatorToken, numberCaplValue, unitToken, findExpressionCaplValue, caseInsensitiveMatch != null);
	  	  	  	case SET: return rankCollection(referencedCaplValue.getSetValue(), operatorToken, numberCaplValue, unitToken, findExpressionCaplValue, caseInsensitiveMatch != null);
	  	  	  	case MAP: return rankCollection(referencedCaplValue.getMapValue().values(), operatorToken, numberCaplValue, unitToken, findExpressionCaplValue, caseInsensitiveMatch != null);
				case LIST: return rankCollection(referencedCaplValue.getListValue(), operatorToken, numberCaplValue, unitToken, findExpressionCaplValue, caseInsensitiveMatch != null);
				default: printOperandDataTypeError(new String[] { "SET", "MAP", "LIST", "STRING" }, referencedCaplValue, "TOP / BOTTOM");
						 return null;
	  		}
	  	else return EMPTY_CAPL_VALUE;
	}
}

private CaplValue indexOf(CaplValue referencedCaplValue, Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Mutability mutability,
						  Set<String> referencedIdentifiers, boolean evaluate):
{
  	Token indexToken = null;

	CaplValue collectionElementCaplValue = null;
}
{
	(	  	indexToken = < FIRST_INDEX >
	 	|
	 	indexToken = < LAST_INDEX >
	)
	< LEFT_PARENTHESIS >
	collectionElementCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
  	< RIGHT_PARENTHESIS >
  	{
  	  	if (evaluate)
	  		return getListIndex(referencedCaplValue, indexToken, collectionElementCaplValue);
	  	return EMPTY_CAPL_VALUE;
	}
}

private CaplValue collectionElement(CaplValue referencedCaplValue, Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Mutability mutability,
								  	Set<String> referencedIdentifiers, boolean evaluate):
{
	CaplValue collectionPathCaplValue = null;

	CaplValue listCaplValue,
			  collectionElementCaplValue;

	List<CaplValue> listCaplValues;

	String key;

	if (evaluate)
		if (referencedCaplValue == null)
		{
			printMessage("Referenced collection element does not exist");
			return null;
		}
		else if (!referencedCaplValue.hasCollectionValueDataType())
		{
			printOperandDataTypeError(new String[] { "SET, MAP, LIST" }, referencedCaplValue, "COLLECTION ACCESSOR");
			return null;
		}
}
{
  	(	  	< LEFT_BRACKET > collectionPathCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate) < RIGHT_BRACKET >
	  	{
	  	  	if (evaluate)
	  	  		if (collectionPathCaplValue == null)
	  	  			return null;
	  	  		else if (collectionPathCaplValue.getValueDataType() == ValueDataType.STRING)
	  	  		{
	  	  		  	key = collectionPathCaplValue.getStringValue();
	  	  			if (referencedCaplValue.getValueDataType() == ValueDataType.MAP)
					  	if (key.startsWith(">"))
					  	{
					  	  	key = key.substring(1).trim();
					  	  	if (referencedCaplValue.getCapacity() < Integer.MAX_VALUE)
					  			listCaplValue = CaplCollection.getList(referencedCaplValue.getCapacity());
					  		else listCaplValue = CaplCollection.getList();

					  		listCaplValues = listCaplValue.getListValue();
					  		for (CaplValue oneMapValue: referencedCaplValue.getMapValue().values())
						  	  	if (oneMapValue.getValueDataType() == ValueDataType.MAP)
						  	  	{
						  	  	  	collectionElementCaplValue = oneMapValue.getMapValue().get(key);
						  			if (collectionElementCaplValue != null &&
						  				collectionElementCaplValue.getValueDataType() != ValueDataType.SET &&
						  				collectionElementCaplValue.getValueDataType() != ValueDataType.LIST) 
						  				listCaplValues.add(collectionElementCaplValue);
						  		}
					  		referencedCaplValue = listCaplValue;
					  	}
					  	else
					  	{ 
							referencedCaplValue = referencedCaplValue.getMapValue().get(key);
							if (referencedCaplValue == null)
								return null;
						}
					else if (referencedCaplValue.getValueDataType() == ValueDataType.LIST)
					{
					  	if (referencedCaplValue.getCapacity() < Integer.MAX_VALUE)
					  		listCaplValue = CaplCollection.getList(referencedCaplValue.getCapacity());
					  	else listCaplValue = CaplCollection.getList();
					  	listCaplValues = listCaplValue.getListValue();
					  	for (CaplValue oneListElement: referencedCaplValue.getListValue())
					  	  	if (oneListElement.getValueDataType() == ValueDataType.MAP)
					  	  	{
					  	  	  	collectionElementCaplValue = oneListElement.getMapValue().get(key);
					  			if (collectionElementCaplValue != null) 
					  				listCaplValues.add(collectionElementCaplValue);
					  		}
					  	referencedCaplValue = listCaplValue;
					}
					else
		  	  	  	{
		  	  	  	  	printOperandDataTypeError(new String[] { "MAP", "LIST" }, referencedCaplValue, "STRING COLLECTION ACCESSOR");
		  	  	  	  	return null;
		  	  	  	}
		  	  	}
		  	  	else if (collectionPathCaplValue.getValueDataType() == ValueDataType.NUMBER)
		  	  		if (referencedCaplValue.getValueDataType() == ValueDataType.LIST)
		  	  		{
			  	  	  	listCaplValues = referencedCaplValue.getListValue();
						if (collectionPathCaplValue.getNumberValue() < 0d || collectionPathCaplValue.getNumberValue() >= listCaplValues.size())
			  	  	  	  	return null;
						referencedCaplValue = listCaplValues.get((int) collectionPathCaplValue.getNumberValue());
		  	  	 	}
		  	  	 	else
		  	  	  	{
		  	  	  	  	printOperandDataTypeError(new String[] { "LIST" }, referencedCaplValue, "NUMBER COLLECTION ACCESSOR");
		  	  	  	  	return null;
		  	  	  	}
		  	  	else
		  	  	{
		  	  	  	printOperandDataTypeError(new String[] { "NUMBER", "STRING" }, collectionPathCaplValue, "COLLECTION ACCESSOR");
				  	return null;
				}
			else referencedCaplValue = EMPTY_CAPL_VALUE;
		}
	)+
	{
		return referencedCaplValue;
	}
}

private CaplValue castFromValue(CaplValue referencedCaplValue, Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Mutability mutability, Set<String> referencedIdentifiers, boolean evaluate):
{
	CaplValue datePatternCaplValue = null,
			  timeWindowLengthCaplValue = null,
			  firstTimestampCaplValue = null,
			  timeCaplValue;

	String booleanValue;

	if (referencedCaplValue == null)
		return null;
}
{
  	< DATE_TO_NUMBER > < LEFT_PARENTHESIS > datePatternCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate) < RIGHT_PARENTHESIS >
	{
		if (evaluate)
  	  	  	return parseDate(referencedCaplValue, datePatternCaplValue);
  	  	return EMPTY_CAPL_VALUE;
	}
	|
	< DATE_TO_TIME_WINDOW >
		< LEFT_PARENTHESIS >
		datePatternCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
		< COMMA >
		firstTimestampCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
		< COMMA >
		timeWindowLengthCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
		< RIGHT_PARENTHESIS >
	{
		if (evaluate)
		{
			if (firstTimestampCaplValue == null || timeWindowLengthCaplValue == null)
				return null;
			if (firstTimestampCaplValue.getValueDataType() == ValueDataType.NUMBER && timeWindowLengthCaplValue.getValueDataType() == ValueDataType.NUMBER)
			{ 
  	  	  		timeCaplValue = parseDate(referencedCaplValue, datePatternCaplValue);
  	  	  		if (timeCaplValue == null)
  	  	  			return null;
  	  	  		return new CaplValue(Math.floor((timeCaplValue.getNumberValue() - firstTimestampCaplValue.getNumberValue()) / timeWindowLengthCaplValue.getNumberValue()));
  	  	  	}
  	  	  	printOperandDataTypeError(new String[] { "NUMBER" }, timeWindowLengthCaplValue, firstTimestampCaplValue, "DATE_TO_TIME_WINDOW");
	  	  	return null;
  	  	}
  	  	return EMPTY_CAPL_VALUE;
	}
	| 
	< STRING_TO_NUMBER >
	{
		if (evaluate)
  	  	{
  	  	  	if (referencedCaplValue.getValueDataType() == ValueDataType.STRING)
	  	  	  	try
	  	  	  	{
	  	  	  	  	return new CaplValue(Double.parseDouble(referencedCaplValue.getStringValue()));
	  	  	  	} catch (NumberFormatException e)
	  	  	  	{
	  	  	  	  	printOperandDataTypeError(new String[] { "NUMBER AS STRING" }, referencedCaplValue, "STRING_TO_NUMBER");
	  	  	  	  	return null;
	  	  	  	}
	  	  	printOperandDataTypeError(new String[] { "STRING" }, referencedCaplValue, "STRING_TO_NUMBER");
	  	  	return null;
		}
  	  	return EMPTY_CAPL_VALUE;
	}
	|
	< STRING_TO_BOOLEAN >
	{
		if (evaluate)
  	  	{
  	  	  	if (referencedCaplValue.getValueDataType() == ValueDataType.STRING)
  	  	  	{ 
	  	  	  	booleanValue = referencedCaplValue.getStringValue().toLowerCase();
	  	  	  	if (booleanValue.equals("true"))
	  	  	  		return new CaplValue(true);
	  	  	  	else if (booleanValue.equals("false"))
	  	  	  		return new CaplValue(false);
	  	  	  	printOperandDataTypeError(new String[] { "BOOLEAN AS STRING" }, referencedCaplValue, "STRING_TO_BOOLEAN");
	  	  	  	return null;
	  	  	}
	  	  	printOperandDataTypeError(new String[] { "STRING" }, referencedCaplValue, "STRING_TO_BOOLEAN");
	  	  	return null;
		}
  	  	return EMPTY_CAPL_VALUE;
	}
	|
	< NUMBER_TO_STRING >
	{
		if (evaluate)
  	  	{
  	  	  	if (referencedCaplValue.getValueDataType() == ValueDataType.NUMBER)
	  	  	  	return new CaplValue("" + referencedCaplValue.getNumberValue());
	  	  	printOperandDataTypeError(new String[] { "NUMBER" }, referencedCaplValue, "NUMBER_TO_STRING");
	  	  	return null;
		}
  	  	return EMPTY_CAPL_VALUE;
  	 }
  	|
  	< NUMBER_TO_TIME_WINDOW >
		< LEFT_PARENTHESIS >
		firstTimestampCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
		< COMMA >
		timeWindowLengthCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
		< RIGHT_PARENTHESIS >
	{
		if (evaluate)
		{
			if (firstTimestampCaplValue == null || timeWindowLengthCaplValue == null)
				return null;
			if (referencedCaplValue.getValueDataType() == ValueDataType.STRING)
				try
				{
				  	referencedCaplValue = new CaplValue(Double.parseDouble(referencedCaplValue.getStringValue()));
				} catch (NumberFormatException e)
				{
				  	printOperandDataTypeError(new String[] { "NUMBER", "NUMBER AS STRING" }, referencedCaplValue, "NUMBER_TO_TIME_WINDOW");
				  	return null;
				}
			if (firstTimestampCaplValue.getValueDataType() == ValueDataType.NUMBER && timeWindowLengthCaplValue.getValueDataType() == ValueDataType.NUMBER)
  	  	  		return new CaplValue(Math.floor((referencedCaplValue.getNumberValue() - firstTimestampCaplValue.getNumberValue()) / timeWindowLengthCaplValue.getNumberValue()));
  	  	  	printOperandDataTypeError(new String[] { "NUMBER" }, firstTimestampCaplValue, timeWindowLengthCaplValue, "NUMBER_TO_TIME_WINDOW");
	  	  	return null;
  	  	}
  	  	return EMPTY_CAPL_VALUE;
	}
	|
	< NUMBER_TO_DATE >
		< LEFT_PARENTHESIS >
		datePatternCaplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
		< RIGHT_PARENTHESIS >
	{
	  	if (evaluate)
	  	  	return formatDate(referencedCaplValue, datePatternCaplValue);
  	  	return EMPTY_CAPL_VALUE;
	}	  
}

private CaplValue valueExpression(Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Mutability mutability, Set<String> referencedIdentifiers, boolean evaluate):
{
  	String identifier = null;
  	
	Token referencedToken = null;

	CaplValue referencedCaplValue;

	long now;
}
{
  	(		(	  		referencedToken = < NUM_EVENTS >
	  		{ 
	  			if (eventCaplValue == null)
 	  			{
 	  			  	printMessage(referencedToken, "Illegal attempt to access number of events at this point");
 	  			  	return null;
 	  			}
 	  		}
	  		|
	  		referencedToken = < NOW >
	  		| 
	  		referencedToken = < NUMBER >
	  		|
	  		referencedToken = < STRING >
	  		|
	  		referencedToken = < BOOLEAN >
	  	)
	  	{
	  	  	if (evaluate)
	  	  		return getValue(referencedToken, stateCaplValues);
	  	  	return EMPTY_CAPL_VALUE;
	  	}
	)
	|
	(
	  	referencedToken = < IDENTIFIER >
	  	{
	  	  	if (referencedIdentifiers != null)
	  	  	{
	  	  	  	identifier = referencedToken.toString(); 
		    	referencedIdentifiers.add(identifier);
		    }
	  	  	if (evaluate)
	  	  	{
	  	  	  	if (referencedIdentifiers == null) 
		  	  		identifier = referencedToken.toString();
		    	referencedCaplValue = stateCaplValues.get(identifier);
		  	   	if (referencedCaplValue == null)
		  	   	{
		  	   	   	printMessage(referencedToken, "Identififer has not been declared previously");
		  	   	   	return null;
		  	   	}
		  	   	if (referencedCaplValue.getTimeWindowStart() > 0L)
		  	   	{
		  	   	  	now = (long) stateCaplValues.get("*now*").getNumberValue();
		  	   	  	if (now - referencedCaplValue.getTimeWindowStart() > referencedCaplValue.getTimeWindowLength())
		  	   	  	{
		  	   	  	  	if (referencedCaplValue.getValueDataType() == ValueDataType.SET)
		  	   	  	  		referencedCaplValue.getSetValue().clear();
		  	   	  	  	else if(referencedCaplValue.getValueDataType() == ValueDataType.MAP)
		  	   	  	  		referencedCaplValue.getMapValue().clear();
		  	   	  	  	else referencedCaplValue.getListValue().clear();
		  	   	  	  	referencedCaplValue.setTimeWindowStart(now);
		  	   	  	}
		  	   	}
		  	}
		  	else referencedCaplValue = EMPTY_CAPL_VALUE;
	  	}
	 	|
	 	< EVENT >
	 	{
 	  		if (evaluate)
 	  			if (eventCaplValue == null)
 	  			{
 	  			  	printMessage(referencedToken, "Illegal attempt to access event - event may not be accessed at this point");
 	  			  	return null;
 	  			}
				else referencedCaplValue = eventCaplValue;
			else referencedCaplValue = EMPTY_CAPL_VALUE;
	 	}
	 	|
	 	referencedCaplValue = webServiceContent(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
	 	{
			if (evaluate)
			{ 
 	  			if (referencedCaplValue == null)
 	  			{
 	  			  	printMessage("Unable to retrieve value from Web service");
 	  			  	return null;
 	  			}
			}
			else referencedCaplValue = EMPTY_CAPL_VALUE;
	 	}
	)
	{
		return referencedCaplValue;
	}
}

private CaplValue valueExpression1(Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Mutability mutability, Set<String> referencedIdentifiers, boolean evaluate):
{
  	CaplValue expressionResult = null,
  		      nextExpressionResult;
}
{
	expressionResult = valueExpression2(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
	{
	  	if (expressionResult == null)
	  		return null;
	  	evaluate =  evaluate && (expressionResult.getValueDataType() != ValueDataType.BOOLEAN || !expressionResult.getBooleanValue());
	}
	(
	  	< OR >
	  	{
		  	if (expressionResult.getValueDataType() != ValueDataType.BOOLEAN)
		  	{
		  	  	printOperandDataTypeError(new String[] { "BOOLEAN" }, expressionResult, expressionResult, "OR");
		  	  	return null;
		  	}
	  	}
	  	nextExpressionResult = valueExpression2(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
	  	{
	  	  	if (evaluate)
	  	  	{ 
		  		if (nextExpressionResult == null)
					return null;
				if (expressionResult.getValueDataType() != nextExpressionResult.getValueDataType())
				{
		  			printOperandDataTypeError(new String[] { "BOOLEAN" }, nextExpressionResult, nextExpressionResult, "OR");
		  			return null;
				}
				expressionResult = new CaplValue(expressionResult.getBooleanValue() || nextExpressionResult.getBooleanValue());
				evaluate = !nextExpressionResult.getBooleanValue();
			}
	  	}
	)*
	{ return expressionResult; }
}

private CaplValue valueExpression2(Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Mutability mutability, Set<String> referencedIdentifiers, boolean evaluate):
{
  	CaplValue expressionResult = null,
  		      nextExpressionResult;
}
{
	expressionResult = valueExpression3(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
	{
	  	if (expressionResult == null)
	  		return null;
	  	evaluate = evaluate && (expressionResult.getValueDataType() != ValueDataType.BOOLEAN || expressionResult.getBooleanValue());
	}
	(
	  	< AND > nextExpressionResult = valueExpression3(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
		{
		  	if (evaluate)
		  	{ 
				if (nextExpressionResult == null)
					return null;
				if (expressionResult.getValueDataType() != nextExpressionResult.getValueDataType() || expressionResult.getValueDataType() != ValueDataType.BOOLEAN)
				{
				  	printOperandDataTypeError(new String[] { "BOOLEAN" }, expressionResult, nextExpressionResult, "AND");
			  		return null;
				}
				expressionResult = new CaplValue(expressionResult.getBooleanValue() && nextExpressionResult.getBooleanValue());
				evaluate = nextExpressionResult.getBooleanValue();
			}
		}
	)*
	{ return expressionResult; }
}

private CaplValue valueExpression3(Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Mutability mutability, Set<String> referencedIdentifiers, boolean evaluate):
{
  	CaplValue expressionResult = null,
  		      nextExpressionResult;

  	Token operator,
  		  modifier = null;
}
{
	expressionResult = valueExpression4(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
	{
	  	if (expressionResult == null)
	  		return null;
	}
	(
	  	(
	  	  	operator = < EQUALS > [ modifier = < CASE_INSENSITIVE_MATCH > ] | operator = < NOT_EQUALS > | operator = < GREATER > | operator = < LESS >
	  	)
		nextExpressionResult = valueExpression4(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
		{
		  	if (evaluate)
		  	{ 
			  	if (nextExpressionResult == null)
					return null;
				if (expressionResult.getValueDataType() != nextExpressionResult.getValueDataType())
				{
			  		printMessage("Incompatible data types of operands for " + getTokenString(operator) + " operation");
			  		return null;
				}
				switch (operator.kind)
				{
				  	case EQUALS: if (expressionResult.getValueDataType() == ValueDataType.NUMBER)
									expressionResult = new CaplValue(Math.abs(expressionResult.getNumberValue() - nextExpressionResult.getNumberValue()) < EPSILON); 
							  	 else if (expressionResult.getValueDataType() == ValueDataType.STRING)
							  	 	if (modifier == null)
							  			expressionResult = new CaplValue(expressionResult.getStringValue().equals(nextExpressionResult.getStringValue()));
							  		else expressionResult = new CaplValue(expressionResult.getStringValue().equalsIgnoreCase(nextExpressionResult.getStringValue()));
							  	 else  if (expressionResult.getValueDataType() == ValueDataType.BOOLEAN)
							  		expressionResult = new CaplValue(expressionResult.getBooleanValue() == nextExpressionResult.getBooleanValue());
							  	 else if (expressionResult.getValueDataType() == ValueDataType.SET)
							  	 	expressionResult = new CaplValue(expressionResult.getSetValue().equals(nextExpressionResult.getSetValue()));
							  	 else if (expressionResult.getValueDataType() == ValueDataType.MAP)
							  	 	expressionResult = new CaplValue(expressionResult.getMapValue().equals(nextExpressionResult.getMapValue()));
							  	 else expressionResult = new CaplValue(expressionResult.getListValue().equals(nextExpressionResult.getListValue()));
							  	 break;
					case NOT_EQUALS: if (expressionResult.getValueDataType() == ValueDataType.NUMBER)
										expressionResult = new CaplValue(Math.abs(expressionResult.getNumberValue() - nextExpressionResult.getNumberValue()) > EPSILON);
									 else if (expressionResult.getValueDataType() == ValueDataType.STRING)
									 	if (modifier == null)
									  		expressionResult = new CaplValue(!expressionResult.getStringValue().equals(nextExpressionResult.getStringValue()));
									  	else expressionResult = new CaplValue(!expressionResult.getStringValue().equalsIgnoreCase(nextExpressionResult.getStringValue()));
									 else  if (expressionResult.getValueDataType() == ValueDataType.BOOLEAN)
									  	expressionResult = new CaplValue(expressionResult.getBooleanValue() != nextExpressionResult.getBooleanValue());
								 	 else if (expressionResult.getValueDataType() == ValueDataType.SET)
								  	 	expressionResult = new CaplValue(!expressionResult.getSetValue().equals(nextExpressionResult.getSetValue()));
								  	 else if (expressionResult.getValueDataType() == ValueDataType.MAP)
								  	 	expressionResult = new CaplValue(!expressionResult.getMapValue().equals(nextExpressionResult.getMapValue()));
								  	 else expressionResult = new CaplValue(!expressionResult.getListValue().equals(nextExpressionResult.getListValue()));
								 	 break;
					case GREATER: if (expressionResult.getValueDataType() == ValueDataType.NUMBER)
									expressionResult = new CaplValue(expressionResult.getNumberValue() > nextExpressionResult.getNumberValue() + EPSILON);
							  	  else
							  	  {
								  	printOperandDataTypeError(new String[] { "NUMBER" }, expressionResult, operator);
								  	return null;
								  } 
							  	  break;
					default: if (expressionResult.getValueDataType() == ValueDataType.NUMBER)
								expressionResult = new CaplValue(expressionResult.getNumberValue() < nextExpressionResult.getNumberValue() - EPSILON);
							 else
							 {
							  	printOperandDataTypeError(new String[] { "NUMBER" }, expressionResult, operator);
							  	return null;
							 }
				}
			}
			else expressionResult = new CaplValue(false);
		}
	)*
	{ return expressionResult; }
}

private CaplValue valueExpression4(Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Mutability mutability, Set<String> referencedIdentifiers, boolean evaluate):
{
  	CaplValue expressionResult = null,
  		      nextExpressionResult;

  	Token operator;
}
{
	expressionResult = valueExpression5(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
	{
	  	if (expressionResult == null)
	  		return null;
	}
	(
	  	(
	  	  	operator = < PLUS > | operator = < MINUS >
	  	)
		nextExpressionResult = valueExpression5(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
		{
		  	if (evaluate)
		  	{ 
			  	if (nextExpressionResult == null)
					return null;
				if (operator.kind == CaplInterpreterConstants.PLUS)
				{ 
	  				if (expressionResult.getValueDataType() == ValueDataType.NUMBER && nextExpressionResult.getValueDataType() == ValueDataType.NUMBER)
				   		expressionResult = new CaplValue(expressionResult.getNumberValue() + nextExpressionResult.getNumberValue());
				   	else if (expressionResult.getValueDataType() == ValueDataType.STRING && nextExpressionResult.getValueDataType() == ValueDataType.STRING)
				   		expressionResult = new CaplValue(expressionResult.getStringValue() + nextExpressionResult.getStringValue());
				   	else if (expressionResult.getValueDataType() == ValueDataType.NUMBER && nextExpressionResult.getValueDataType() == ValueDataType.STRING)
				   		expressionResult = new CaplValue(expressionResult.getNumberValue() + nextExpressionResult.getStringValue());
				   	else if (expressionResult.getValueDataType() == ValueDataType.STRING && nextExpressionResult.getValueDataType() == ValueDataType.NUMBER)
				   		expressionResult = new CaplValue(expressionResult.getStringValue() + nextExpressionResult.getNumberValue());
				   	else if (expressionResult.getValueDataType() == ValueDataType.SET && nextExpressionResult.getValueDataType() == ValueDataType.SET)
				   		expressionResult = CaplCollection.getCombinedSet(expressionResult, nextExpressionResult);
				   	else if (expressionResult.getValueDataType() == ValueDataType.SET && nextExpressionResult.getValueDataType() == ValueDataType.NUMBER)
				   		expressionResult = operateOnSet(expressionResult, nextExpressionResult, operator);
				   	else if (expressionResult.getValueDataType() == ValueDataType.NUMBER && nextExpressionResult.getValueDataType() == ValueDataType.SET)
				   		expressionResult = operateOnSet(nextExpressionResult, expressionResult, operator);
				   	else if (expressionResult.getValueDataType() == ValueDataType.MAP && nextExpressionResult.getValueDataType() == ValueDataType.MAP)
				   		expressionResult = CaplCollection.getCombinedMap(expressionResult, nextExpressionResult);
				   	else if (expressionResult.getValueDataType() == ValueDataType.MAP && nextExpressionResult.getValueDataType() == ValueDataType.NUMBER)
				   		expressionResult = operateOnMap(expressionResult, nextExpressionResult, operator);
				   	else if (expressionResult.getValueDataType() == ValueDataType.NUMBER && nextExpressionResult.getValueDataType() == ValueDataType.MAP)
				   		expressionResult = operateOnMap(nextExpressionResult, expressionResult, operator);
				   	else if (expressionResult.getValueDataType() == ValueDataType.LIST && nextExpressionResult.getValueDataType() == ValueDataType.LIST)
				   		expressionResult = CaplCollection.getCombinedList(expressionResult, nextExpressionResult);
				   	else if (expressionResult.getValueDataType() == ValueDataType.LIST && nextExpressionResult.getValueDataType() == ValueDataType.NUMBER)
				   		expressionResult = operateOnList(expressionResult, nextExpressionResult, operator);
				   	else if (expressionResult.getValueDataType() == ValueDataType.NUMBER && nextExpressionResult.getValueDataType() == ValueDataType.LIST)
				   		expressionResult = operateOnList(nextExpressionResult, expressionResult, operator);
				  	else
				   	{
				     	printOperandDataTypeError(new String[] { "NUMBER", "STRING", "SET", "MAP", "LIST" }, expressionResult, operator);
				  		return null;
				   	}
  					if (expressionResult == null)
					{
					  	printOperandDataTypeIncompatibilityError("Either both operands must be time-windowed data structures or neither one is; if one is a time-windowed data structure, the time window start times and lengths must be equal", expressionResult, nextExpressionResult, operator);
					  	return null;
					}
				}
			   	else 
			   	{ 
			   		if (expressionResult.getValueDataType() == ValueDataType.NUMBER && nextExpressionResult.getValueDataType() == ValueDataType.NUMBER)
						expressionResult = new CaplValue(expressionResult.getNumberValue() - nextExpressionResult.getNumberValue());
				   	else if (expressionResult.getValueDataType() == ValueDataType.SET && nextExpressionResult.getValueDataType() == ValueDataType.SET)
				   		expressionResult = CaplCollection.getDifferenceSet(expressionResult, nextExpressionResult, false);
				   	else if (expressionResult.getValueDataType() == ValueDataType.SET && nextExpressionResult.getValueDataType() == ValueDataType.NUMBER)
				   		expressionResult = operateOnSet(expressionResult, nextExpressionResult, operator);
				   	else if (expressionResult.getValueDataType() == ValueDataType.MAP && nextExpressionResult.getValueDataType() == ValueDataType.NUMBER)
				   		expressionResult = operateOnMap(expressionResult, nextExpressionResult, operator);
				   	else if (expressionResult.getValueDataType() == ValueDataType.LIST && nextExpressionResult.getValueDataType() == ValueDataType.LIST)
					   	expressionResult = CaplCollection.getDifferenceList(expressionResult, nextExpressionResult, false);
					else if (expressionResult.getValueDataType() == ValueDataType.LIST && nextExpressionResult.getValueDataType() == ValueDataType.NUMBER)
				   		expressionResult = operateOnList(expressionResult, nextExpressionResult, operator);
				   	else
				   	{
				  		printOperandDataTypeError(new String[] { "NUMBER", 	"SET", "LIST" }, expressionResult, operator);
				  		return null;
				   	}
				   	if (expressionResult == null)
	  					printOperandDataTypeIncompatibilityError("Either both operands must be time-windowed data structures or neither one is; if one is a time-windowed data structure, the time window start times and lengths must be equal", expressionResult, nextExpressionResult, operator);
			   	}
			}
		}
	)*
	{
	  	return expressionResult;
	}
}

private CaplValue valueExpression5(Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Mutability mutability, Set<String> referencedIdentifiers, boolean evaluate):
{
  	CaplValue expressionResult = null,
  		      nextExpressionResult;

  	Token operator;
}
{
	expressionResult = valueExpression6(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
	{
	  	if (expressionResult == null)
	  		return null;
	}
	(
	  	(
	  	  	operator = < MULT > | operator = < DIV > | operator = < INT_DIV > | operator = < MODULO > | operator = < EXP >
	  	)
		nextExpressionResult = valueExpression6(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
		{
		  	if (evaluate)
		  	{ 
			  	if (nextExpressionResult == null)
					return null;

				if (expressionResult.getValueDataType() == nextExpressionResult.getValueDataType())
					if (expressionResult.getValueDataType() == ValueDataType.SET)
					  	if (operator.kind == CaplInterpreterConstants.DIV)
						  	expressionResult = CaplCollection.getDifferenceSet(expressionResult, nextExpressionResult, true);
					  	else
					  	{
					  	  	printMessage(operator, "< MULT >, < INT_DIV >, < MODULO >, and < EXP > operations not allowed on two SETs (< DIV > is allowed)");
					  	  	return null;
					  	}
					else if (expressionResult.getValueDataType() == ValueDataType.LIST)
						if (operator.kind == CaplInterpreterConstants.DIV)
						  	expressionResult = CaplCollection.getDifferenceList(expressionResult, nextExpressionResult, true);
					  	else
					  	{
					  	  	printMessage(operator, "< MULT >, < INT_DIV >, < MODULO >, and < EXP > operations not allowed on two SETs (< DIV > is allowed)");
					  	  	return null;
					  	}
					else if (expressionResult.getValueDataType() == ValueDataType.NUMBER)
					{
						if (operator.kind == CaplInterpreterConstants.MULT)
						   	expressionResult = new CaplValue(expressionResult.getNumberValue() * nextExpressionResult.getNumberValue());
						else if (operator.kind == CaplInterpreterConstants.EXP)
							expressionResult = new CaplValue(Math.pow(expressionResult.getNumberValue(), nextExpressionResult.getNumberValue()));
						else if (nextExpressionResult.getNumberValue() == 0d)
						{
						  	printMessage(operator, "Division by zero");
						  	return null;
						}	  
						else if (operator.kind == CaplInterpreterConstants.DIV)
							expressionResult = new CaplValue(expressionResult.getNumberValue() / nextExpressionResult.getNumberValue());
						else if (operator.kind == CaplInterpreterConstants.INT_DIV)
							expressionResult = new CaplValue(Math.floor(expressionResult.getNumberValue() / nextExpressionResult.getNumberValue()));
						else expressionResult = new CaplValue(expressionResult.getNumberValue() % nextExpressionResult.getNumberValue());
					}
					else
					{
					  	printOperandDataTypeError(new String[] { "NUMBER", 	"SET", "LIST" }, expressionResult, operator);
				  		return null;
					}
				else if (operator.kind == CaplInterpreterConstants.MULT)
					if (expressionResult.getValueDataType() == ValueDataType.SET && nextExpressionResult.getValueDataType() == ValueDataType.NUMBER)
						expressionResult = operateOnSet(expressionResult, nextExpressionResult, operator);
					else if (expressionResult.getValueDataType() == ValueDataType.NUMBER && nextExpressionResult.getValueDataType() == ValueDataType.SET)
						expressionResult = operateOnSet(nextExpressionResult, expressionResult, operator);
					else if (expressionResult.getValueDataType() == ValueDataType.MAP && nextExpressionResult.getValueDataType() == ValueDataType.NUMBER)
						expressionResult = operateOnMap(expressionResult, nextExpressionResult, operator);
					else if (expressionResult.getValueDataType() == ValueDataType.NUMBER && nextExpressionResult.getValueDataType() == ValueDataType.MAP)
						expressionResult = operateOnMap(nextExpressionResult, expressionResult, operator);
					else if (expressionResult.getValueDataType() == ValueDataType.LIST && nextExpressionResult.getValueDataType() == ValueDataType.NUMBER)
						expressionResult = operateOnList(expressionResult, nextExpressionResult, operator);
					else if (expressionResult.getValueDataType() == ValueDataType.NUMBER && nextExpressionResult.getValueDataType() == ValueDataType.LIST)
						expressionResult = operateOnList(nextExpressionResult, expressionResult, operator);
					else
					{
					  	printOperandDataTypeError(new String[] { "SET/NUMBER", "NUMBER/SET", "MAP/NUMBER", "NUMBER/MAP", "LIST/NUMBER", "NUMBER/LIST" }, expressionResult, nextExpressionResult, operator);
					  	return null;
					}
				else if (expressionResult.getValueDataType() == ValueDataType.SET && nextExpressionResult.getValueDataType() == ValueDataType.NUMBER)
				{
				  	if (nextExpressionResult.getNumberValue() == 0d)
					{
					  	printMessage(operator, "Division by zero");
					  	return null;
					}
					expressionResult = operateOnSet(expressionResult, nextExpressionResult, operator);
				}
				else if (expressionResult.getValueDataType() == ValueDataType.MAP && nextExpressionResult.getValueDataType() == ValueDataType.NUMBER)
				{
				  	if (nextExpressionResult.getNumberValue() == 0d)
					{
					  	printMessage(operator, "Division by zero");
					  	return null;
					} 
					expressionResult = operateOnMap(expressionResult, nextExpressionResult, operator);
				}
				else if (expressionResult.getValueDataType() == ValueDataType.LIST && nextExpressionResult.getValueDataType() == ValueDataType.NUMBER)
				{
				  	if (nextExpressionResult.getNumberValue() == 0d)
					{
					  	printMessage(operator, "Division by zero");
					  	return null;
					} 
					expressionResult = operateOnList(expressionResult, nextExpressionResult, operator);
				}
				else
				{
			  		printOperandDataTypeError(new String[] { "SET/NUMBER", "MAP/NUMBER", "LIST/NUMBER" }, expressionResult, nextExpressionResult, operator);
			  		return null;
				}
			}
		}
	)*
	{ return expressionResult; }
}

private CaplValue valueExpression6(Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Mutability mutability, Set<String> referencedIdentifiers, boolean evaluate):
{
  	CaplValue expressionResult;
}
{
  	(	  	< NOT > expressionResult = valueExpression7(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
	  	{
	  	  	if (evaluate)
	  	  		if (expressionResult == null)
	  	  			return null;
		  	  	else if (expressionResult.getValueDataType() == ValueDataType.BOOLEAN)
					expressionResult = new CaplValue(!expressionResult.getBooleanValue());
				else
				{
				  	printOperandDataTypeError(new String[] { "BOOLEAN" }, expressionResult, "NOT");
				  	return null;
				}
	  	}
	 	|
	 	< MINUS > expressionResult = valueExpression7(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
	  	{
	  	  	if (evaluate)
	  	  		if (expressionResult == null)
	  	  			return null;
		  	  	else if (expressionResult.getValueDataType() == ValueDataType.NUMBER)
					expressionResult = new CaplValue(-expressionResult.getNumberValue());
				else
				{
				  	printOperandDataTypeError(new String[] { "NUMBER" }, expressionResult, "UNARY MINUS");
				  	return null;
				}
	  	}
	 	| 
		expressionResult = valueExpression7(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
	)
	{
  	  	return expressionResult;
  	}
}

private CaplValue valueExpression7(Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Mutability mutability, Set<String> referencedIdentifiers, boolean evaluate):
{
  	Token function = null;
  	
  	CaplValue expressionResult = null,
  			  nextExpressionResult = null;
}
{
  	(
  	  	expressionResult = valueExpression(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
  	 	|
	    [ function = < LOG > | function = < ABS > | function = < FLOOR > | function = < CEIL > ]
	    < LEFT_PARENTHESIS > expressionResult = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate) < RIGHT_PARENTHESIS >
		{
			if (function != null && evaluate)
			{
			  	if (expressionResult == null)
		  	  		return null;

			  	if (expressionResult.getValueDataType() == ValueDataType.NUMBER)
			  		if (function.kind == CaplInterpreterConstants.LOG)
			  			expressionResult = new CaplValue(Math.log(expressionResult.getNumberValue()));
			  		else if (function.kind == CaplInterpreterConstants.ABS)
			  			expressionResult = new CaplValue(Math.abs(expressionResult.getNumberValue()));
			  		else if (function.kind == CaplInterpreterConstants.FLOOR)
			  			expressionResult = new CaplValue(Math.floor(expressionResult.getNumberValue()));
			  		else expressionResult = new CaplValue(Math.ceil(expressionResult.getNumberValue()));
				else if (expressionResult.getValueDataType() == ValueDataType.SET)
			  	  		expressionResult = operateOnSet(expressionResult, null, function);
			  	  	else if (expressionResult.getValueDataType() == ValueDataType.MAP)
			  	  		expressionResult = operateOnMap(expressionResult, null, function);
			  	  	else if (expressionResult.getValueDataType() == ValueDataType.LIST)
			  	  		expressionResult = operateOnList(expressionResult, null, function);
			  	  	else
					{ 
						printOperandDataTypeError(new String[] { "NUMBER", "SET", "MAP", "LIST" }, expressionResult, function);
						return null;
					}
			}
		}
		|
		(		  	function = < MIN > | function = < MAX >
		)
		< LEFT_PARENTHESIS >
 			expressionResult = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
 			< COMMA >
 			nextExpressionResult = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
	 	<  RIGHT_PARENTHESIS >
	 	{
	 	  	if (evaluate)
				if (expressionResult == null || nextExpressionResult == null)
	  	  			return null;
		  	  	else if (expressionResult.getValueDataType() != ValueDataType.NUMBER)
				{ 
					printOperandDataTypeError(new String[] { "NUMBER" }, expressionResult, function);
					return null;
				}
				else if (nextExpressionResult.getValueDataType() != ValueDataType.NUMBER)
				{ 
					printOperandDataTypeError(new String[] { "NUMBER" }, nextExpressionResult, function);
					return null;
				}
	  			else if (function.kind == CaplInterpreterConstants.MIN)
	  				expressionResult = new CaplValue(Math.min(expressionResult.getNumberValue(), nextExpressionResult.getNumberValue()));
	  			else expressionResult = new CaplValue(Math.max(expressionResult.getNumberValue(), nextExpressionResult.getNumberValue()));
	 	}
		|
	 	expressionResult = collectionInitializer(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, true)
	)
	[
  	  	expressionResult = collectionElement(expressionResult, stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
  	  	[
  	  		< EXISTS > 
	  	  	{
	  			if (evaluate)
	  				if (expressionResult == null)
	  					return new CaplValue(false);
	  				else return new CaplValue(true);
	  			return EMPTY_CAPL_VALUE; 		  	
	  	  	}
	  	  	|
	  	  	< NOT_NULL >
	  	  	{
	 			if (evaluate)
	  				if (expressionResult == null || expressionResult.getValueDataType() == ValueDataType.NA)
	  					return new CaplValue(false);
	  				else return new CaplValue(true);
	  			return EMPTY_CAPL_VALUE;
	  	  	}
  		]
  		{
  		  	if (expressionResult == null)
  		  	{
  		  	  	printMessage("Referenced collection element does not exist");
  		  	  	return null;
  		  	}
  		}
	]
  	[
  		expressionResult = aggregation(expressionResult, stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
  		{
  		  	if (expressionResult == null)
  		  		return null;
  		}
		|
		expressionResult = collectionValueContains(expressionResult, stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
		{
  		  	if (expressionResult == null)
  		  		return null;
  		}
		|
		expressionResult = indexOf(expressionResult, stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
		{
  		  	if (expressionResult == null)
  		  		return null;
  		}
		|
		expressionResult = collectionManipulation(expressionResult, stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
		{
  		  	if (expressionResult == null)
  		  		return null;
  		}
		|
		expressionResult = topOrBottom(expressionResult, stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
		{
  		  	if (expressionResult == null)
  		  		return null;
  		}
	]
	[
	  	expressionResult = castFromValue(expressionResult, stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, evaluate)
	]
	{
  	  	return expressionResult;
  	}
}

private boolean assignment(Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Mutability mutability, Set<String> referencedIdentifiers, boolean debug):
{
  	String identifierAsString = null;

  	CaplValue caplValue;

	if (debug)
		printMessage("Parsing \"assignment\"", Level.TRACE);
}
{
  	< IDENTIFIER >
	{
	    identifierAsString = token.toString();
	    if (stateCaplValues.containsKey(identifierAsString)) 
  		{
  		  	printMessage("Attempt to define " + mutability + " \"" + identifierAsString + "\" more than once");
  		  	return false;
  		}
	}
	< COLON >
	caplValue = valueExpression1(stateCaplValues, eventCaplValue, mutability, referencedIdentifiers, true)
	{
	   	if (caplValue == null)
	   		return false;
   		stateCaplValues.put(identifierAsString, caplValue);
   		if (debug)
   			LOGGER.debug("[Line " + token.beginLine + "] >> " + identifierAsString + " = " + caplValue);
		return true;
	}
}

private boolean settings(Map<String, CaplValue> stateCaplValues, Set<String> referencedIdentifiers):
{
  	CaplValue debugCaplValue = new CaplValue(false),
  		  	  eventRecordingCaplValue = new CaplValue(false),
			  expiresCaplValue;

  	printMessage("Parsing \"settings\"", Level.TRACE);

  	stateCaplValues.put("*eventRecording*", eventRecordingCaplValue);
}
{
  	< SETTINGS > < COLON >
  	[
	  	< DEBUG > < COLON > debugCaplValue = valueExpression1(stateCaplValues, null, Mutability.CONSTANT, referencedIdentifiers, true)
	  	{
	  	  	if (debugCaplValue == null)
	  	  		return false;
	  	  	if (debugCaplValue.getValueDataType() == ValueDataType.BOOLEAN)
	  	  		stateCaplValues.put("*debug*", debugCaplValue);
	  	  	else
	  	  	{
	  	  	  	printOperandDataTypeError(new String[] { "BOOLEAN" }, debugCaplValue, ":");
	  	  	  	return false;
	  	  	}
	  	}
	  	< COMMA >
	]
  	[
	  	< EVENT_RECORDING > < COLON > eventRecordingCaplValue = valueExpression1(stateCaplValues, null, Mutability.CONSTANT, referencedIdentifiers, true)
	  	{
	  	  	if (eventRecordingCaplValue == null)
	  	  		return false;
	  	  	if (eventRecordingCaplValue.getValueDataType() == ValueDataType.BOOLEAN)
		  		stateCaplValues.put("*eventRecording*", eventRecordingCaplValue);
		  	else
		  	{
		  	  	printOperandDataTypeError(new String[] { "BOOLEAN" }, eventRecordingCaplValue, ":");
		  	  	return false;
		  	}
	  	}
  		< COMMA >
	]
  	< EXPIRES > < COLON > expiresCaplValue = valueExpression1(stateCaplValues, null, Mutability.CONSTANT, referencedIdentifiers, true)
  	{
  	  	if (expiresCaplValue == null)
  	  		return false;
  	  	if (expiresCaplValue.getValueDataType() == ValueDataType.NUMBER)
  	  		if (expiresCaplValue.getNumberValue() >= 0d)
	  			stateCaplValues.put("*expires*", expiresCaplValue);
	  		else
	  		{
	  		  	printOperandDataTypeError(new String[] { "NON-NEGATIVE NUMBER" }, expiresCaplValue, ":");
	  	  		return false;
	  	  	}
	  	else
	  	{
	  	  	printOperandDataTypeError(new String[] { "NUMBER" }, expiresCaplValue, ":");
	  	  	return false;
	  	}
  	}
  	< SEMICOLON > { return true; }
}

private boolean constants(Map<String, CaplValue> stateCaplValues, Set<String> referencedIdentifiers, boolean debug):
{
  	boolean result = true;

	if (debug)
  		printMessage("Parsing \"constants\"", Level.TRACE);
}
{
  	< CONSTANTS > < COLON > [
  								result = assignment(stateCaplValues, null, Mutability.CONSTANT, referencedIdentifiers, debug)
  								{
  								  	if (!result)
  								  		return false;
  								}
  								(									< COMMA > result = assignment(stateCaplValues, null, Mutability.CONSTANT, referencedIdentifiers, debug)
	  								{
	  								  	if (!result)
	  								  		return false;
	  								}
  								)*
  							]
  							< SEMICOLON >
  							{
  							  	makeImmutable(stateCaplValues);
  							  	return true;
  							} 
}

private boolean variables(Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Set<String> referencedIdentifiers, boolean debug):
{
  	boolean result = true;

	if (debug)
  		printMessage("Parsing \"variables\"", Level.TRACE);
}
{
	< VARIABLES > < COLON > [
  								result = assignment(stateCaplValues, eventCaplValue, Mutability.VARIABLE, referencedIdentifiers, debug)
  								{
  								  	if (!result)
  								  		return false;
  								}
  								(
									< COMMA > result = assignment(stateCaplValues, eventCaplValue, Mutability.VARIABLE, referencedIdentifiers, debug)
	  								{
	  								  	if (!result)
	  								  		return false;
	  								}
  								)*
  							]
  							< SEMICOLON > { return true; }
}

private boolean thenElse(Map<String, CaplValue> stateCaplValues, Map<String, CaplValue> outputCaplValues, CaplValue eventCaplValue,
					 	 Set<String> referencedIdentifiers, boolean isUpdateRule,
					 	 String identifierAsString, CaplValue referencedCaplValue, boolean preCondition, boolean debug):
{
  	CaplValue updateCaplValue = null;
  			  
	if (debug)
		printMessage("Parsing \"thenElse\"", Level.TRACE);
}
{
	updateCaplValue = valueExpression1(stateCaplValues, eventCaplValue, Mutability.VARIABLE, referencedIdentifiers, preCondition)
	{
	  	if (preCondition)
	  	{ 
			if (updateCaplValue == null)
		  	{
		  	  	printMessage("The rule for identifier \"" + (identifierAsString == null ? "< NOT SPECIFIED >" : identifierAsString) + "\" in this rules section produced an invalid value");
		   	  	return false;
		  	}
		  	if (isUpdateRule && identifierAsString != null && updateCaplValue.getValueDataType() != referencedCaplValue.getValueDataType())
		  	{
		  	  	printMessage("Incompatible data types between identifier \"" + identifierAsString + "\" and the specified rule: " + referencedCaplValue.getValueDataType() + " versus " + updateCaplValue.getValueDataType());
		   	  	return false;
		  	}
		  	if (identifierAsString != null)
		  	{
		  	  	updateCaplValue.setMutability(Mutability.VARIABLE); // Even if the updateCaplValue is a CONSTANT, the left side of the assignment is a VARIABLE and we want the new value to be a VARIABLE as well.
				outputCaplValues.put(identifierAsString, updateCaplValue);
				if (debug)
   					LOGGER.debug("[Line " + token.beginLine + "] >> " + identifierAsString + " = " + updateCaplValue);
			}
		}
		return true;
	}
}

private boolean evaluateAssignment(Map<String, CaplValue> stateCaplValues, Map<String, CaplValue> outputCaplValues, CaplValue eventCaplValue,
								   Set<String> referencedIdentifiers, boolean isUpdateRule, boolean preCondition, boolean debug):
{
	String identifierAsString = null;

  	CaplValue referencedCaplValue = null;
  			  
  	boolean success;

	if (debug)
		printMessage("Parsing \"evaluateAssignment\"", Level.TRACE);
}
{
	[
	  	< IDENTIFIER >
		{
		    identifierAsString = token.toString();
		    if (isUpdateRule)
		    { 
			    referencedCaplValue = stateCaplValues.get(identifierAsString);
			   	if (referencedCaplValue == null)
			   	{
			   	  	printMessage("Identifier \"" + identifierAsString + "\" has not been defined in the \"variables\" section");
			   	  	return false;
			   	}
			   	if (referencedCaplValue.getMutability() == Mutability.CONSTANT)
			   	{
			   	  	printMessage("Identifier \"" + identifierAsString + "\" references a constant and thus cannot be updated in this rules section");
			   	  	return false;
			   	}
			}
			// else the identifier is an output label rather than a previously defined variable.
			else if (outputCaplValues.containsKey(identifierAsString))
			{
			  	printMessage("Duplicate output label \"" + identifierAsString + "\"");
		   	  	return false;
			}
		}
	]
	< COLON >
	success = thenElse(stateCaplValues, outputCaplValues, eventCaplValue, referencedIdentifiers, isUpdateRule, identifierAsString, referencedCaplValue, preCondition, debug)
  	{
  	  	if (!success)
  	  		return false;
  	}
  	[
		< ELSE >
	  	success = thenElse(stateCaplValues, outputCaplValues, eventCaplValue, referencedIdentifiers, isUpdateRule, identifierAsString, referencedCaplValue, !preCondition, debug)
  	  	{
  	  	  	if (!success)
  	  	  		return false;
  	  	}
  	]
  	{
  	  	return true;
  	}
}

private boolean rule(Map<String, CaplValue> stateCaplValues, Map<String, CaplValue> outputCaplValues, CaplValue eventCaplValue,
					 Set<String> referencedIdentifiers, boolean isUpdateRule, boolean debug):
{
  	CaplValue conditionCaplValue = null;
  			  
  	boolean preCondition = true,
  			success;

	if (debug)
		printMessage("Parsing \"rule\"", Level.TRACE);
}
{
	// Left side of the assignment is optional so that collection operations can be performed without having to assign the outcome to an identifier.
	[
		conditionCaplValue = valueExpression1(stateCaplValues, eventCaplValue, Mutability.VARIABLE, referencedIdentifiers, true)
		{
		   	if (conditionCaplValue == null)
		   	{ 
		   		printMessage("The condition in this rules section is invalid");
		   	  	return false;
		    }
		   	if (conditionCaplValue.getValueDataType() != ValueDataType.BOOLEAN)
			{
				printMessage("The condition in this rules section is not a BOOLEAN value");
		   	  	return false;
			}
			preCondition = conditionCaplValue.getBooleanValue();
			if (debug)
   				LOGGER.debug("[Line " + token.beginLine + "] >> precondition is " + preCondition);
		}
	]
	< COLON >
	success = evaluateAssignment(stateCaplValues, outputCaplValues, eventCaplValue, referencedIdentifiers, isUpdateRule, preCondition, debug)
	{
		if (!success)
			return false;
	}
	(
	  	< NEXT_EVAL >		success = evaluateAssignment(stateCaplValues, outputCaplValues, eventCaplValue, referencedIdentifiers, isUpdateRule, preCondition, debug)
		{
			if (!success)
				return false;
		}
	)*
	{
		return true;
	}
}

private boolean updateRules(Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Set<String> referencedIdentifiers, boolean debug):
{
  	boolean result = true;

  	if (debug)
  		printMessage("Parsing \"updateRules\"", Level.TRACE);
}
{
	< UPDATES > < COLON > [
							result = rule(stateCaplValues, stateCaplValues, eventCaplValue, referencedIdentifiers, true, debug)
							{
							  	if (!result)
							  		return false;
							}
  			 				(  			 				   < COMMA > result = rule(stateCaplValues, stateCaplValues, eventCaplValue, referencedIdentifiers, true, debug)
  			 				   {
  			 				     	if (!result)
  			 				     		return false;
  			 				   }
  			 				)*
  			 			  ]
  			 			  < SEMICOLON > { return true; }
}

private HashMap<String, CaplValue> outputRules(Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Set<String> referencedIdentifiers, boolean debug):
{
  	final HashMap<String, CaplValue> outputCaplValues = new LinkedHashMap<String, CaplValue>();

  	boolean result = true;

	if (debug)
  		printMessage("Parsing \"outputRules\"", Level.TRACE);
}
{
	< OUTPUTS > < COLON > [
							result = rule(stateCaplValues, outputCaplValues, eventCaplValue, referencedIdentifiers, false, debug)
							{
							  	if (!result)
							  		return null;
							}
  			 				(
  			 				   < COMMA > result = rule(stateCaplValues, outputCaplValues, eventCaplValue, referencedIdentifiers, false, debug)
  			 				   {
  			 				     	if (!result)
  			 				     		return null;
  			 				   }
  			 				)*
  			 			  ]
  			 			  < SEMICOLON > { return outputCaplValues; }
}

private HashMap<String, CaplValue> rules(Map<String, CaplValue> stateCaplValues, CaplValue eventCaplValue, Set<String> referencedIdentifiers, boolean debug):
{
  	HashMap<String, CaplValue> outputCaplValues = null;

  	boolean result;

	if (debug)
  		printMessage("Parsing \"rules\"", Level.TRACE);
}
{
	result = updateRules(stateCaplValues, eventCaplValue, referencedIdentifiers, debug) { if (!result) return null; }
	outputCaplValues = outputRules(stateCaplValues, eventCaplValue, referencedIdentifiers, debug) { if (outputCaplValues == null) return null; }
	< EOF >
	{
	  	if (referencedIdentifiers != null && referencedIdentifiers.size() < stateCaplValues.size())
			for (String identifier: stateCaplValues.keySet())
				if (!referencedIdentifiers.contains(identifier) && !identifier.startsWith("*"))	  	  	
	  				printMessage("Declared " + stateCaplValues.get(identifier).getMutability() + " \"" + identifier + "\" is not used", Level.WARN);
	  	return outputCaplValues;
	}
}

TOKEN_MGR_DECLS:
{}