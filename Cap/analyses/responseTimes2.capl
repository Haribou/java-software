# We classify tweets according to two sets of words into 4 groups: tweets containing words from set 1, tweets containing words from set 2, 
# tweets containing words from both sets, and tweets not containing words from either set.
# Then, we measure response times, inter-arrival times, response ratios, etc., for all four groups.

debug: 				off;

constants:

WINDOW_SIZE: 		100000,
EVERY: 				100,
WORDS1: 			set("delayed", "lost", "cancel", "rude", "awful", "terrible", "wrong", "vaccin", "vax", "covid", "ridiculous", "hate", "suck", "wors", "missed", "joke", "shit", "crap", "piss", "bitch", "ass", "fuck", "trash", "idiot", "poor", "hell", "complain", "unacceptable", "wtf", "stupid", "excuse", "nobody", "respect", "problem", "racis", "disappoint", "mess", "refuse", "error", "unbelievable", "kick", "nasty", "frustrating", "lie"),
WORDS2: 			set("happy", "love", "luv", "thank", "wow", "good", "nice", "awesome", "cool", "friendly", "best", "appreciate", "wonderful", "great", "grateful", "perfect");

variables:

retweets: 			map("words1": 0, "words2": 0, "both": 0, "none": 0),
tweeters: 			map("words1": set[WINDOW_SIZE], "words2": set[WINDOW_SIZE], "none": set[WINDOW_SIZE], "both": set[WINDOW_SIZE]),
lastTweetTimes: 	map("words1": 0, "words2": 0, "both": 0, "none": 0),
interArrivalTimes: 	map("words1": list[WINDOW_SIZE], "words2": list[WINDOW_SIZE], "none": list[WINDOW_SIZE], "both": list[WINDOW_SIZE]),
tweetTimes: 		map("words1": map[WINDOW_SIZE], "words2": map[WINDOW_SIZE], "none": map[WINDOW_SIZE], "both": map[WINDOW_SIZE]),
unrespondedTweets: 	map("words1": set[WINDOW_SIZE], "words2": set[WINDOW_SIZE], "none": set[WINDOW_SIZE], "both": set[WINDOW_SIZE]),
responseTimes: 		map("words1": list[WINDOW_SIZE], "words2": list[WINDOW_SIZE], "none": list[WINDOW_SIZE], "both": list[WINDOW_SIZE]),

numAllTweets:		0,
responseTime: 		0,
isRetweet: 			false,
hasExtendedText: 	false,
tweet: 				"",
rTweetId:			"", 
hasWord1: 			false,
hasWord2: 			false,
wordSelector: 		"";

updateRules:

numAllTweets:													: numAllTweets + 1,
isRetweet:														: @["retweeted_status"] exists,
rTweetId:														: "",
rTweetId: 			isRetweet									: @["retweeted_status"]["id_str"],
rTweetId: 			!isRetweet & @["in_reply_to_status_id_str"] notNull	: @["in_reply_to_status_id_str"],

# Classify tweets into "words1", "words2", "both", "none", based on tweet content, to be found in various payload locations based on RT and length of tweet text:
hasExtendedText: 	isRetweet									: @["retweeted_status"]["extended_tweet"] exists,
tweet: 				isRetweet & hasExtendedText					: @["retweeted_status"]["extended_tweet"]["full_text"],
tweet: 				isRetweet & !hasExtendedText				: @["retweeted_status"]["text"],
hasExtendedText: 	!isRetweet									: @["extended_tweet"] exists,
tweet: 				!isRetweet & hasExtendedText				: @["extended_tweet"]["full_text"],
tweet: 				!isRetweet & !hasExtendedText				: @["text"],
hasWord1:														: tweet containsSome?(WORDS1),
hasWord2:														: tweet containsSome?(WORDS2),
wordSelector: 		hasWord1 & hasWord2							: "both",
wordSelector: 		hasWord1 & !hasWord2						: "words1",
wordSelector: 		!hasWord1 & hasWord2						: "words2",
wordSelector: 		!hasWord1 & !hasWord2						: "none",

# Update data collections for classified tweet:
:																: unrespondedTweets[wordSelector] add(@["id_str"]),
: 					isRetweet									: retweets add(wordSelector: retweets[wordSelector] + 1),
:																: tweeters[wordSelector] add(@["user"]["screen_name"]),
: 					lastTweetTimes[wordSelector] > 0			: interArrivalTimes[wordSelector] add(now - lastTweetTimes[wordSelector]),
:																: tweetTimes[wordSelector] add(@["id_str"]: now),
responseTime: 		rTweetId ~ "" & tweetTimes[wordSelector] containsKeys(rTweetId): (now - tweetTimes[wordSelector][rTweetId]) / 1000 else 0,
: 					responseTime > 0							: responseTimes[wordSelector] add(responseTime),
: 					responseTime > 0							: unrespondedTweets[wordSelector] remove(rTweetId),
:																: lastTweetTimes add(wordSelector: now),
:																: interArrivalTimes[wordSelector] add(now - lastTweetTimes[wordSelector]);

outputRules:

word1TweetersCount: 		numEvents % EVERY = 0											: tweetTimes["words1"] countKeys,
word1Percentage: 			numEvents % EVERY = 0											: 100 * tweetTimes["words1"] countKeys / numAllTweets + "%",
word2TweetersCount: 		numEvents % EVERY = 0											: tweetTimes["words2"] countKeys,
word2Percentage: 			numEvents % EVERY = 0											: 100 * tweetTimes["words2"] countKeys / numAllTweets + "%",
bothTweetersCount: 			numEvents % EVERY = 0											: tweetTimes["both"] countKeys,
bothPercentage: 			numEvents % EVERY = 0											: 100 * tweetTimes["both"] countKeys / numAllTweets + "%",
noneTweetersCount: 			numEvents % EVERY = 0											: tweetTimes["none"] countKeys,
nonePercentage: 			numEvents % EVERY = 0											: 100 * tweetTimes["none"] countKeys / numAllTweets + "%",

word1TweetsPerTweeter: 		numEvents % EVERY = 0 & tweetTimes["words1"] countKeys > 0		: tweetTimes["words1"] countKeys / tweeters["words1"] count,
word2TweetsPerTweeter: 		numEvents % EVERY = 0 & tweetTimes["words2"] countKeys > 0		: tweetTimes["words2"] countKeys / tweeters["words2"] count,
bothTweetsPerTweeter: 		numEvents % EVERY = 0 & tweetTimes["both"] countKeys > 0		: tweetTimes["both"] countKeys / tweeters["both"] count,
noneTweetsPerTweeter: 		numEvents % EVERY = 0 & tweetTimes["none"] countKeys > 0		: tweetTimes["none"] countKeys / tweeters["none"] count,

word1RetweetRatio: 			numEvents % EVERY = 0 & tweetTimes["words1"] countKeys > 0		: 100 * retweets["words1"] / tweetTimes["words1"] countKeys + "%",
word2RetweetRatio: 			numEvents % EVERY = 0 & tweetTimes["words2"] countKeys > 0		: 100 * retweets["words2"] / tweetTimes["words2"] countKeys + "%",
bothRetweetRatio: 			numEvents % EVERY = 0 & tweetTimes["both"] countKeys > 0		: 100 * retweets["both"] / tweetTimes["both"] countKeys + "%",
noneRetweetRatio: 			numEvents % EVERY = 0 & tweetTimes["none"] countKeys > 0		: 100 * retweets["none"] / tweetTimes["none"] countKeys + "%",

word1AvgResponseTime: 		numEvents % EVERY = 0 & responseTimes["words1"] count > 0		: responseTimes["words1"] avg + " sec",
word2AvgResponseTime: 		numEvents % EVERY = 0 & responseTimes["words2"] count > 0		: responseTimes["words2"] avg + " sec",
bothAvgResponseTime: 		numEvents % EVERY = 0 & responseTimes["both"] count > 0			: responseTimes["both"] avg + " sec",
noneAvgResponseTime: 		numEvents % EVERY = 0 & responseTimes["none"] count > 0			: responseTimes["none"] avg + " sec",

word1ResponseRates: 		numEvents % EVERY = 0 & tweetTimes["words1"] countKeys > 0		: 100 * (tweetTimes["words1"] countKeys - unrespondedTweets["words1"] count) / tweetTimes["words1"] countKeys + "%",
word2ResponseRates: 		numEvents % EVERY = 0 & tweetTimes["words2"] countKeys > 0		: 100 * (tweetTimes["words2"] countKeys - unrespondedTweets["words2"] count) / tweetTimes["words2"] countKeys + "%",
bothResponseRates: 			numEvents % EVERY = 0 & tweetTimes["both"] countKeys > 0		: 100 * (tweetTimes["both"] countKeys - unrespondedTweets["both"] count) / tweetTimes["both"] countKeys + "%",
noneResponseRates: 			numEvents % EVERY = 0 & tweetTimes["none"] countKeys > 0		: 100 * (tweetTimes["none"] countKeys - unrespondedTweets["none"] count) / tweetTimes["none"] countKeys + "%",

word1InterArrivalTimesAvg: 	numEvents % EVERY = 0 & interArrivalTimes["words1"] count > 0	: interArrivalTimes["words1"] avg + " ms",
word2InterArrivalTimesAvg: 	numEvents % EVERY = 0 & interArrivalTimes["words2"] count > 0	: interArrivalTimes["words2"] avg + " ms",
bothInterArrivalTimesAvg: 	numEvents % EVERY = 0 & interArrivalTimes["both"] count > 0		: interArrivalTimes["both"] avg + " ms",
noneInterArrivalTimesAvg: 	numEvents % EVERY = 0 & interArrivalTimes["none"] count > 0		: interArrivalTimes["none"] avg + " ms",

word1InterArrivalTimes:		numEvents % EVERY = 0 & interArrivalTimes["words1"] count > 0	: interArrivalTimes["words1"] histo(0, 100, 300),
word2InterArrivalTimes: 	numEvents % EVERY = 0 & interArrivalTimes["words2"] count > 0	: interArrivalTimes["words2"] histo(0, 100, 300),
bothInterArrivalTimes: 		numEvents % EVERY = 0 & interArrivalTimes["both"] count > 0		: interArrivalTimes["both"] histo(0, 100, 300),
noneInterArrivalTimes:	 	numEvents % EVERY = 0 & interArrivalTimes["none"] count > 0		: interArrivalTimes["none"] histo(0, 100, 300);